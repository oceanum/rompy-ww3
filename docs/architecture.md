# Component-Based Architecture

## Overview

The rompy-ww3 package follows a clean, modular architecture designed to provide direct access to WAVEWATCH III (WW3) namelist functionality while maintaining type safety and ease of use.

This architecture introduces dedicated **Component Models** for each major WW3 control file, building upon the existing clean architecture principles while providing enhanced modularity and flexibility for configuring WAVEWATCH III (WW3) model runs.

## Key Principles

### 1. **Component Encapsulation**
Each WW3 control file is represented by a dedicated component class that encapsulates all related namelist objects:

- `ShellComponent` → `ww3_shel.nml` (Main model configuration)
- `GridComponent` → `ww3_grid.nml` (Grid preprocessing configuration)
- `MultiComponent` → `ww3_multi.nml` (Multi-grid model configuration)
- `BoundaryComponent` → `ww3_bound.nml` (Boundary preprocessing configuration)
- `BoundaryUpdateComponent` → `ww3_bounc.nml` (Boundary update configuration)
- `ControlComponent` → `ww3_prnc.nml` (Print control configuration)
- `TrackComponent` → `ww3_trnc.nml` (Track output configuration)
- `UnformattedOutputComponent` → `ww3_ounf.nml` (Unformatted output configuration)
- `PointOutputComponent` → `ww3_ounp.nml` (Point output configuration)
- `RestartUpdateComponent` → `ww3_uprstr.nml` (Restart update configuration)
- `ParametersComponent` → `namelists.nml` (Model parameters configuration)

### 2. **Unified Interface**
All components inherit from a common base class `WW3ComponentBaseModel` that provides:

- Consistent `render()` method for generating namelist content
- Backward compatibility with existing `NamelistBaseModel` interface
- Type safety and validation through Pydantic V2

### 3. **Composability**
Components can be composed together to create complete model configurations:

```python
from rompy_ww3.components import (
    ShellComponent, 
    GridComponent, 
    MultiComponent,
    BoundaryComponent
)
from rompy_ww3.namelists import (
    Domain, Input, OutputType, OutputDate,
    Spectrum, Run, Timesteps, Bound
)

# Create individual components
shell = ShellComponent(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T", "water_levels": "T"}),
    output_type=OutputType(field={"list": "HSIGN TMM10 TM02 PDIR PENT"}),
    output_date=OutputDate(field_start="20230101 000000", field_stride="3600")
)

grid = GridComponent(
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)

boundary = BoundaryComponent(
    bound=Bound(mode="READ", file="boundary_spec.nc", interp=2)
)

# Components work together through the Config class
config = Config(
    shell_component=shell,
    grid_component=grid,
    boundary_component=boundary
)
```

### 4. **Backward Compatibility**
The component-based architecture maintains full backward compatibility:

- Existing namelist objects continue to work as before
- Traditional Config usage patterns remain unchanged
- Components can be mixed with traditional namelist objects
- No breaking changes to existing APIs

## Component Structure

### Component Base Class
All components inherit from `WW3ComponentBaseModel` which provides:

```python
from rompy_ww3.components.basemodel import WW3ComponentBaseModel

class MyComponent(WW3ComponentBaseModel):
    def render(self) -> str:
        """Render the component to a namelist string."""
        # Implementation specific to each component
        pass
        
    def write_nml(self, workdir: Union[Path, str]) -> None:
        """Write the rendered component to a namelist file."""
        # Implementation provided by base class
        pass
```

### Component Fields
Each component defines fields for the namelist objects it manages:

```python
class ShellComponent(WW3ComponentBaseModel):
    """Component for ww3_shel.nml containing shell configuration."""
    
    domain: Optional[Domain] = None
    input_nml: Optional[InputForcing] = None
    output_type: Optional[OutputType] = None
    output_date: Optional[OutputDate] = None
    homog_count: Optional[HomogCount] = None
    homog_input: Optional[List[HomogInput]] = None
```

### Component Rendering
Components provide unified rendering through the `render()` method:

```python
def render(self) -> str:
    """Render the shell component as a combined namelist string."""
    shel_content = []
    shel_content.append("! WW3 main model configuration")
    shel_content.append("! Generated by rompy-ww3")
    shel_content.append("")

    # Add DOMAIN_NML
    if self.domain:
        rendered = self.domain.render().replace("\\n", "\n")
        shel_content.extend(rendered.split("\n"))
        shel_content.append("")

    # Add INPUT_NML
    if self.input_nml:
        rendered = self.input_nml.render().replace("\\n", "\n")
        shel_content.extend(rendered.split("\n"))
        shel_content.append("")

    # ... add other namelists as needed
    
    return "\n".join(shel_content)
```

## Usage Patterns

### 1. Basic Component Usage
```python
from rompy_ww3.components import ShellComponent, GridComponent
from rompy_ww3.namelists import Domain, Input, Spectrum, Run, Timesteps

# Create components with namelist objects
shell = ShellComponent(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T"})
)

grid = GridComponent(
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)

# Generate namelist content
shell_content = shell.render()
grid_content = grid.render()
```

### 2. Component-Based Configuration
```python
from rompy_ww3.config import Config
from rompy_ww3.components import ShellComponent, GridComponent

# Create all required components
shell = ShellComponent(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T"})
)

grid = GridComponent(
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)

# Pass components to Config
config = Config(
    shell_component=shell,
    grid_component=grid
)

# Generate all namelist files
result = config(runtime=your_runtime_object)
```

### 3. Mixed Approach (Components + Traditional)
```python
from rompy_ww3.config import Config
from rompy_ww3.components import ShellComponent

# Mix components with traditional namelist objects
shell = ShellComponent(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T"})
)

# Traditional approach for other namelists
config = Config(
    shell_component=shell,  # Component-based
    spectrum=Spectrum(...),  # Traditional namelist object
    run=Run(...),           # Traditional namelist object
    timesteps=Timesteps(...) # Traditional namelist object
)
```

## Benefits

### 1. **Enhanced Organization**
- Clear separation of concerns with dedicated component classes
- Logical grouping of related namelist objects
- Easier maintenance and development

### 2. **Improved Reusability**
- Components can be reused across different configurations
- Easy composition of complex model setups
- Modular design promotes code reuse

### 3. **Better Type Safety**
- Strong typing through Pydantic validation
- Clear component interfaces
- IDE support with auto-completion

### 4. **Flexible Architecture**
- Components can be used independently or together
- Easy to extend with new component types
- Backward compatibility maintained

### 5. **Simplified Configuration**
- Reduced boilerplate code
- Clear component responsibilities
- Intuitive API design

## Migration Guide

### From Traditional Approach
```python
# OLD WAY - Direct namelist objects
config = Config(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T"}),
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)
```

### To Component-Based Approach
```python
# NEW WAY - Component-based approach
shell = ShellComponent(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T"})
)

grid = GridComponent(
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)

config = Config(
    shell_component=shell,
    grid_component=grid
)
```

### Gradual Migration
The transition can be gradual - mix components with traditional namelist objects:

```python
# MIGRATION STEP - Mix approaches
config = Config(
    shell_component=ShellComponent(...),  # New component approach
    spectrum=Spectrum(...),              # Traditional approach
    run=Run(...),                        # Traditional approach
    timesteps=Timesteps(...)             # Traditional approach
)
```

## Future Development

The component-based architecture provides a solid foundation for future enhancements:

### 1. **Advanced Components**
- Specialized components for domain-specific use cases
- Composite components that combine multiple simpler components
- Dynamic components that adapt based on configuration

### 2. **Enhanced Composition**
- Component composition patterns and best practices
- Validation across multiple components
- Dependency management between components

### 3. **Extended Functionality**
- Component lifecycle management
- Advanced rendering strategies
- Integration with external configuration systems

The component-based architecture represents the next evolution of rompy-ww3, building upon the clean architecture principles while providing enhanced modularity and flexibility for configuring WW3 model runs.