# Component-Based Architecture

## Overview

The rompy-ww3 package follows a clean, modular architecture designed to provide direct access to WAVEWATCH III (WW3) namelist functionality while maintaining type safety and ease of use.

This architecture introduces dedicated **Component Models** for each major WW3 control file, providing enhanced modularity and flexibility for configuring WAVEWATCH III (WW3) model runs.

## Key Principles

### 1. **Component Encapsulation**
Each WW3 control file is represented by a dedicated component class that encapsulates all related namelist objects:

- `Shel` → `ww3_shel.nml` (Main model configuration)
- `Grid` → `ww3_grid.nml` (Grid preprocessing configuration)
- `Multi` → `ww3_multi.nml` (Multi-grid model configuration)
- `Bound` → `ww3_bound.nml` (Boundary preprocessing configuration)
- `Bounc` → `ww3_bounc.nml` (Boundary update configuration)
- `Prnc` → `ww3_prnc.nml` (Field preprocessing configuration)
- `Trnc` → `ww3_trnc.nml` (Track output configuration)
- `Ounf` → `ww3_ounf.nml` (Field output configuration)
- `Ounp` → `ww3_ounp.nml` (Point output configuration)
- `Uptstr` → `ww3_upstr.nml` (Restart update configuration)
- `Namelists` → `namelists.nml` (Physics parameters configuration)

### 2. **Unified Interface**
All components inherit from a common base class `WW3ComponentBaseModel` that provides:

- Consistent `render()` method for generating namelist content
- Type safety and validation through Pydantic V2
- Standard file writing and execution functionality

### 3. **Composability**
Components can be composed together to create complete model configurations:

```python
from rompy_ww3.components import (
    Shel, 
    Grid, 
    Multi,
    Bound
)
from rompy_ww3.namelists import (
    Domain, Input, OutputType, OutputDate,
    Spectrum, Run, Timesteps, Bound as BoundNML
)

# Create individual components
shell = Shel(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T", "water_levels": "T"}),
    output_type=OutputType(field={"list": "HSIGN TMM10 TM02 PDIR PENT"}),
    output_date=OutputDate(field_start="20230101 000000", field_stride="3600")
)

grid = Grid(
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)

boundary = Bound(
    bound=BoundNML(mode="READ", file="boundary_spec.nc", interp=2)
)

# Components work together through the Config class
config = Config(
    ww3_shel=shell,
    ww3_grid=grid,
    ww3_bound=boundary
)
```

## Component Structure

### Component Base Class
All components inherit from `WW3ComponentBaseModel` which provides:

```python
from rompy_ww3.components.basemodel import WW3ComponentBaseModel

class MyComponent(WW3ComponentBaseModel):
    def render(self) -> str:
        """Render the component to a namelist string."""
        # Implementation specific to each component
        pass
        
    def write_nml(self, workdir: Union[Path, str]) -> None:
        """Write the rendered component to a namelist file."""
        # Implementation provided by base class
        pass
```

### Component Fields
Each component defines fields for the namelist objects it manages:

```python
class Shel(WW3ComponentBaseModel):
    """Component for ww3_shel.nml containing shell configuration."""
    
    domain: Optional[Domain] = None
    input_nml: Optional[Input] = None
    output_type: Optional[OutputType] = None
    output_date: Optional[OutputDate] = None
    homog_count: Optional[HomogCount] = None
    homog_input: Optional[List[HomogInput]] = None
```

### Component Rendering
Components provide unified rendering through the `render()` method:

```python
def render(self) -> str:
    """Render the shell component as a combined namelist string."""
    shel_content = []
    shel_content.append("! WW3 main model configuration")
    shel_content.append("! Generated by rompy-ww3")
    shel_content.append("")

    # Add DOMAIN_NML
    if self.domain:
        rendered = self.domain.render()
        shel_content.extend(rendered.split("\n"))
        shel_content.append("")

    # Add INPUT_NML
    if self.input_nml:
        rendered = self.input_nml.render()
        shel_content.extend(rendered.split("\n"))
        shel_content.append("")

    # ... add other namelists as needed
    
    return "\n".join(shel_content)
```

## Usage Patterns

### 1. Basic Component Usage
```python
from rompy_ww3.components import Shel, Grid
from rompy_ww3.namelists import Domain, Input, Spectrum, Run, Timesteps

# Create components with namelist objects
shell = Shel(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T"})
)

grid = Grid(
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)

# Generate namelist content
shell_content = shell.render()
grid_content = grid.render()
```

### 2. Component-Based Configuration
```python
from rompy_ww3.config import Config
from rompy_ww3.components import Shel, Grid

# Create all required components
shell = Shel(
    domain=Domain(start="20230101 000000", stop="20230107 000000"),
    input_nml=Input(forcing={"winds": "T"})
)

grid = Grid(
    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),
    run=Run(fldry=False, flcx=True, flcy=True),
    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)
)

# Pass components to Config
config = Config(
    ww3_shel=shell,
    ww3_grid=grid
)

# Generate all namelist files
result = config(runtime=your_runtime_object)
```

## Benefits

### 1. **Enhanced Organization**
- Clear separation of concerns with dedicated component classes
- Logical grouping of related namelist objects
- Easier maintenance and development

### 2. **Improved Reusability**
- Components can be reused across different configurations
- Easy composition of complex model setups
- Modular design promotes code reuse

### 3. **Better Type Safety**
- Strong typing through Pydantic validation
- Clear component interfaces
- IDE support with auto-completion

### 4. **Flexible Architecture**
- Components can be used independently or together
- Easy to extend with new component types
- Standardized interfaces across all components

### 5. **Simplified Configuration**
- Reduced boilerplate code
- Clear component responsibilities
- Intuitive API design

## Future Development

The component-based architecture provides a solid foundation for future enhancements:

### 1. **Advanced Components**
- Specialized components for domain-specific use cases
- Composite components that combine multiple simpler components
- Dynamic components that adapt based on configuration

### 2. **Enhanced Composition**
- Component composition patterns and best practices
- Validation across multiple components
- Dependency management between components

### 3. **Extended Functionality**
- Component lifecycle management
- Advanced rendering strategies
- Integration with external configuration systems

The component-based architecture provides enhanced modularity and flexibility for configuring WW3 model runs.