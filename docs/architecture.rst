Architecture and Design Decisions
=================================

This document explains the key architectural decisions behind rompy-ww3 and how the various components work together.

Overview
--------

rompy-ww3 follows a layered architecture that provides both high-level abstractions and low-level control:

1. **High-Level Objects**: Grid and Data objects provide intuitive interfaces for common tasks
2. **Namelist Layer**: Core WW3 namelist objects that map directly to WW3 control files
3. **Integration Layer**: Config class that bridges high-level objects with namelist configurations
4. **Execution Layer**: Model execution and file management

Design Philosophy
-----------------

The architecture follows these key principles:

Backward Compatibility
~~~~~~~~~~~~~~~~~~~~~~

Existing rompy configurations continue to work unchanged. Users can gradually adopt new features without breaking existing workflows.

.. code-block:: python

    # Traditional approach still works
    config = Config(
        domain=Domain(start="20080522 000000", stop="20080522 030000"),
        # Direct namelist objects
        depth=Depth(filename="depth.dat", sf=0.001, idf=50, idla=1),
        # ...
    )

Progressive Enhancement
~~~~~~~~~~~~~~~~~~~~~~~

Users can mix and match approaches based on their needs:

.. code-block:: python

    # Modern approach with Grid object
    config = Config(
        domain=Domain(start="20080522 000000", stop="20080522 030000"),
        # Grid object with intelligent defaults
        grid=Grid(
            name="Test Grid",
            grid_type="RECT",
            depth_file=Path("depth.dat"),  # Automatically creates DEPTH_NML
            # ...
        ),
        # ...
    )

Flexible Control
~~~~~~~~~~~~~~~~

Direct access to namelist objects is preserved for fine-grained control:

.. code-block:: python

    # Hybrid approach
    config = Config(
        domain=Domain(start="20080522 000000", stop="20080522 030000"),
        # Grid object for most configuration
        grid=Grid(
            name="Test Grid",
            grid_type="RECT",
            # ...
        ),
        # Override specific namelist objects when needed
        depth=Depth(filename="custom_depth.dat", sf=0.001, idf=50, idla=1),
        # ...
    )

Component Architecture
----------------------

High-Level Objects (Grid and Data)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Grid and Data objects provide intuitive interfaces for common WW3 configuration tasks:

**Grid Object**
    - Handles grid file management (depth, mask, obstacle files)
    - Automatically generates appropriate namelist objects
    - Provides validation and intelligent defaults
    - Supports multiple grid types (RECT, CURV, UNST, SMC)

**Data Object**
    - Manages forcing data preparation
    - Handles both file-based and homogeneous data
    - Integrates with rompy's Source system for data retrieval
    - Automatically generates WW3 preprocessing namelists

Namelist Layer
~~~~~~~~~~~~~~

Core namelist objects map directly to WW3 control file sections:

- Domain, Spectrum, Run, Timesteps
- Grid, Rect, Curv, Unst, Smc
- Depth, Mask, Obstacle, Slope, Sediment
- Forcing, Track, Point, Field
- And many more...

Each namelist object corresponds to a specific section in WW3 control files.

Integration Layer (Config Class)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Config class serves as the integration point that bridges high-level objects with namelist configurations:

1. **Automatic Extraction**: Pulls namelist information from Grid/Data objects
2. **Conflict Resolution**: Direct namelist objects take precedence over Grid/Data object values
3. **Template Generation**: Creates WW3 control files using Jinja2 templates
4. **File Management**: Coordinates staging and organization of input files

.. code-block:: python

    def generate_grid_namelist(self, output_path: Path) -> None:
        """Generate the complete ww3_grid.nml file for grid preprocessing."""
        grid_content = []
        grid_content.append("! WW3 grid preprocessing configuration")
        grid_content.append("! Generated by rompy-ww3")
        grid_content.append("")

        # Add SPECTRUM_NML
        if self.spectrum:
            rendered = self.spectrum.render().replace("\\n", "\n")
            grid_content.extend(rendered.split("\n"))
            grid_content.append("")

        # Add RUN_NML
        if self.run:
            rendered = self.run.render().replace("\\n", "\n")
            grid_content.extend(rendered.split("\n"))
            grid_content.append("")

        # Add GRID_NML (from Grid object or direct namelist)
        if self.grid:
            grid_content.append(self.grid.generate_grid_nml())
            grid_content.append("")

        # Add RECT_NML (from Grid object or direct namelist)
        if self.grid and self.grid.grid_type == "RECT":
            grid_content.append(self.grid.generate_rect_nml())
            grid_content.append("")

        # Add TIMESTEPS_NML
        if self.timesteps:
            rendered = self.timesteps.render().replace("\\n", "\n")
            grid_content.extend(rendered.split("\n"))
            grid_content.append("")

        # Add optional depth-related namelists
        # Priority: Direct namelist > Grid object namelist > Grid object file
        if self.depth:
            rendered = self.depth.render().replace("\\n", "\n")
            grid_content.extend(rendered.split("\n"))
            grid_content.append("")
        elif self.grid and self.grid.depth_file:
            depth_nml_obj = self.grid.get_depth_nml()
            if depth_nml_obj:
                rendered = depth_nml_obj.render().replace("\\n", "\n")
                grid_content.extend(rendered.split("\n"))
                grid_content.append("")

        # ... similar logic for other file-based namelists

Execution Layer
~~~~~~~~~~~~~~~

Handles model execution and file management:

1. **Staging**: Organizes input files in appropriate directories
2. **Templates**: Renders WW3 control files using Jinja2 templates
3. **Execution**: Coordinates model runs and manages output

Data Flow
---------

The typical data flow through the system:

1. **Configuration Definition**:
   - User creates Config with Grid/Data objects and/or direct namelist objects
   - Grid/Data objects validate parameters and manage files

2. **Model Preparation**:
   - Config processes Grid/Data objects to extract namelist information
   - Files are copied to staging directories
   - Namelist objects are instantiated and validated

3. **Template Rendering**:
   - Namelist objects render to Fortran-style namelist strings
   - Templates generate WW3 control files
   - File organization follows WW3 conventions

4. **Model Execution**:
   - Prepared files are organized for WW3 execution
   - Model runs can be executed locally or submitted to HPC systems

File Organization
-----------------

The system organizes files according to WW3 conventions:

::

    staging_directory/
    ├── grid/                 # Grid files (depth, mask, etc.)
    │   ├── depth.dat
    │   └── ww3_grid_depth_nml.nml
    ├── data/                 # Forcing data files
    │   ├── wind_forcing.nc
    │   └── ww3_prnc.nml
    └── namelists/            # WW3 control files
        ├── ww3_shel.nml      # Shell model configuration
        ├── ww3_grid.nml      # Grid preprocessing
        ├── ww3_bound.nml     # Boundary preprocessing
        └── ...

Design Patterns
---------------

Several design patterns are used throughout the implementation:

Factory Pattern
~~~~~~~~~~~~~~~

Namelist objects act as factories for generating WW3 control file content:

.. code-block:: python

    class Depth(BaseModel):
        """DEPTH_NML namelist object."""
        filename: str
        sf: float = 0.001
        idf: int = 50
        idla: int = 1

        def render(self) -> str:
            """Render the namelist as a Fortran-style string."""
            lines = []
            lines.append("&DEPTH_NML")
            lines.append(f"  DEPTH%SF = {self.sf}")
            lines.append(f"  DEPTH%FILENAME = '{self.filename}'")
            lines.append(f"  DEPTH%IDF = {self.idf}")
            lines.append(f"  DEPTH%IDLA = {self.idla}")
            lines.append("/")
            return "\n".join(lines)

Strategy Pattern
~~~~~~~~~~~~~~~~

Different grid types implement the same interface with different behaviors:

.. code-block:: python

    # Rectilinear grid
    grid = Grid(grid_type="RECT", nx=100, ny=50, dx=0.1, dy=0.1)
    
    # Curvilinear grid  
    grid = Grid(grid_type="CURV", x_coord_file="x_coords.nc", y_coord_file="y_coords.nc")
    
    # Unstructured grid
    grid = Grid(grid_type="UNST", unst_file="mesh.gr3")

Observer Pattern
~~~~~~~~~~~~~~~~

The Config class observes Grid/Data objects to extract namelist information:

.. code-block:: python

    # Config automatically extracts depth namelist from Grid object
    if self.grid and self.grid.depth_file:
        depth_nml = self.grid.get_depth_nml()  # Observer pattern in action

Benefits of This Architecture
-----------------------------

1. **Gradual Adoption**: Users can adopt new features incrementally
2. **Maximum Compatibility**: Existing configurations continue to work
3. **Flexible Control**: Both high-level abstractions and low-level control available
4. **Extensibility**: New WW3 features can be added through either approach
5. **Maintainability**: Clear separation of concerns makes maintenance easier
6. **Testability**: Each layer can be tested independently

Common Usage Patterns
---------------------

Basic Configuration with Grid Object
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    from rompy_ww3.config import Config
    from rompy_ww3.grid import Grid
    from rompy_ww3.namelists import Domain, Spectrum, Run, Timesteps

    config = Config(
        domain=Domain(
            start="20080522 000000",
            stop="20080522 030000",
            iostyp=1,
        ),
        spectrum=Spectrum(
            xfr=1.1,
            freq1=0.03679,
            nk=3,
            nth=12,
        ),
        run=Run(
            fldry=False,
            flcx=True,
            flcy=True,
            flcth=True,
            flck=False,
            flsou=True,
        ),
        timesteps=Timesteps(
            dtmax=480.0,
            dtxy=160.0,
            dtkth=240.0,
            dtmin=10.0,
        ),
        grid=Grid(
            name="Test Grid",
            grid_type="RECT",
            coordinate_system="SPHE",
            grid_closure="SMPL",
            zlim=-0.10,
            dmin=2.5,
            x0=183.4,
            y0=25.1,
            dx=0.35457,
            dy=0.35457,
            nx=225,
            ny=106,
            depth_file=Path("depth.dat"),
        ),
    )

Mixed Approach with Overrides
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    config = Config(
        domain=Domain(start="20080522 000000", stop="20080522 030000"),
        # Use Grid object for most configuration
        grid=Grid(
            name="Test Grid",
            grid_type="RECT",
            # ... grid parameters
            depth_file=Path("depth.dat"),
        ),
        # Override specific namelist objects when needed
        depth=Depth(
            filename="custom_depth.dat",
            sf=0.001,
            idf=50,
            idla=1
        ),
        # Direct namelist objects for other parameters
        mask=Mask(
            filename="custom_mask.dat",
            idf=60,
            idla=1
        ),
    )

Traditional Approach
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    config = Config(
        domain=Domain(start="20080522 000000", stop="20080522 030000"),
        # All direct namelist objects (traditional approach)
        grid=GRID_NML(
            name="Test Grid",
            type="RECT",
            coord="SPHE",
            clos="SMPL",
            zlim=-0.10,
            dmin=2.5,
        ),
        rect=Rect(
            nx=225,
            ny=106,
            sx=0.35457,
            sy=0.35457,
            x0=183.4,
            y0=25.1,
        ),
        depth=Depth(
            filename="depth.dat",
            sf=0.001,
            idf=50,
            idla=1
        ),
        mask=Mask(
            filename="mask.dat",
            idf=60,
            idla=1
        ),
        # ... other direct namelist objects
    )