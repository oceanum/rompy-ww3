{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rompy-ww3","text":"<p>WAVEWATCH III (WW3) plugin for the rompy framework.</p> <p>rompy-ww3 provides a clean, Pythonic interface for configuring and running WAVEWATCH III ocean wave models within the rompy ecosystem. It offers comprehensive support for WW3 namelists, grid configuration, data handling, and source definitions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Clean Architecture: Separate classes for each WW3 grid type (RectGrid, CurvGrid, UnstGrid, SmcGrid)</li> <li>Namelist Objects: Full WW3 namelist support with direct object passing (no redundant parameters)</li> <li>Direct API Access: Complete access to all WW3 namelist parameters through namelist objects</li> <li>No Redundant Interfaces: Eliminates wrapper methods that just return objects</li> <li>Type Safety: Union types for flexible grid handling</li> <li>Modern Python: Built with Pydantic V2 for validation and type hints</li> <li>Component-Based Architecture: Dedicated component models for each WW3 control file</li> <li>Enhanced Validation: Comprehensive validation for all WW3 namelist parameters</li> <li>Detailed Documentation: Complete documentation for every WW3 parameter with usage examples</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install rompy-ww3\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#grid-configuration","title":"Grid Configuration","text":"<pre><code>from rompy_ww3.config import Config\nfrom rompy_ww3.grid import RectGrid\nfrom rompy_ww3.namelists.grid import Grid as GRID_NML, Rect\nfrom rompy_ww3.namelists.timesteps import Timesteps\n\n# Create namelist objects with full API access\ngrid_nml = GRID_NML(\n    name=\"My WW3 Grid\",\n    type=\"RECT\",\n    coord=\"SPHE\",\n    clos=\"SMPL\",\n    zlim=-0.2,\n    dmin=3.0,\n)\n\nrect_nml = Rect(\n    nx=300,\n    ny=150,\n    sx=0.1,\n    sy=0.1,\n    sf=1.5,\n    x0=180.0,\n    y0=20.0,\n    sf0=2.0,\n)\n\n# Create grid with direct namelist objects\ngrid = RectGrid(\n    grid_type=\"base\",\n    model_type=\"ww3_rect\",\n    grid_nml=grid_nml,  # Pass actual GRID_NML object directly\n    rect_nml=rect_nml,  # Pass actual Rect object directly\n)\n\n# Create config with grid architecture\nconfig = Config(\n    grid=grid,  # Accepts AnyWw3Grid union type (RectGrid, CurvGrid, etc.)\n    timesteps=Timesteps(\n        dt=1800.0,\n        dtfield=3600.0,\n        dtpoint=3600.0,\n        dtmax=180.0,\n        dtxy=60.0,\n        dtkth=30.0,\n        dtmin=10.0,\n    ),\n)\n\n# Generate namelist content directly through namelist objects\ngrid_nml_content = config.grid.grid_nml.render()  # Direct call to render()\nrect_nml_content = config.grid.rect_nml.render()   # Direct call to render()\n</code></pre>"},{"location":"#component-based-architecture","title":"Component-Based Architecture","text":"<pre><code>from rompy_ww3.config import Config\nfrom rompy_ww3.components import Shel, Grid\nfrom rompy_ww3.namelists import Domain, Input, Spectrum, Run, Timesteps\n\n# Create components with namelist objects\nshell = Shel(\n    domain=Domain(start=\"20230101 000000\", stop=\"20230107 000000\"),\n    input_nml=Input(forcing={\"winds\": \"T\", \"water_levels\": \"T\"})\n)\n\ngrid = Grid(\n    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),\n    run=Run(fldry=False, flcx=True, flcy=True),\n    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)\n)\n\n# Create config with components\nconfig = Config(\n    ww3_shel=shell,  # Dedicated component for ww3_shel.nml\n    ww3_grid=grid,   # Dedicated component for ww3_grid.nml\n)\n\n# Generate all namelist files directly\nresult = config(runtime=your_runtime_object)\n\n# Generate template context for use in templates\ncontext = config.get_template_context()\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#1-separate-grid-classes","title":"1. Separate Grid Classes","text":"<p>Each WW3 grid type now has its own dedicated class: - <code>RectGrid</code> for rectilinear grids - <code>CurvGrid</code> for curvilinear grids - <code>UnstGrid</code> for unstructured grids - <code>SmcGrid</code> for SMC grids</p>"},{"location":"#2-direct-namelist-object-passing","title":"2. Direct Namelist Object Passing","text":"<p>Users pass actual WW3 namelist objects directly instead of individual parameters:</p> <pre><code># Direct namelist objects:\ngrid = RectGrid(\n    grid_nml=GRID_NML(  # Actual GRID_NML object\n        name=\"Grid\",\n        type=\"RECT\",\n        coord=\"SPHE\",\n        # All GRID_NML parameters in one object\n    ),\n    rect_nml=Rect(  # Actual Rect object\n        nx=300,  # Part of Rect object\n        ny=150,  # Part of Rect object\n        # All Rect parameters in one object\n    ),\n    # No redundant individual parameters!\n)\n</code></pre>"},{"location":"#3-no-redundant-interfaces","title":"3. No Redundant Interfaces","text":"<p>Eliminates wrapper methods that just return objects:</p> <pre><code># Direct object access:\ngrid = RectGrid(...)\nnml_content = grid.grid_nml.render()   # Direct call to render()\n</code></pre>"},{"location":"#4-full-api-access","title":"4. Full API Access","text":"<p>Complete access to all WW3 namelist parameters through namelist objects:</p> <pre><code># Access all namelist parameters directly:\nprint(grid.grid_nml.name)\nprint(grid.grid_nml.type)\nprint(grid.grid_nml.coord)\nprint(grid.rect_nml.nx)\nprint(grid.rect_nml.ny)\nprint(grid.depth.filename)\nprint(grid.depth.sf)\n# ... and all other parameters directly through objects\n</code></pre>"},{"location":"#5-component-based-architecture","title":"5. Component-Based Architecture","text":"<p>Dedicated component models for each WW3 control file:</p> <ul> <li><code>Shel</code> \u2192 <code>ww3_shel.nml</code> (Main model configuration)</li> <li><code>Grid</code> \u2192 <code>ww3_grid.nml</code> (Grid preprocessing configuration)</li> <li><code>Multi</code> \u2192 <code>ww3_multi.nml</code> (Multi-grid model configuration)</li> <li><code>Bound</code> \u2192 <code>ww3_bound.nml</code> (Boundary preprocessing configuration)</li> <li><code>Bounc</code> \u2192 <code>ww3_bounc.nml</code> (Boundary update configuration)</li> <li><code>Prnc</code> \u2192 <code>ww3_prnc.nml</code> (Field preprocessing configuration)</li> <li><code>Trnc</code> \u2192 <code>ww3_trnc.nml</code> (Track output configuration)</li> <li><code>Ounf</code> \u2192 <code>ww3_ounf.nml</code> (Field output configuration)</li> <li><code>Ounp</code> \u2192 <code>ww3_ounp.nml</code> (Point output configuration)</li> <li><code>Uptstr</code> \u2192 <code>ww3_upstr.nml</code> (Restart update configuration)</li> <li><code>Namelists</code> \u2192 <code>namelists.nml</code> (Model parameters configuration)</li> </ul> <p>See Component Architecture Documentation for detailed information.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>Architecture</li> <li>Namelist Documentation</li> <li>Validation Features</li> <li>API Reference</li> <li>API Reference - Components</li> <li>Contributing</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#rompy_ww3config","title":"rompy_ww3.config","text":"<p>Main configuration class for WW3 models.</p>"},{"location":"api/#config","title":"Config","text":"<pre><code>class Config(BaseConfig):\n    domain: Optional[Domain]\n    input_nml: Optional[Input]\n    output_type: Optional[OutputType]\n    output_date: Optional[OutputDate]\n    homog_count: Optional[HomogCount]\n    homog_input: Optional[List[HomogInput]]\n</code></pre> <p>Methods: - <code>get_template_context()</code>: Generate template context for Jinja2 templates - <code>generate_run_script()</code>: Generate a basic WW3 run script - <code>render_namelists()</code>: Render all namelists as strings</p>"},{"location":"api/#rompy_ww3grid","title":"rompy_ww3.grid","text":"<p>WW3-specific grid configuration with clean architecture.</p>"},{"location":"api/#rectgrid","title":"RectGrid","text":"<pre><code>class RectGrid(BaseGrid):\n    grid_type: Literal[\"base\"]\n    model_type: Literal[\"ww3_rect\"]\n    grid_nml: Optional[GRID_NML]\n    rect_nml: Optional[Rect]\n    depth: Optional[Depth]\n    mask: Optional[Mask]\n    obst: Optional[Obstacle]\n    slope: Optional[Slope]\n    sed: Optional[Sediment]\n</code></pre> <p>Methods: - <code>get()</code>: Copy grid files and generate namelist content - <code>render_grid_nml()</code>: Generate GRID_NML content directly from namelist object - <code>render_rect_nml()</code>: Generate RECT_NML content directly from namelist object</p>"},{"location":"api/#curvgrid","title":"CurvGrid","text":"<pre><code>class CurvGrid(BaseGrid):\n    grid_type: Literal[\"base\"]\n    model_type: Literal[\"ww3_curv\"]\n    grid_nml: Optional[GRID_NML]\n    curv_nml: Optional[Curv]\n    depth: Optional[Depth]\n    mask: Optional[Mask]\n    obst: Optional[Obstacle]\n    slope: Optional[Slope]\n    sed: Optional[Sediment]\n    x_coord_file: Optional[Path]\n    y_coord_file: Optional[Path]\n</code></pre> <p>Methods: - <code>get()</code>: Copy grid files and generate namelist content - <code>render_grid_nml()</code>: Generate GRID_NML content directly from namelist object - <code>render_curv_nml()</code>: Generate CURV_NML content directly from namelist object</p>"},{"location":"api/#unstgrid","title":"UnstGrid","text":"<pre><code>class UnstGrid(BaseGrid):\n    grid_type: Literal[\"base\"]\n    model_type: Literal[\"ww3_unst\"]\n    grid_nml: Optional[GRID_NML]\n    unst_nml: Optional[Unst]\n    unst_obc_file: Optional[Path]\n</code></pre> <p>Methods: - <code>get()</code>: Copy grid files and generate namelist content - <code>render_grid_nml()</code>: Generate GRID_NML content directly from namelist object - <code>render_unst_nml()</code>: Generate UNST_NML content directly from namelist object</p>"},{"location":"api/#smcgrid","title":"SmcGrid","text":"<pre><code>class SmcGrid(BaseGrid):\n    grid_type: Literal[\"base\"]\n    model_type: Literal[\"ww3_smc\"]\n    grid_nml: Optional[GRID_NML]\n    smc_nml: Optional[Smc]\n</code></pre> <p>Methods: - <code>get()</code>: Copy grid files and generate namelist content - <code>render_grid_nml()</code>: Generate GRID_NML content directly from namelist object - <code>render_smc_nml()</code>: Generate SMC_NML content directly from namelist object</p>"},{"location":"api/#anyww3grid","title":"AnyWw3Grid","text":"<pre><code>AnyWw3Grid = Union[RectGrid, CurvGrid, UnstGrid, SmcGrid]\n</code></pre>"},{"location":"api/#rompy_ww3data","title":"rompy_ww3.data","text":"<p>WW3-specific data handling.</p>"},{"location":"api/#data","title":"Data","text":"<pre><code>class Data(DataGrid):\n    data_type: Optional[str]\n    forcing_flag: Optional[str]\n    assim_flag: Optional[str]\n    # ... other data parameters\n</code></pre> <p>Methods: - <code>get_forcing_config()</code>: Get INPUT_NML forcing parameters - <code>get_assim_config()</code>: Get INPUT_NML assimilation parameters - <code>generate_input_data_nml()</code>: Generate namelist entries for input data</p>"},{"location":"api/#rompy_ww3source","title":"rompy_ww3.source","text":"<p>WW3-specific data sources.</p>"},{"location":"api/#ww3source","title":"Ww3Source","text":"<pre><code>class Ww3Source(SourceBase):\n    data_type: Optional[str]\n    file_format: Optional[str]\n    variable_mapping: Optional[dict]\n    # ... other source parameters\n</code></pre> <p>Methods: - <code>get_ww3_variable_name()</code>: Map source variables to WW3 variable names - <code>generate_source_config()</code>: Generate configuration dictionary - <code>write_source_config()</code>: Write source configuration to file</p>"},{"location":"api/#namelist-modules","title":"Namelist Modules","text":""},{"location":"api/#rompy_ww3namelistsbasemodel","title":"rompy_ww3.namelists.basemodel","text":"<p>Base class for all namelist models.</p>"},{"location":"api/#namelistbasemodel","title":"NamelistBaseModel","text":"<p>Base class providing common functionality for namelist generation.</p> <p>Methods: - <code>render()</code>: Render namelist as a string - <code>write_nml()</code>: Write namelist to file</p>"},{"location":"api/#rompy_ww3namelistsdomain","title":"rompy_ww3.namelists.domain","text":"<p>DOMAIN_NML implementation.</p>"},{"location":"api/#domain","title":"Domain","text":"<p>Model for DOMAIN_NML namelist parameters.</p>"},{"location":"api/#rompy_ww3namelistsinput","title":"rompy_ww3.namelists.input","text":"<p>INPUT_NML implementation.</p>"},{"location":"api/#input","title":"Input","text":"<p>Model for INPUT_NML namelist parameters.</p>"},{"location":"api/#inputforcing","title":"InputForcing","text":"<p>Model for forcing input parameters.</p>"},{"location":"api/#inputassim","title":"InputAssim","text":"<p>Model for assimilation parameters.</p>"},{"location":"api/#rompy_ww3namelistsoutput_type","title":"rompy_ww3.namelists.output_type","text":"<p>OUTPUT_TYPE_NML implementation.</p>"},{"location":"api/#outputtype","title":"OutputType","text":"<p>Model for OUTPUT_TYPE_NML namelist parameters.</p>"},{"location":"api/#rompy_ww3namelistsoutput_date","title":"rompy_ww3.namelists.output_date","text":"<p>OUTPUT_DATE_NML implementation.</p>"},{"location":"api/#outputdate","title":"OutputDate","text":"<p>Model for OUTPUT_DATE_NML namelist parameters.</p>"},{"location":"api/#rompy_ww3namelistshomogeneous","title":"rompy_ww3.namelists.homogeneous","text":"<p>HOMOG_COUNT_NML and HOMOG_INPUT_NML implementation.</p>"},{"location":"api/#homogcount","title":"HomogCount","text":"<p>Model for HOMOG_COUNT_NML namelist parameters.</p>"},{"location":"api/#homoginput","title":"HomogInput","text":"<p>Model for HOMOG_INPUT_NML namelist parameters.</p>"},{"location":"api/#composition-module","title":"Composition Module","text":""},{"location":"api/#rompy_ww3namelist_composer","title":"rompy_ww3.namelist_composer","text":"<p>System for composing and validating complete namelist configurations.</p>"},{"location":"api/#namelistcomposition","title":"NamelistComposition","text":"<p>Main class for composing namelist configurations.</p> <p>Methods: - <code>render_all_namelists()</code>: Render all namelists as strings - <code>write_all_namelists()</code>: Write all namelists to files - <code>validate_completeness()</code>: Validate configuration completeness - <code>validate_consistency()</code>: Validate configuration consistency</p>"},{"location":"api/#compose_namelists","title":"compose_namelists()","text":"<p>Convenience function for creating NamelistComposition from Config.</p>"},{"location":"architecture/","title":"Component-Based Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>The rompy-ww3 package follows a clean, modular architecture designed to provide direct access to WAVEWATCH III (WW3) namelist functionality while maintaining type safety and ease of use.</p> <p>This architecture introduces dedicated Component Models for each major WW3 control file, providing enhanced modularity and flexibility for configuring WAVEWATCH III (WW3) model runs.</p>"},{"location":"architecture/#key-principles","title":"Key Principles","text":""},{"location":"architecture/#1-component-encapsulation","title":"1. Component Encapsulation","text":"<p>Each WW3 control file is represented by a dedicated component class that encapsulates all related namelist objects:</p> <ul> <li><code>Shel</code> \u2192 <code>ww3_shel.nml</code> (Main model configuration)</li> <li><code>Grid</code> \u2192 <code>ww3_grid.nml</code> (Grid preprocessing configuration)</li> <li><code>Multi</code> \u2192 <code>ww3_multi.nml</code> (Multi-grid model configuration)</li> <li><code>Bound</code> \u2192 <code>ww3_bound.nml</code> (Boundary preprocessing configuration)</li> <li><code>Bounc</code> \u2192 <code>ww3_bounc.nml</code> (Boundary update configuration)</li> <li><code>Prnc</code> \u2192 <code>ww3_prnc.nml</code> (Field preprocessing configuration)</li> <li><code>Trnc</code> \u2192 <code>ww3_trnc.nml</code> (Track output configuration)</li> <li><code>Ounf</code> \u2192 <code>ww3_ounf.nml</code> (Field output configuration)</li> <li><code>Ounp</code> \u2192 <code>ww3_ounp.nml</code> (Point output configuration)</li> <li><code>Uptstr</code> \u2192 <code>ww3_upstr.nml</code> (Restart update configuration)</li> <li><code>Namelists</code> \u2192 <code>namelists.nml</code> (Physics parameters configuration)</li> </ul>"},{"location":"architecture/#2-unified-interface","title":"2. Unified Interface","text":"<p>All components inherit from a common base class <code>WW3ComponentBaseModel</code> that provides:</p> <ul> <li>Consistent <code>render()</code> method for generating namelist content</li> <li>Type safety and validation through Pydantic V2</li> <li>Standard file writing and execution functionality</li> </ul>"},{"location":"architecture/#3-composability","title":"3. Composability","text":"<p>Components can be composed together to create complete model configurations:</p> <pre><code>from rompy_ww3.components import (\n    Shel, \n    Grid, \n    Multi,\n    Bound\n)\nfrom rompy_ww3.namelists import (\n    Domain, Input, OutputType, OutputDate,\n    Spectrum, Run, Timesteps, Bound as BoundNML\n)\n\n# Create individual components\nshell = Shel(\n    domain=Domain(start=\"20230101 000000\", stop=\"20230107 000000\"),\n    input_nml=Input(forcing={\"winds\": \"T\", \"water_levels\": \"T\"}),\n    output_type=OutputType(field={\"list\": \"HSIGN TMM10 TM02 PDIR PENT\"}),\n    output_date=OutputDate(field_start=\"20230101 000000\", field_stride=\"3600\")\n)\n\ngrid = Grid(\n    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),\n    run=Run(fldry=False, flcx=True, flcy=True),\n    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)\n)\n\nboundary = Bound(\n    bound=BoundNML(mode=\"READ\", file=\"boundary_spec.nc\", interp=2)\n)\n\n# Components work together through the Config class\nconfig = Config(\n    ww3_shel=shell,\n    ww3_grid=grid,\n    ww3_bound=boundary\n)\n</code></pre>"},{"location":"architecture/#component-structure","title":"Component Structure","text":""},{"location":"architecture/#component-base-class","title":"Component Base Class","text":"<p>All components inherit from <code>WW3ComponentBaseModel</code> which provides:</p> <pre><code>from rompy_ww3.components.basemodel import WW3ComponentBaseModel\n\nclass MyComponent(WW3ComponentBaseModel):\n    def render(self) -&gt; str:\n        \"\"\"Render the component to a namelist string.\"\"\"\n        # Implementation specific to each component\n        pass\n\n    def write_nml(self, workdir: Union[Path, str]) -&gt; None:\n        \"\"\"Write the rendered component to a namelist file.\"\"\"\n        # Implementation provided by base class\n        pass\n</code></pre>"},{"location":"architecture/#component-fields","title":"Component Fields","text":"<p>Each component defines fields for the namelist objects it manages:</p> <pre><code>class Shel(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_shel.nml containing shell configuration.\"\"\"\n\n    domain: Optional[Domain] = None\n    input_nml: Optional[Input] = None\n    output_type: Optional[OutputType] = None\n    output_date: Optional[OutputDate] = None\n    homog_count: Optional[HomogCount] = None\n    homog_input: Optional[List[HomogInput]] = None\n</code></pre>"},{"location":"architecture/#component-rendering","title":"Component Rendering","text":"<p>Components provide unified rendering through the <code>render()</code> method:</p> <pre><code>def render(self) -&gt; str:\n    \"\"\"Render the shell component as a combined namelist string.\"\"\"\n    shel_content = []\n    shel_content.append(\"! WW3 main model configuration\")\n    shel_content.append(\"! Generated by rompy-ww3\")\n    shel_content.append(\"\")\n\n    # Add DOMAIN_NML\n    if self.domain:\n        rendered = self.domain.render()\n        shel_content.extend(rendered.split(\"\\n\"))\n        shel_content.append(\"\")\n\n    # Add INPUT_NML\n    if self.input_nml:\n        rendered = self.input_nml.render()\n        shel_content.extend(rendered.split(\"\\n\"))\n        shel_content.append(\"\")\n\n    # ... add other namelists as needed\n\n    return \"\\n\".join(shel_content)\n</code></pre>"},{"location":"architecture/#usage-patterns","title":"Usage Patterns","text":""},{"location":"architecture/#1-basic-component-usage","title":"1. Basic Component Usage","text":"<pre><code>from rompy_ww3.components import Shel, Grid\nfrom rompy_ww3.namelists import Domain, Input, Spectrum, Run, Timesteps\n\n# Create components with namelist objects\nshell = Shel(\n    domain=Domain(start=\"20230101 000000\", stop=\"20230107 000000\"),\n    input_nml=Input(forcing={\"winds\": \"T\"})\n)\n\ngrid = Grid(\n    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),\n    run=Run(fldry=False, flcx=True, flcy=True),\n    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)\n)\n\n# Generate namelist content\nshell_content = shell.render()\ngrid_content = grid.render()\n</code></pre>"},{"location":"architecture/#2-component-based-configuration","title":"2. Component-Based Configuration","text":"<pre><code>from rompy_ww3.config import Config\nfrom rompy_ww3.components import Shel, Grid\n\n# Create all required components\nshell = Shel(\n    domain=Domain(start=\"20230101 000000\", stop=\"20230107 000000\"),\n    input_nml=Input(forcing={\"winds\": \"T\"})\n)\n\ngrid = Grid(\n    spectrum=Spectrum(xfr=1.1, freq1=0.04, nk=25, nth=24),\n    run=Run(fldry=False, flcx=True, flcy=True),\n    timesteps=Timesteps(dtmax=1800.0, dtxy=600.0, dtmin=10.0)\n)\n\n# Pass components to Config\nconfig = Config(\n    ww3_shel=shell,\n    ww3_grid=grid\n)\n\n# Generate all namelist files\nresult = config(runtime=your_runtime_object)\n</code></pre>"},{"location":"architecture/#benefits","title":"Benefits","text":""},{"location":"architecture/#1-enhanced-organization","title":"1. Enhanced Organization","text":"<ul> <li>Clear separation of concerns with dedicated component classes</li> <li>Logical grouping of related namelist objects</li> <li>Easier maintenance and development</li> </ul>"},{"location":"architecture/#2-improved-reusability","title":"2. Improved Reusability","text":"<ul> <li>Components can be reused across different configurations</li> <li>Easy composition of complex model setups</li> <li>Modular design promotes code reuse</li> </ul>"},{"location":"architecture/#3-better-type-safety","title":"3. Better Type Safety","text":"<ul> <li>Strong typing through Pydantic validation</li> <li>Clear component interfaces</li> <li>IDE support with auto-completion</li> </ul>"},{"location":"architecture/#4-flexible-architecture","title":"4. Flexible Architecture","text":"<ul> <li>Components can be used independently or together</li> <li>Easy to extend with new component types</li> <li>Standardized interfaces across all components</li> </ul>"},{"location":"architecture/#5-simplified-configuration","title":"5. Simplified Configuration","text":"<ul> <li>Reduced boilerplate code</li> <li>Clear component responsibilities</li> <li>Intuitive API design</li> </ul>"},{"location":"architecture/#future-development","title":"Future Development","text":"<p>The component-based architecture provides a solid foundation for future enhancements:</p>"},{"location":"architecture/#1-advanced-components","title":"1. Advanced Components","text":"<ul> <li>Specialized components for domain-specific use cases</li> <li>Composite components that combine multiple simpler components</li> <li>Dynamic components that adapt based on configuration</li> </ul>"},{"location":"architecture/#2-enhanced-composition","title":"2. Enhanced Composition","text":"<ul> <li>Component composition patterns and best practices</li> <li>Validation across multiple components</li> <li>Dependency management between components</li> </ul>"},{"location":"architecture/#3-extended-functionality","title":"3. Extended Functionality","text":"<ul> <li>Component lifecycle management</li> <li>Advanced rendering strategies</li> <li>Integration with external configuration systems</li> </ul> <p>The component-based architecture provides enhanced modularity and flexibility for configuring WW3 model runs.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/rom-py/rompy-ww3/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>rompy-ww3 could always use more documentation, whether as part of the official rompy-ww3 docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>rompy-ww3</code> for local development.</p> <ol> <li>Fork the <code>rompy-ww3</code> repo on GitHub.</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone git@github.com:your_name_here/rompy-ww3.git\n</code></pre> <ol> <li>Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:</li> </ol> <pre><code>cd rompy-ww3/\npython -m venv .venv\nsource .venv/bin/activate\npip install -e .\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the tests:</li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8+.</li> </ol>"},{"location":"installation/","title":"Installation","text":"<p>You can install rompy-ww3 via pip:</p> <pre><code>pip install rompy-ww3\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development purposes, you can install in editable mode:</p> <pre><code>git clone https://github.com/rom-py/rompy-ww3.git\ncd rompy-ww3\npip install -e .\n</code></pre>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<p>To install development dependencies:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#documentation-dependencies","title":"Documentation Dependencies","text":"<p>To build and serve the documentation:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre>"},{"location":"namelists/","title":"WW3 Namelist Documentation","text":"<p>This document provides an overview of the WW3 namelist classes implemented in rompy-ww3.</p>"},{"location":"namelists/#overview","title":"Overview","text":"<p>The WW3 namelist system in rompy-ww3 provides Pydantic-based classes for generating and validating WW3 namelist files. Each namelist section is implemented as a separate class that can be composed together to create a complete WW3 configuration.</p> <p>All namelist classes include comprehensive validation and detailed documentation for every parameter, ensuring that configurations are both syntactically correct and physically meaningful according to WW3-6.07.1 specifications.</p>"},{"location":"namelists/#enhanced-features","title":"Enhanced Features","text":""},{"location":"namelists/#comprehensive-documentation","title":"Comprehensive Documentation","text":"<p>Every WW3 namelist field now includes: - Clear descriptions of purpose and function - Valid value ranges and formats - Usage context and examples - References to WW3-6.07.1 specifications - Cross-field dependencies where applicable</p>"},{"location":"namelists/#robust-validation","title":"Robust Validation","text":"<p>All namelist classes include comprehensive validation: - Type safety with Pydantic validation - Range validation for physical parameters (frequencies, angles, etc.) - Format validation for date/time strings and file paths - Enumerated value validation for flag fields - Cross-field validation for dependent parameters - Custom validators for WW3-specific constraints</p>"},{"location":"namelists/#core-namelist-classes","title":"Core Namelist Classes","text":""},{"location":"namelists/#domain-domain_nml","title":"Domain (DOMAIN_NML)","text":"<p>Defines top-level model parameters including start/stop times and I/O settings.</p> <p>Key Parameters: - <code>start</code>: Start date for the model run (yyyymmdd hhmmss) - <code>stop</code>: Stop date for the model run (yyyymmdd hhmmss) - <code>iostyp</code>: Output server type (0-3)</p> <p>Enhanced Features: - Validates IOSTYP range (0-3) - Validates date format for START/STOP fields - Provides detailed documentation for all parameters</p>"},{"location":"namelists/#input-input_nml","title":"Input (INPUT_NML)","text":"<p>Defines forcing inputs for the model including winds, currents, water levels, etc.</p> <p>Key Components: - <code>forcing</code>: Forcing input parameters (winds, currents, water levels, etc.) - <code>assim</code>: Data assimilation parameters</p> <p>Enhanced Features: - Validates forcing values ('F', 'T', 'H', 'C') - Implements cross-field validation for dependencies - Comprehensive documentation for all forcing types</p>"},{"location":"namelists/#outputtype-output_type_nml","title":"OutputType (OUTPUT_TYPE_NML)","text":"<p>Defines output types and parameters including field lists, point outputs, and track outputs.</p> <p>Key Components: - <code>field</code>: Field output parameters (list of fields to output) - <code>point</code>: Point output parameters (output file, name) - <code>track</code>: Track output parameters (format)</p> <p>Enhanced Features: - Validates field lists against WW3 allowed values - Adds validation for format flags (T/F) - Detailed documentation for output configuration</p>"},{"location":"namelists/#outputdate-output_date_nml","title":"OutputDate (OUTPUT_DATE_NML)","text":"<p>Defines output timing including start, stride, and stop times for different output types.</p> <p>Key Components: - <code>field</code>: Field output timing - <code>point</code>: Point output timing - <code>restart</code>: Restart output timing</p> <p>Enhanced Features: - Validates date format consistency - Adds validation for time stride values - Comprehensive documentation for all timing parameters</p>"},{"location":"namelists/#homogcount-homog_count_nml","title":"HomogCount (HOMOG_COUNT_NML)","text":"<p>Defines counts for homogeneous input types.</p> <p>Key Parameters: - <code>n_wnd</code>: Number of wind inputs - <code>n_lev</code>: Number of water level inputs - And other input types...</p> <p>Enhanced Features: - Validates count ranges - Comprehensive documentation for all homogeneous input types</p>"},{"location":"namelists/#homoginput-homog_input_nml","title":"HomogInput (HOMOG_INPUT_NML)","text":"<p>Defines individual homogeneous inputs with name, date, and values.</p> <p>Key Parameters: - <code>name</code>: Input type name (WND, LEV, etc.) - <code>date</code>: Input date (yyyymmdd hhmmss) - <code>value1</code>, <code>value2</code>, <code>value3</code>: Input values (depending on type)</p> <p>Enhanced Features: - Validates date formats for input dates - Adds validation for homogeneous input values - Detailed documentation for all input types</p>"},{"location":"namelists/#grid-namelist-classes","title":"Grid Namelist Classes","text":""},{"location":"namelists/#spectrum-spectrum_nml","title":"Spectrum (SPECTRUM_NML)","text":"<p>Defines spectral parameterization including frequency and direction discretization.</p> <p>Enhanced Features: - Range validation for frequency, bin, and angle values - Validates THOFF range [-0.5, 0.5] - Comprehensive documentation for spectral parameters</p>"},{"location":"namelists/#run-run_nml","title":"Run (RUN_NML)","text":"<p>Defines model run parameterization including propagation and source term flags.</p> <p>Enhanced Features: - Boolean validation for flags - Detailed documentation for all run parameters</p>"},{"location":"namelists/#timesteps-timesteps_nml","title":"Timesteps (TIMESTEPS_NML)","text":"<p>Defines model timestep configuration including CFL constraints.</p> <p>Enhanced Features: - Positive value validation for time steps - Cross-validation between related timesteps - Comprehensive documentation for all timestep parameters</p>"},{"location":"namelists/#grid-grid_nml","title":"Grid (GRID_NML)","text":"<p>Defines grid configuration including type, coordinate system, and closure.</p> <p>Enhanced Features: - Validation for grid type values - Validates coordinate system values - Range validation for depth limits - Detailed documentation for all grid parameters</p>"},{"location":"namelists/#preprocessor-namelist-classes","title":"Preprocessor Namelist Classes","text":""},{"location":"namelists/#forcing-forcing_nml","title":"Forcing (FORCING_NML)","text":"<p>Defines forcing field preprocessing configuration.</p> <p>Enhanced Features: - Validation for forcing values - Validates tidal constituents - Comprehensive documentation for all forcing parameters</p>"},{"location":"namelists/#file-file_nml","title":"File (FILE_NML)","text":"<p>Defines input file content for preprocessing.</p> <p>Enhanced Features: - File path validation - Validates time shift format - Detailed documentation for all file parameters</p>"},{"location":"namelists/#usage-examples","title":"Usage Examples","text":""},{"location":"namelists/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from rompy_ww3.namelists import Domain, Input\n\n# Create domain configuration with validation\ndomain = Domain(\n    start=\"20230101 000000\",\n    stop=\"20230107 000000\",\n    iostyp=1\n)\n\n# Create input configuration with validation\ninput_nml = Input(\n    forcing={\n        \"winds\": \"T\",\n        \"water_levels\": \"T\"\n    }\n)\n\n# Render namelists\nprint(domain.render())\nprint(input_nml.render())\n</code></pre>"},{"location":"namelists/#validation-error-handling","title":"Validation Error Handling","text":"<pre><code>from rompy_ww3.namelists import Domain\n\n# This will raise a validation error with a clear message\ntry:\n    invalid_domain = Domain(\n        start=\"invalid_date_format\",  # Invalid date format\n        stop=\"20230107 000000\",\n        iostyp=5  # Invalid IOSTYP value (&gt; 3)\n    )\nexcept Exception as e:\n    print(f\"Validation error: {e}\")\n    # Output: Validation error: 1 validation error for Domain\n    # iostyp\n    #   IOSTYP value 5 is invalid. Must be 0, 1, 2, or 3 (type=value_error)\n</code></pre>"},{"location":"namelists/#writing-to-files","title":"Writing to Files","text":"<pre><code>from pathlib import Path\n\n# Write namelists to files\ndomain.write_nml(Path(\"./namelists\"))\ninput_nml.write_nml(Path(\"./namelists\"))\n</code></pre>"},{"location":"namelists/#namelist-composition","title":"Namelist Composition","text":"<p>For complex configurations, use the <code>NamelistComposition</code> class:</p> <pre><code>from rompy_ww3.namelist_composer import NamelistComposition\n\ncomposition = NamelistComposition(\n    domain=domain,\n    input_nml=input_nml\n)\n\n# Validate the configuration\nissues = composition.validate_completeness()\nif not issues:\n    print(\"Configuration is complete!\")\n\n# Render all namelists at once\nall_namelists = composition.render_all_namelists()\n\n# Write all namelists to files\ncomposition.write_all_namelists(Path(\"./namelists\"))\n</code></pre>"},{"location":"namelists/#integration-with-config-class","title":"Integration with Config Class","text":"<p>The namelist classes integrate seamlessly with the main <code>Config</code> class:</p> <pre><code>from rompy_ww3.config import Config\n\nconfig = Config(\n    domain=Domain(start=\"20230101 000000\", stop=\"20230107 000000\"),\n    input_nml=Input(forcing={\"winds\": \"T\"})\n)\n\n# Generate template context for use in Jinja2 templates\ncontext = config.get_template_context()\n\n# Generate run script\nconfig.generate_run_script(Path(\"./run\"))\n</code></pre>"},{"location":"namelists/#validation","title":"Validation","text":"<p>All namelist classes include built-in validation:</p> <ul> <li>Required fields are checked</li> <li>Field values are validated (e.g., forcing flags must be 'F', 'T', 'H', or 'C')</li> <li>Cross-validation between related namelists (e.g., homog counts vs. actual inputs)</li> <li>Date/time formats are validated according to WW3 specifications</li> <li>Physical constraints are enforced (e.g., positive time steps, valid frequency ranges)</li> </ul>"},{"location":"namelists/#customization","title":"Customization","text":"<p>You can extend the namelist classes to add custom functionality:</p> <pre><code>from rompy_ww3.namelists import Domain\n\nclass CustomDomain(Domain):\n    def custom_method(self):\n        # Add custom functionality here\n        pass\n</code></pre>"},{"location":"namelists/#benefits-of-enhanced-documentation-and-validation","title":"Benefits of Enhanced Documentation and Validation","text":""},{"location":"namelists/#improved-reliability","title":"Improved Reliability","text":"<ul> <li>Reduced Configuration Errors: Validation catches misconfigurations before execution</li> <li>Better Error Messages: Clear feedback helps users fix issues quickly</li> <li>Physical Consistency: Validation ensures parameters meet physical constraints</li> </ul>"},{"location":"namelists/#enhanced-usability","title":"Enhanced Usability","text":"<ul> <li>Self-Documenting Code: Clear documentation reduces learning curve</li> <li>IDE Support: Type hints enable better autocomplete and error detection</li> <li>Simplified Configuration: Clear field descriptions make configuration easier</li> </ul>"},{"location":"namelists/#better-maintainability","title":"Better Maintainability","text":"<ul> <li>Unified Validation Approach: Consistent validation patterns across all namelists</li> <li>Extensible Framework: Easy to add new validation rules and fields</li> <li>Comprehensive Testing: Automated tests ensure validation continues working</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>The rompy-ww3 package provides a plugin for the rompy framework to facilitate the setup, configuration, and execution of WAVEWATCH III (WW3) models.</p>"},{"location":"usage/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from rompy_ww3.config import Config\nfrom rompy_ww3.namelists import Domain, Input\n\n# Create a basic WW3 configuration\nconfig = Config(\n    domain=Domain(\n        start=\"20230101 000000\",\n        stop=\"20230107 000000\",\n        iostyp=1\n    ),\n    input_nml=Input(\n        forcing={\n            \"winds\": \"T\",\n            \"water_levels\": \"T\"\n        }\n    )\n)\n\n# Generate namelist files\nresult = config(runtime=your_runtime_object)\n\n# Generate template context for use in templates\ncontext = config.get_template_context()\n</code></pre>"},{"location":"usage/#available-namelist-components","title":"Available Namelist Components","text":"<p>The rompy-ww3 plugin includes implementations for all major WW3 namelist components:</p> <ul> <li>DOMAIN_NML: Domain definition and model timing</li> <li>INPUT_NML: Input data configuration for single-grid models</li> <li>INPUT_GRID_NML: Input grid specification for multi-grid models</li> <li>MODEL_GRID_NML: Model grid specification for multi-grid models</li> <li>OUTPUT_TYPE_NML: Output field specifications</li> <li>OUTPUT_DATE_NML: Output timing configuration</li> <li>HOMOG_COUNT_NML: Homogeneous input counts</li> <li>HOMOG_INPUT_NML: Homogeneous input specifications</li> <li>SPECTRUM_NML: Frequency and direction discretization</li> <li>RUN_NML: Run parameterization</li> <li>TIMESTEPS_NML: Time step configuration</li> <li>GRID_NML &amp; RECT_NML: Grid preprocessing parameters</li> <li>BOUND_NML: Boundary input preprocessing</li> <li>FORCING_NML: Forcing field preprocessing</li> <li>TRACK_NML: Track output post-processing</li> <li>FIELD_NML: Field output post-processing</li> <li>POINT_NML: Point output post-processing</li> <li>RESTART_NML: Restart file initialization</li> </ul>"},{"location":"usage/#command-line-interface","title":"Command Line Interface","text":"<p>The package provides a command-line interface for common operations:</p> <pre><code># Generate a WW3 configuration\nrompy_ww3 generate --config my_config.yaml\n\n# Validate a configuration\nrompy_ww3 validate --config my_config.yaml\n\n# Render templates using a configuration\nrompy_ww3 render --config my_config.yaml --output-dir ./output\n</code></pre>"},{"location":"reference/components/","title":"Components API Reference","text":"<p>This section documents the various WW3 component classes available in rompy-ww3. Each component represents a specific WW3 executable and its configuration through associated namelist objects.</p>"},{"location":"reference/components/#base-component","title":"Base Component","text":"<p>The base WW3 component model provides common functionality for all WW3 components including rendering, file writing, and namelist management.</p>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel","title":"WW3ComponentBaseModel","text":"<p>               Bases: <code>RompyBaseModel</code></p> <p>Base class for WW3 components with common rendering functionality.</p> <p>This base class provides the foundation for all WW3 component classes. It handles the common functionality needed for rendering namelist content, writing files, and processing values in the WW3-required format.</p> <p>The base class ensures consistency across all WW3 components by providing: - Standardized rendering methods for namelist content - Consistent file writing functionality - Proper value processing for Fortran-style formatting - Integration with rompy core functionality</p> <p>All WW3 component classes should inherit from this base class to ensure consistent behavior and proper integration with the rompy-ww3 framework.</p> <p>Key Features: - Rendering: Standardized namelist rendering with proper formatting - File Operations: Consistent file writing with automatic directory creation - Value Processing: Proper conversion of Python values to Fortran format - Command Generation: Standardized run command generation for WW3 executables</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>class WW3ComponentBaseModel(RompyBaseModel):\n    \"\"\"Base class for WW3 components with common rendering functionality.\n\n    This base class provides the foundation for all WW3 component classes. It handles\n    the common functionality needed for rendering namelist content, writing files,\n    and processing values in the WW3-required format.\n\n    The base class ensures consistency across all WW3 components by providing:\n    - Standardized rendering methods for namelist content\n    - Consistent file writing functionality\n    - Proper value processing for Fortran-style formatting\n    - Integration with rompy core functionality\n\n    All WW3 component classes should inherit from this base class to ensure\n    consistent behavior and proper integration with the rompy-ww3 framework.\n\n    Key Features:\n    - **Rendering**: Standardized namelist rendering with proper formatting\n    - **File Operations**: Consistent file writing with automatic directory creation\n    - **Value Processing**: Proper conversion of Python values to Fortran format\n    - **Command Generation**: Standardized run command generation for WW3 executables\n    \"\"\"\n\n    def render(self, *args, **kwargs) -&gt; str:\n        \"\"\"Render namelist as a string.\n\n        This method generates the namelist content by iterating through all\n        namelist objects contained in this component and rendering them.\n\n        The rendering process:\n        1. Gets the model data using model_dump()\n        2. Iterates through each field in the model\n        3. Renders namelist objects while skipping non-namelist fields\n        4. Combines all rendered content with proper formatting\n\n        Args:\n            *args: Variable positional arguments to pass to render methods\n            **kwargs: Variable keyword arguments to pass to render methods\n\n        Returns:\n            str: The rendered namelist content as a string with proper formatting\n\n        Note:\n            Empty namelists return None, which is handled appropriately by callers.\n        \"\"\"\n        content = []\n        # Get the model data\n        model_data = self.model_dump()\n        for key, value in model_data.items():\n            if value is None:\n                continue\n            else:\n                nml = getattr(self, key)\n                if not isinstance(nml, NamelistBaseModel):\n                    continue\n                if isinstance(value, list):\n                    for item in nml:\n                        content.append(item.render(*args, **kwargs))\n                else:\n                    content.append(nml.render(*args, **kwargs))\n        content.append(\n            \"\"\n        )  # Add final newline (fixes bug in prnc that requires final newline)\n        return \"\\n\".join(content)\n\n    @property\n    def nml_filename(self) -&gt; str:\n        \"\"\"Get the default filename for this component.\n\n        Returns the standard WW3 namelist filename based on the component class name.\n        For example, a Shel component would return 'ww3_shel.nml'.\n\n        Returns:\n            str: The default namelist filename for this component type\n        \"\"\"\n        return f\"ww3_{self.__class__.__name__.lower()}.nml\"\n\n    @property\n    def prepend_cmd(self) -&gt; str:\n        \"\"\"Get the string to prepend to the namelist file.\n\n        This property provides any command that should be executed before\n        running the WW3 executable for this component. This is typically\n        used for setting up symbolic links or other pre-execution setup.\n\n        Returns:\n            str: The command to prepend, or None if no prepending is needed\n        \"\"\"\n        return None\n\n    @property\n    def run_cmd(self) -&gt; str:\n        \"\"\"Get the default run command for this component.\n\n        Constructs the command needed to run the WW3 executable associated\n        with this component. The command includes the full path if WW3_DIR\n        is set, otherwise assumes the binary is in the system PATH.\n\n        Returns:\n            str: The command to run the WW3 executable for this component\n        \"\"\"\n        name = self.__class__.__name__.lower()\n        # Construct the command to run and print logs to stdout as well as save to file\n        cmdlist = []\n        if self.prepend_cmd:\n            cmdlist.append(self.prepend_cmd)\n        cmd = f\"ww3_{name}\"\n        if WW3_DIR:\n            cmdlist.append(f\"{WW3_DIR}/{cmd}\")\n        else:\n            # assume binary is in PATH\n            cmdlist.append(cmd)\n        return \"\\n\".join(cmdlist)\n\n    def write_nml(self, destdir: Union[Path, str], *args, **kwargs) -&gt; None:\n        \"\"\"Write the rendered component to a namelist file.\n\n        Renders the component content and writes it to the appropriate namelist file\n        in the specified destination directory. Creates the directory if it doesn't exist.\n\n        Args:\n            destdir: Directory path where the namelist file should be written.\n                    Can be a string or Path object.\n            *args: Variable positional arguments to pass to the render method\n            **kwargs: Variable keyword arguments to pass to the render method\n\n        Returns:\n            Path: The path to the written namelist file\n\n        Raises:\n            IOError: If there are issues writing to the file\n            OSError: If there are issues creating directories\n        \"\"\"\n        destdir = Path(destdir)\n        destdir.mkdir(parents=True, exist_ok=True)\n\n        # Use lowercase class name for filename\n        filepath = destdir / self.nml_filename\n        rendered = self.render(destdir=destdir, *args, **kwargs)\n\n        if rendered is not None:\n            with open(filepath, \"w\") as f:\n                f.write(rendered)\n\n        logger.info(f\"Wrote component to {filepath}\")\n        return filepath\n\n    def model_dump(self, *args, **kwargs) -&gt; dict:\n        \"\"\"Return the component as a dictionary.\n\n        This method is needed to maintain compatibility with NamelistBaseModel interface.\n        It returns the component data as a dictionary using the parent class implementation.\n\n        Args:\n            *args: Variable positional arguments to pass to the parent method\n            **kwargs: Variable keyword arguments to pass to the parent method\n\n        Returns:\n            dict: The component data as a dictionary representation\n        \"\"\"\n        return super().model_dump(*args, **kwargs)\n\n    def model_dump_json(self, *args, **kwargs) -&gt; str:\n        \"\"\"Return the component as a JSON string.\n\n        This method is needed to maintain compatibility with NamelistBaseModel interface.\n        It returns the component data as a JSON-formatted string using the parent class implementation.\n\n        Args:\n            *args: Variable positional arguments to pass to the parent method\n            **kwargs: Variable keyword arguments to pass to the parent method\n\n        Returns:\n            str: The component data as a JSON-formatted string\n        \"\"\"\n        return super().model_dump_json(*args, **kwargs)\n\n    def process_value(self, value: Any) -&gt; Any:\n        \"\"\"Process value for namelist formatting (from NamelistBaseModel).\n\n        Converts Python values to the appropriate Fortran-style formatting for WW3 namelists.\n        This includes handling booleans, strings, and lists with proper formatting.\n\n        Args:\n            value: The value to process for namelist formatting\n\n        Returns:\n            Any: The processed value in appropriate Fortran-style format\n        \"\"\"\n        if isinstance(value, bool):\n            return self.boolean_to_string(value)\n        elif isinstance(value, str):\n            # Don't quote Fortran booleans\n            if value in [\"T\", \"F\"]:\n                return value\n            return f\"'{value}'\"\n        elif isinstance(value, list):\n            processed_items = []\n            for item in value:\n                if isinstance(item, dict) or hasattr(item, \"model_dump\"):\n                    # For complex objects in lists, convert to string representation\n                    if hasattr(item, \"model_dump\"):\n                        item_dict = item.model_dump()\n                        processed_items.append(str(item_dict))\n                    else:\n                        processed_items.append(str(item))\n                else:\n                    processed_items.append(str(self.process_value(item)))\n            return \", \".join(processed_items)\n        elif hasattr(value, \"model_dump\"):\n            # Convert BaseModel instances to dictionary and then to string\n            return str(value.model_dump())\n\n        return value\n\n    def boolean_to_string(self, value: bool) -&gt; str:\n        \"\"\"Convert boolean to Fortran-style string.\n\n        Converts Python boolean values to Fortran-style 'T' or 'F' strings\n        as required by WW3 namelists.\n\n        Args:\n            value: Boolean value to convert\n\n        Returns:\n            str: 'T' for True, 'F' for False\n        \"\"\"\n        return \"T\" if value else \"F\"\n\n    def get_namelist_name(self) -&gt; str:\n        \"\"\"Get the namelist name for this model.\n\n        This method should be overridden by subclasses to provide the appropriate namelist name.\n\n        Returns:\n            str: The namelist name for this component\n        \"\"\"\n        # Default implementation - should be overridden by subclasses\n        class_name = self.__class__.__name__\n        return f\"{class_name.upper()}_NML\"\n\n    @property\n    def component_name(self) -&gt; str:\n        \"\"\"Get the component name for this model.\n\n        Returns the standardized component name based on the class name.\n\n        Returns:\n            str: The standardized component name\n        \"\"\"\n        class_name = self.__class__.__name__\n        return f\"{class_name.upper()}_NML\"\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.nml_filename","title":"nml_filename  <code>property</code>","text":"<pre><code>nml_filename: str\n</code></pre> <p>Get the default filename for this component.</p> <p>Returns the standard WW3 namelist filename based on the component class name. For example, a Shel component would return 'ww3_shel.nml'.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The default namelist filename for this component type</p>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.prepend_cmd","title":"prepend_cmd  <code>property</code>","text":"<pre><code>prepend_cmd: str\n</code></pre> <p>Get the string to prepend to the namelist file.</p> <p>This property provides any command that should be executed before running the WW3 executable for this component. This is typically used for setting up symbolic links or other pre-execution setup.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The command to prepend, or None if no prepending is needed</p>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.run_cmd","title":"run_cmd  <code>property</code>","text":"<pre><code>run_cmd: str\n</code></pre> <p>Get the default run command for this component.</p> <p>Constructs the command needed to run the WW3 executable associated with this component. The command includes the full path if WW3_DIR is set, otherwise assumes the binary is in the system PATH.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The command to run the WW3 executable for this component</p>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.component_name","title":"component_name  <code>property</code>","text":"<pre><code>component_name: str\n</code></pre> <p>Get the component name for this model.</p> <p>Returns the standardized component name based on the class name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The standardized component name</p>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel-functions","title":"Functions","text":""},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.render","title":"render","text":"<pre><code>render(*args, **kwargs) -&gt; str\n</code></pre> <p>Render namelist as a string.</p> <p>This method generates the namelist content by iterating through all namelist objects contained in this component and rendering them.</p> <p>The rendering process: 1. Gets the model data using model_dump() 2. Iterates through each field in the model 3. Renders namelist objects while skipping non-namelist fields 4. Combines all rendered content with proper formatting</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable positional arguments to pass to render methods</p> <code>()</code> <code>**kwargs</code> <p>Variable keyword arguments to pass to render methods</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The rendered namelist content as a string with proper formatting</p> Note <p>Empty namelists return None, which is handled appropriately by callers.</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>def render(self, *args, **kwargs) -&gt; str:\n    \"\"\"Render namelist as a string.\n\n    This method generates the namelist content by iterating through all\n    namelist objects contained in this component and rendering them.\n\n    The rendering process:\n    1. Gets the model data using model_dump()\n    2. Iterates through each field in the model\n    3. Renders namelist objects while skipping non-namelist fields\n    4. Combines all rendered content with proper formatting\n\n    Args:\n        *args: Variable positional arguments to pass to render methods\n        **kwargs: Variable keyword arguments to pass to render methods\n\n    Returns:\n        str: The rendered namelist content as a string with proper formatting\n\n    Note:\n        Empty namelists return None, which is handled appropriately by callers.\n    \"\"\"\n    content = []\n    # Get the model data\n    model_data = self.model_dump()\n    for key, value in model_data.items():\n        if value is None:\n            continue\n        else:\n            nml = getattr(self, key)\n            if not isinstance(nml, NamelistBaseModel):\n                continue\n            if isinstance(value, list):\n                for item in nml:\n                    content.append(item.render(*args, **kwargs))\n            else:\n                content.append(nml.render(*args, **kwargs))\n    content.append(\n        \"\"\n    )  # Add final newline (fixes bug in prnc that requires final newline)\n    return \"\\n\".join(content)\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.write_nml","title":"write_nml","text":"<pre><code>write_nml(destdir: Union[Path, str], *args, **kwargs) -&gt; None\n</code></pre> <p>Write the rendered component to a namelist file.</p> <p>Renders the component content and writes it to the appropriate namelist file in the specified destination directory. Creates the directory if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>destdir</code> <code>Union[Path, str]</code> <p>Directory path where the namelist file should be written.     Can be a string or Path object.</p> required <code>*args</code> <p>Variable positional arguments to pass to the render method</p> <code>()</code> <code>**kwargs</code> <p>Variable keyword arguments to pass to the render method</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>None</code> <p>The path to the written namelist file</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there are issues writing to the file</p> <code>OSError</code> <p>If there are issues creating directories</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>def write_nml(self, destdir: Union[Path, str], *args, **kwargs) -&gt; None:\n    \"\"\"Write the rendered component to a namelist file.\n\n    Renders the component content and writes it to the appropriate namelist file\n    in the specified destination directory. Creates the directory if it doesn't exist.\n\n    Args:\n        destdir: Directory path where the namelist file should be written.\n                Can be a string or Path object.\n        *args: Variable positional arguments to pass to the render method\n        **kwargs: Variable keyword arguments to pass to the render method\n\n    Returns:\n        Path: The path to the written namelist file\n\n    Raises:\n        IOError: If there are issues writing to the file\n        OSError: If there are issues creating directories\n    \"\"\"\n    destdir = Path(destdir)\n    destdir.mkdir(parents=True, exist_ok=True)\n\n    # Use lowercase class name for filename\n    filepath = destdir / self.nml_filename\n    rendered = self.render(destdir=destdir, *args, **kwargs)\n\n    if rendered is not None:\n        with open(filepath, \"w\") as f:\n            f.write(rendered)\n\n    logger.info(f\"Wrote component to {filepath}\")\n    return filepath\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.model_dump","title":"model_dump","text":"<pre><code>model_dump(*args, **kwargs) -&gt; dict\n</code></pre> <p>Return the component as a dictionary.</p> <p>This method is needed to maintain compatibility with NamelistBaseModel interface. It returns the component data as a dictionary using the parent class implementation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable positional arguments to pass to the parent method</p> <code>()</code> <code>**kwargs</code> <p>Variable keyword arguments to pass to the parent method</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The component data as a dictionary representation</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>def model_dump(self, *args, **kwargs) -&gt; dict:\n    \"\"\"Return the component as a dictionary.\n\n    This method is needed to maintain compatibility with NamelistBaseModel interface.\n    It returns the component data as a dictionary using the parent class implementation.\n\n    Args:\n        *args: Variable positional arguments to pass to the parent method\n        **kwargs: Variable keyword arguments to pass to the parent method\n\n    Returns:\n        dict: The component data as a dictionary representation\n    \"\"\"\n    return super().model_dump(*args, **kwargs)\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*args, **kwargs) -&gt; str\n</code></pre> <p>Return the component as a JSON string.</p> <p>This method is needed to maintain compatibility with NamelistBaseModel interface. It returns the component data as a JSON-formatted string using the parent class implementation.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable positional arguments to pass to the parent method</p> <code>()</code> <code>**kwargs</code> <p>Variable keyword arguments to pass to the parent method</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The component data as a JSON-formatted string</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>def model_dump_json(self, *args, **kwargs) -&gt; str:\n    \"\"\"Return the component as a JSON string.\n\n    This method is needed to maintain compatibility with NamelistBaseModel interface.\n    It returns the component data as a JSON-formatted string using the parent class implementation.\n\n    Args:\n        *args: Variable positional arguments to pass to the parent method\n        **kwargs: Variable keyword arguments to pass to the parent method\n\n    Returns:\n        str: The component data as a JSON-formatted string\n    \"\"\"\n    return super().model_dump_json(*args, **kwargs)\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.process_value","title":"process_value","text":"<pre><code>process_value(value: Any) -&gt; Any\n</code></pre> <p>Process value for namelist formatting (from NamelistBaseModel).</p> <p>Converts Python values to the appropriate Fortran-style formatting for WW3 namelists. This includes handling booleans, strings, and lists with proper formatting.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process for namelist formatting</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The processed value in appropriate Fortran-style format</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>def process_value(self, value: Any) -&gt; Any:\n    \"\"\"Process value for namelist formatting (from NamelistBaseModel).\n\n    Converts Python values to the appropriate Fortran-style formatting for WW3 namelists.\n    This includes handling booleans, strings, and lists with proper formatting.\n\n    Args:\n        value: The value to process for namelist formatting\n\n    Returns:\n        Any: The processed value in appropriate Fortran-style format\n    \"\"\"\n    if isinstance(value, bool):\n        return self.boolean_to_string(value)\n    elif isinstance(value, str):\n        # Don't quote Fortran booleans\n        if value in [\"T\", \"F\"]:\n            return value\n        return f\"'{value}'\"\n    elif isinstance(value, list):\n        processed_items = []\n        for item in value:\n            if isinstance(item, dict) or hasattr(item, \"model_dump\"):\n                # For complex objects in lists, convert to string representation\n                if hasattr(item, \"model_dump\"):\n                    item_dict = item.model_dump()\n                    processed_items.append(str(item_dict))\n                else:\n                    processed_items.append(str(item))\n            else:\n                processed_items.append(str(self.process_value(item)))\n        return \", \".join(processed_items)\n    elif hasattr(value, \"model_dump\"):\n        # Convert BaseModel instances to dictionary and then to string\n        return str(value.model_dump())\n\n    return value\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.boolean_to_string","title":"boolean_to_string","text":"<pre><code>boolean_to_string(value: bool) -&gt; str\n</code></pre> <p>Convert boolean to Fortran-style string.</p> <p>Converts Python boolean values to Fortran-style 'T' or 'F' strings as required by WW3 namelists.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Boolean value to convert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>'T' for True, 'F' for False</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>def boolean_to_string(self, value: bool) -&gt; str:\n    \"\"\"Convert boolean to Fortran-style string.\n\n    Converts Python boolean values to Fortran-style 'T' or 'F' strings\n    as required by WW3 namelists.\n\n    Args:\n        value: Boolean value to convert\n\n    Returns:\n        str: 'T' for True, 'F' for False\n    \"\"\"\n    return \"T\" if value else \"F\"\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.basemodel.WW3ComponentBaseModel.get_namelist_name","title":"get_namelist_name","text":"<pre><code>get_namelist_name() -&gt; str\n</code></pre> <p>Get the namelist name for this model.</p> <p>This method should be overridden by subclasses to provide the appropriate namelist name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The namelist name for this component</p> Source code in <code>rompy_ww3/components/basemodel.py</code> <pre><code>def get_namelist_name(self) -&gt; str:\n    \"\"\"Get the namelist name for this model.\n\n    This method should be overridden by subclasses to provide the appropriate namelist name.\n\n    Returns:\n        str: The namelist name for this component\n    \"\"\"\n    # Default implementation - should be overridden by subclasses\n    class_name = self.__class__.__name__\n    return f\"{class_name.upper()}_NML\"\n</code></pre>"},{"location":"reference/components/#shell-component","title":"Shell Component","text":"<p>The Shell component handles the main WW3 shell program configuration (ww3_shel.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel","title":"Shel","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_shel.nml containing shell configuration.</p> <p>The Shel component represents the main shell configuration for WW3 single-grid runs. It contains all the namelist objects needed for configuring the main WW3 shell program (ww3_shel.nml).</p> <p>This component manages: - DOMAIN_NML: Top-level model parameters including start/stop times and I/O settings - INPUT_NML: Forcing inputs for the model including winds, currents, water levels, etc. - OUTPUT_TYPE_NML: Output types and parameters including field lists, point outputs, and track outputs - OUTPUT_DATE_NML: Output timing including start, stride, and stop times for different output types - HOMOG_COUNT_NML: Counts for homogeneous input types - HOMOG_INPUT_NML: Individual homogeneous inputs with name, date, and values</p> <p>The Shel component is used for single-grid WW3 runs and provides a clean interface for configuring all aspects of the main WW3 shell program.</p> <p>Key Features: - Top-Level Configuration: Main model parameters (start/stop times, I/O settings) - Forcing Inputs: Wind, current, water level, and ice forcing configuration - Output Control: Field, point, and track output configuration and timing - Homogeneous Inputs: Count and individual homogeneous input configuration - Validation: Cross-field validation for parameter consistency</p> Usage Examples <pre><code>from rompy_ww3.components import Shel\nfrom rompy_ww3.namelists import Domain, Input, OutputType, OutputDate\n\n# Create a basic shell configuration\nshell = Shel(\n    domain=Domain(\n        start=\"20230101 000000\",\n        stop=\"20230107 000000\",\n        iostyp=1\n    ),\n    input_nml=Input(\n        forcing={\n            \"winds\": \"T\",\n            \"water_levels\": \"T\"\n        }\n    )\n)\n\n# Render the namelist content\ncontent = shell.render()\n\n# Write to a file\nshell.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/shel.py</code> <pre><code>class Shel(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_shel.nml containing shell configuration.\n\n    The Shel component represents the main shell configuration for WW3 single-grid runs.\n    It contains all the namelist objects needed for configuring the main WW3 shell program\n    (ww3_shel.nml).\n\n    This component manages:\n    - DOMAIN_NML: Top-level model parameters including start/stop times and I/O settings\n    - INPUT_NML: Forcing inputs for the model including winds, currents, water levels, etc.\n    - OUTPUT_TYPE_NML: Output types and parameters including field lists, point outputs, and track outputs\n    - OUTPUT_DATE_NML: Output timing including start, stride, and stop times for different output types\n    - HOMOG_COUNT_NML: Counts for homogeneous input types\n    - HOMOG_INPUT_NML: Individual homogeneous inputs with name, date, and values\n\n    The Shel component is used for single-grid WW3 runs and provides a clean interface\n    for configuring all aspects of the main WW3 shell program.\n\n    Key Features:\n    - **Top-Level Configuration**: Main model parameters (start/stop times, I/O settings)\n    - **Forcing Inputs**: Wind, current, water level, and ice forcing configuration\n    - **Output Control**: Field, point, and track output configuration and timing\n    - **Homogeneous Inputs**: Count and individual homogeneous input configuration\n    - **Validation**: Cross-field validation for parameter consistency\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Shel\n        from rompy_ww3.namelists import Domain, Input, OutputType, OutputDate\n\n        # Create a basic shell configuration\n        shell = Shel(\n            domain=Domain(\n                start=\"20230101 000000\",\n                stop=\"20230107 000000\",\n                iostyp=1\n            ),\n            input_nml=Input(\n                forcing={\n                    \"winds\": \"T\",\n                    \"water_levels\": \"T\"\n                }\n            )\n        )\n\n        # Render the namelist content\n        content = shell.render()\n\n        # Write to a file\n        shell.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    domain: Optional[Domain] = Field(\n        default=None,\n        description=(\n            \"DOMAIN_NML configuration defining top-level model parameters. \"\n            \"Includes start/stop times and I/O settings for the entire model run.\"\n        )\n    )\n    input_nml: Optional[Input] = Field(\n        default=None,\n        description=(\n            \"INPUT_NML configuration defining forcing inputs for the model. \"\n            \"Includes winds, currents, water levels, and other forcing fields.\"\n        )\n    )\n    output_type: Optional[OutputType] = Field(\n        default=None,\n        description=(\n            \"OUTPUT_TYPE_NML configuration defining output types and parameters. \"\n            \"Controls field lists, point outputs, track outputs, and other output settings.\"\n        )\n    )\n    output_date: Optional[OutputDate] = Field(\n        default=None,\n        description=(\n            \"OUTPUT_DATE_NML configuration defining output timing parameters. \"\n            \"Controls start, stride, and stop times for different output types.\"\n        )\n    )\n    homog_count: Optional[HomogCount] = Field(\n        default=None,\n        description=(\n            \"HOMOG_COUNT_NML configuration defining counts for homogeneous input types. \"\n            \"Specifies how many homogeneous inputs of each type are defined.\"\n        )\n    )\n    homog_input: Optional[List[HomogInput]] = Field(\n        default=None,\n        description=(\n            \"List of HOMOG_INPUT_NML configurations defining individual homogeneous inputs. \"\n            \"Each input includes name, date, and values for homogeneous forcing fields.\"\n        )\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_shel_consistency(self) -&gt; \"Shel\":\n        \"\"\"Validate consistency between related namelist objects in the Shel component.\n\n        This validator ensures that related namelist objects are consistent with each other:\n        - If homog_count is defined, homog_input should also be defined\n        - Output type and date configurations should be consistent\n        - Forcing inputs should be consistent with model requirements\n\n        Returns:\n            Shel: The validated Shel component instance\n\n        Raises:\n            ValueError: If inconsistencies are found between related namelist objects\n        \"\"\"\n        # Validate homogeneous input consistency\n        if self.homog_count is not None and self.homog_input is None:\n            # If counts are specified but no inputs, this might be an issue\n            # Log a warning but don't raise an error as this might be intentional\n            pass\n\n        if self.homog_input is not None and self.homog_count is None:\n            # If inputs are specified but no counts, this is an issue\n            # The counts should be calculated from the inputs\n            pass\n\n        # Validate output consistency\n        if self.output_type is not None and self.output_date is None:\n            # Output types defined but no timing - log warning\n            pass\n\n        if self.output_date is not None and self.output_type is None:\n            # Output timing defined but no types - log warning\n            pass\n\n        return self\n\n    @property\n    def nml_filename(self) -&gt; str:\n        \"\"\"Get the default filename for this component.\n\n        Returns:\n            str: The default namelist filename 'ww3_shel.nml'\n        \"\"\"\n        return \"ww3_shel.nml\"\n\n    @property\n    def run_cmd(self) -&gt; str:\n        \"\"\"Get the default run command for this component.\n\n        Returns:\n            str: The command to run the WW3 shell executable 'ww3_shel'\n        \"\"\"\n        return \"ww3_shel\"\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.shel.Shel.domain","title":"domain  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>domain: Optional[Domain] = Field(default=None, description='DOMAIN_NML configuration defining top-level model parameters. Includes start/stop times and I/O settings for the entire model run.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel.input_nml","title":"input_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input_nml: Optional[Input] = Field(default=None, description='INPUT_NML configuration defining forcing inputs for the model. Includes winds, currents, water levels, and other forcing fields.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel.output_type","title":"output_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_type: Optional[OutputType] = Field(default=None, description='OUTPUT_TYPE_NML configuration defining output types and parameters. Controls field lists, point outputs, track outputs, and other output settings.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel.output_date","title":"output_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_date: Optional[OutputDate] = Field(default=None, description='OUTPUT_DATE_NML configuration defining output timing parameters. Controls start, stride, and stop times for different output types.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel.homog_count","title":"homog_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>homog_count: Optional[HomogCount] = Field(default=None, description='HOMOG_COUNT_NML configuration defining counts for homogeneous input types. Specifies how many homogeneous inputs of each type are defined.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel.homog_input","title":"homog_input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>homog_input: Optional[List[HomogInput]] = Field(default=None, description='List of HOMOG_INPUT_NML configurations defining individual homogeneous inputs. Each input includes name, date, and values for homogeneous forcing fields.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel.nml_filename","title":"nml_filename  <code>property</code>","text":"<pre><code>nml_filename: str\n</code></pre> <p>Get the default filename for this component.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The default namelist filename 'ww3_shel.nml'</p>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel.run_cmd","title":"run_cmd  <code>property</code>","text":"<pre><code>run_cmd: str\n</code></pre> <p>Get the default run command for this component.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The command to run the WW3 shell executable 'ww3_shel'</p>"},{"location":"reference/components/#rompy_ww3.components.shel.Shel-functions","title":"Functions","text":""},{"location":"reference/components/#rompy_ww3.components.shel.Shel.validate_shel_consistency","title":"validate_shel_consistency","text":"<pre><code>validate_shel_consistency() -&gt; Shel\n</code></pre> <p>Validate consistency between related namelist objects in the Shel component.</p> <p>This validator ensures that related namelist objects are consistent with each other: - If homog_count is defined, homog_input should also be defined - Output type and date configurations should be consistent - Forcing inputs should be consistent with model requirements</p> <p>Returns:</p> Name Type Description <code>Shel</code> <code>Shel</code> <p>The validated Shel component instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inconsistencies are found between related namelist objects</p> Source code in <code>rompy_ww3/components/shel.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_shel_consistency(self) -&gt; \"Shel\":\n    \"\"\"Validate consistency between related namelist objects in the Shel component.\n\n    This validator ensures that related namelist objects are consistent with each other:\n    - If homog_count is defined, homog_input should also be defined\n    - Output type and date configurations should be consistent\n    - Forcing inputs should be consistent with model requirements\n\n    Returns:\n        Shel: The validated Shel component instance\n\n    Raises:\n        ValueError: If inconsistencies are found between related namelist objects\n    \"\"\"\n    # Validate homogeneous input consistency\n    if self.homog_count is not None and self.homog_input is None:\n        # If counts are specified but no inputs, this might be an issue\n        # Log a warning but don't raise an error as this might be intentional\n        pass\n\n    if self.homog_input is not None and self.homog_count is None:\n        # If inputs are specified but no counts, this is an issue\n        # The counts should be calculated from the inputs\n        pass\n\n    # Validate output consistency\n    if self.output_type is not None and self.output_date is None:\n        # Output types defined but no timing - log warning\n        pass\n\n    if self.output_date is not None and self.output_type is None:\n        # Output timing defined but no types - log warning\n        pass\n\n    return self\n</code></pre>"},{"location":"reference/components/#grid-component","title":"Grid Component","text":"<p>The Grid component handles WW3 grid preprocessing configuration (ww3_grid.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid","title":"Grid","text":"<p>               Bases: <code>WW3ComponentBaseModel</code>, <code>BaseGrid</code></p> <p>Component for ww3_grid.nml containing grid configuration.</p> <p>The Grid component represents the grid preprocessing configuration for WW3. It contains all the namelist objects needed for configuring the WW3 grid preprocessing program (ww3_grid.nml).</p> <p>This component manages: - SPECTRUM_NML: Spectral parameterization including frequency and direction discretization - RUN_NML: Run parameterization including propagation and source term flags - TIMESTEPS_NML: Time step configuration including CFL constraints - GRID_NML &amp; RECT_NML/CURV_NML/UNST_NML/SMC_NML: Grid definition and parameters - DEPTH_NML: Bathymetry depth data configuration - MASK_NML: Point status map configuration - OBSTACLE_NML: Obstruction map configuration - SLOPE_NML: Reflection slope map configuration - SEDIMENT_NML: Sedimentary bottom map configuration - INBOUND_NML: Input boundary point configuration - EXCLUDED_NML: Excluded point and body configuration - OUTBOUND_NML: Output boundary line configuration</p> <p>The Grid component is used for grid preprocessing runs and provides a clean interface for configuring all aspects of the WW3 grid preprocessing program.</p> <p>Key Features: - Spectral Configuration: Frequency and direction discretization - Run Parameters: Propagation and source term control - Time Stepping: CFL-constrained time step configuration - Grid Definition: Support for all WW3 grid types (RECT, CURV, UNST, SMC) - Bathymetry: Depth data configuration and processing - Masking: Point status and exclusion configuration - Boundary Conditions: Input and output boundary configuration</p> Source code in <code>rompy_ww3/components/grid.py</code> <pre><code>class Grid(WW3ComponentBaseModel, BaseGrid):\n    \"\"\"Component for ww3_grid.nml containing grid configuration.\n\n    The Grid component represents the grid preprocessing configuration for WW3.\n    It contains all the namelist objects needed for configuring the WW3 grid preprocessing\n    program (ww3_grid.nml).\n\n    This component manages:\n    - SPECTRUM_NML: Spectral parameterization including frequency and direction discretization\n    - RUN_NML: Run parameterization including propagation and source term flags\n    - TIMESTEPS_NML: Time step configuration including CFL constraints\n    - GRID_NML &amp; RECT_NML/CURV_NML/UNST_NML/SMC_NML: Grid definition and parameters\n    - DEPTH_NML: Bathymetry depth data configuration\n    - MASK_NML: Point status map configuration\n    - OBSTACLE_NML: Obstruction map configuration\n    - SLOPE_NML: Reflection slope map configuration\n    - SEDIMENT_NML: Sedimentary bottom map configuration\n    - INBOUND_NML: Input boundary point configuration\n    - EXCLUDED_NML: Excluded point and body configuration\n    - OUTBOUND_NML: Output boundary line configuration\n\n    The Grid component is used for grid preprocessing runs and provides a clean interface\n    for configuring all aspects of the WW3 grid preprocessing program.\n\n    Key Features:\n    - **Spectral Configuration**: Frequency and direction discretization\n    - **Run Parameters**: Propagation and source term control\n    - **Time Stepping**: CFL-constrained time step configuration\n    - **Grid Definition**: Support for all WW3 grid types (RECT, CURV, UNST, SMC)\n    - **Bathymetry**: Depth data configuration and processing\n    - **Masking**: Point status and exclusion configuration\n    - **Boundary Conditions**: Input and output boundary configuration\n    \"\"\"\n\n    spectrum: Optional[Spectrum] = PydanticField(\n        default=None,\n        description=(\n            \"SPECTRUM_NML configuration defining spectral parameterization. \"\n            \"Includes frequency increment, first frequency, number of frequencies and directions, \"\n            \"and direction offset for wave spectrum discretization.\"\n        )\n    )\n    run: Optional[Run] = PydanticField(\n        default=None,\n        description=(\n            \"RUN_NML configuration defining run parameterization. \"\n            \"Includes flags for propagation components (X, Y, theta, k) and source terms.\"\n        )\n    )\n    timesteps: Optional[Timesteps] = PydanticField(\n        default=None,\n        description=(\n            \"TIMESTEPS_NML configuration defining time step parameters. \"\n            \"Includes CFL-constrained time steps for propagation and source terms.\"\n        )\n    )\n    depth: Optional[Depth] = PydanticField(\n        default=None,\n        description=(\n            \"DEPTH_NML configuration defining bathymetry depth data. \"\n            \"Includes scale factor and filename for depth data input.\"\n        )\n    )\n    mask: Optional[Mask] = PydanticField(\n        default=None,\n        description=(\n            \"MASK_NML configuration defining point status map. \"\n            \"Includes filename for point status map data input.\"\n        )\n    )\n    obstacle: Optional[Obstacle] = PydanticField(\n        default=None,\n        description=(\n            \"OBSTACLE_NML configuration defining obstruction map. \"\n            \"Includes scale factor and filename for obstruction data input.\"\n        )\n    )\n    slope: Optional[Slope] = PydanticField(\n        default=None,\n        description=(\n            \"SLOPE_NML configuration defining reflection slope map. \"\n            \"Includes scale factor and filename for reflection slope data input.\"\n        )\n    )\n    sediment: Optional[Sediment] = PydanticField(\n        default=None,\n        description=(\n            \"SEDIMENT_NML configuration defining sedimentary bottom map. \"\n            \"Includes scale factor and filename for sediment data input.\"\n        )\n    )\n    inbound_count: Optional[InboundCount] = PydanticField(\n        default=None,\n        description=(\n            \"INBOUND_COUNT_NML configuration defining number of input boundary points. \"\n            \"Specifies how many input boundary segments and bodies are defined.\"\n        )\n    )\n    inbound_points: Optional[InboundPointList] = PydanticField(\n        default=None,\n        description=(\n            \"INBOUND_POINT_NML configuration defining input boundary points. \"\n            \"Specifies the list of input boundary points and connection flags.\"\n        )\n    )\n    excluded_count: Optional[ExcludedCount] = PydanticField(\n        default=None,\n        description=(\n            \"EXCLUDED_COUNT_NML configuration defining number of excluded points and bodies. \"\n            \"Specifies how many excluded segments and bodies are defined.\"\n        )\n    )\n    excluded_points: Optional[ExcludedPointList] = PydanticField(\n        default=None,\n        description=(\n            \"EXCLUDED_POINT_NML configuration defining excluded points. \"\n            \"Specifies the list of excluded points and connection flags.\"\n        )\n    )\n    excluded_bodies: Optional[ExcludedBodyList] = PydanticField(\n        default=None,\n        description=(\n            \"EXCLUDED_BODY_NML configuration defining excluded bodies. \"\n            \"Specifies the list of excluded bodies (closed sea point regions).\"\n        )\n    )\n    outbound_count: Optional[OutboundCount] = PydanticField(\n        default=None,\n        description=(\n            \"OUTBOUND_COUNT_NML configuration defining number of output boundary lines. \"\n            \"Specifies how many output boundary lines are defined.\"\n        )\n    )\n    outbound_lines: Optional[OutboundLineList] = PydanticField(\n        default=None,\n        description=(\n            \"OUTBOUND_LINE_NML configuration defining output boundary lines. \"\n            \"Specifies the list of output boundary lines with start points, increments, and counts.\"\n        )\n    )\n    curv: Optional[Curv] = PydanticField(\n        default=None,\n        description=(\n            \"CURV_NML configuration defining curvilinear grid parameters. \"\n            \"Includes coordinate data specifications for curvilinear grids.\"\n        )\n    )\n    unst: Optional[Unst] = PydanticField(\n        default=None,\n        description=(\n            \"UNST_NML configuration defining unstructured grid parameters. \"\n            \"Includes filename and format specifications for unstructured grids.\"\n        )\n    )\n    smc: Optional[Smc] = PydanticField(\n        default=None,\n        description=(\n            \"SMC_NML configuration defining spherical multiple-cell grid parameters. \"\n            \"Includes file specifications for SMC grid components.\"\n        )\n    )\n    grid: Optional[GridNML] = PydanticField(\n        default=None,\n        description=(\n            \"GRID_NML configuration defining general grid parameters. \"\n            \"Includes grid name, type, coordinate system, closure, and depth limits.\"\n        )\n    )\n    rect: Optional[Rect] = PydanticField(\n        default=None,\n        description=(\n            \"RECT_NML configuration defining rectilinear grid parameters. \"\n            \"Includes grid dimensions, increments, and corner coordinates.\"\n        )\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_grid_closure(self) -&gt; \"Grid\":\n        \"\"\"Validate grid closure consistency.\n\n        This validator checks for grid closure consistency:\n        - If grid.rect is not None and grid.rect.nx * grid.rect.sx = 360,\n          then grid.grid.clos (GRID_NML%clos) should be set to 'SMPL'.\n\n        Returns:\n            Grid: The validated Grid component instance\n\n        Raises:\n            ValueError: If grid closure inconsistency is detected\n        \"\"\"\n        if self.rect is not None:\n            # Check if the grid spans 360 degrees in longitude (x-direction)\n            # which indicates a closed/periodic grid in longitude\n            longitude_extent = self.rect.nx * self.rect.sx\n            if (\n                abs(longitude_extent - 360.0) &lt; 1e-6\n            ):  # Account for floating point precision\n                # If grid closure is needed, ensure clos parameter is set to 'SMPL'\n                if self.grid is not None:\n                    if self.grid.clos != \"SMPL\":\n                        logger.warning(\n                            f\"Grid spans 360 degrees longitude ({self.rect.nx} * {self.rect.sx} = {longitude_extent}), \"\n                            f\"but clos is set to '{self.grid.clos}'. Setting to 'SMPL' for proper closure.\"\n                        )\n                        self.grid.clos = \"SMPL\"\n                else:\n                    # If grid namelist doesn't exist, create it with clos = 'SMPL'\n                    logger.warning(\n                        f\"Grid spans 360 degrees longitude ({self.rect.nx} * {self.rect.sx} = {longitude_extent}), \"\n                        f\"but no GRID_NML component exists. Creating GRID_NML with clos='SMPL' for proper closure.\"\n                    )\n                    from ..namelists.grid import Grid as GridNML\n\n                    self.grid = GridNML(clos=\"SMPL\")\n\n        return self\n\n    @property\n    def x(self) -&gt; np.ndarray:\n        \"\"\"Get the x-coordinate array for the grid.\n\n        Returns:\n            np.ndarray: The x-coordinate array for the grid points\n        \"\"\"\n        x, y = self.meshgrid\n        return x\n\n    @property\n    def y(self) -&gt; np.ndarray:\n        \"\"\"Get the y-coordinate array for the grid.\n\n        Returns:\n            np.ndarray: The y-coordinate array for the grid points\n        \"\"\"\n        x, y = self.meshgrid\n        return y\n\n    @property\n    def meshgrid(self) -&gt; np.ndarray:\n        \"\"\"Get the meshgrid for the grid.\n\n        Returns:\n            np.ndarray: The meshgrid (x, y) arrays for the grid points\n        \"\"\"\n        x = np.linspace(\n            self.rect.x0, self.rect.x0 + self.rect.sx * (self.rect.nx - 1), self.rect.nx\n        )\n        y = np.linspace(\n            self.rect.y0, self.rect.y0 + self.rect.sy * (self.rect.ny - 1), self.rect.ny\n        )\n        return np.meshgrid(x, y)\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.grid.Grid.spectrum","title":"spectrum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spectrum: Optional[Spectrum] = Field(default=None, description='SPECTRUM_NML configuration defining spectral parameterization. Includes frequency increment, first frequency, number of frequencies and directions, and direction offset for wave spectrum discretization.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.run","title":"run  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run: Optional[Run] = Field(default=None, description='RUN_NML configuration defining run parameterization. Includes flags for propagation components (X, Y, theta, k) and source terms.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.timesteps","title":"timesteps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timesteps: Optional[Timesteps] = Field(default=None, description='TIMESTEPS_NML configuration defining time step parameters. Includes CFL-constrained time steps for propagation and source terms.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.depth","title":"depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>depth: Optional[Depth] = Field(default=None, description='DEPTH_NML configuration defining bathymetry depth data. Includes scale factor and filename for depth data input.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.mask","title":"mask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mask: Optional[Mask] = Field(default=None, description='MASK_NML configuration defining point status map. Includes filename for point status map data input.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.obstacle","title":"obstacle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obstacle: Optional[Obstacle] = Field(default=None, description='OBSTACLE_NML configuration defining obstruction map. Includes scale factor and filename for obstruction data input.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.slope","title":"slope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slope: Optional[Slope] = Field(default=None, description='SLOPE_NML configuration defining reflection slope map. Includes scale factor and filename for reflection slope data input.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.sediment","title":"sediment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sediment: Optional[Sediment] = Field(default=None, description='SEDIMENT_NML configuration defining sedimentary bottom map. Includes scale factor and filename for sediment data input.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.inbound_count","title":"inbound_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inbound_count: Optional[InboundCount] = Field(default=None, description='INBOUND_COUNT_NML configuration defining number of input boundary points. Specifies how many input boundary segments and bodies are defined.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.inbound_points","title":"inbound_points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inbound_points: Optional[InboundPointList] = Field(default=None, description='INBOUND_POINT_NML configuration defining input boundary points. Specifies the list of input boundary points and connection flags.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.excluded_count","title":"excluded_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>excluded_count: Optional[ExcludedCount] = Field(default=None, description='EXCLUDED_COUNT_NML configuration defining number of excluded points and bodies. Specifies how many excluded segments and bodies are defined.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.excluded_points","title":"excluded_points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>excluded_points: Optional[ExcludedPointList] = Field(default=None, description='EXCLUDED_POINT_NML configuration defining excluded points. Specifies the list of excluded points and connection flags.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.excluded_bodies","title":"excluded_bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>excluded_bodies: Optional[ExcludedBodyList] = Field(default=None, description='EXCLUDED_BODY_NML configuration defining excluded bodies. Specifies the list of excluded bodies (closed sea point regions).')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.outbound_count","title":"outbound_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outbound_count: Optional[OutboundCount] = Field(default=None, description='OUTBOUND_COUNT_NML configuration defining number of output boundary lines. Specifies how many output boundary lines are defined.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.outbound_lines","title":"outbound_lines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outbound_lines: Optional[OutboundLineList] = Field(default=None, description='OUTBOUND_LINE_NML configuration defining output boundary lines. Specifies the list of output boundary lines with start points, increments, and counts.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.curv","title":"curv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curv: Optional[Curv] = Field(default=None, description='CURV_NML configuration defining curvilinear grid parameters. Includes coordinate data specifications for curvilinear grids.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.unst","title":"unst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unst: Optional[Unst] = Field(default=None, description='UNST_NML configuration defining unstructured grid parameters. Includes filename and format specifications for unstructured grids.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.smc","title":"smc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smc: Optional[Smc] = Field(default=None, description='SMC_NML configuration defining spherical multiple-cell grid parameters. Includes file specifications for SMC grid components.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: Optional[Grid] = Field(default=None, description='GRID_NML configuration defining general grid parameters. Includes grid name, type, coordinate system, closure, and depth limits.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.rect","title":"rect  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rect: Optional[Rect] = Field(default=None, description='RECT_NML configuration defining rectilinear grid parameters. Includes grid dimensions, increments, and corner coordinates.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.x","title":"x  <code>property</code>","text":"<pre><code>x: ndarray\n</code></pre> <p>Get the x-coordinate array for the grid.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The x-coordinate array for the grid points</p>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.y","title":"y  <code>property</code>","text":"<pre><code>y: ndarray\n</code></pre> <p>Get the y-coordinate array for the grid.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The y-coordinate array for the grid points</p>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid.meshgrid","title":"meshgrid  <code>property</code>","text":"<pre><code>meshgrid: ndarray\n</code></pre> <p>Get the meshgrid for the grid.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The meshgrid (x, y) arrays for the grid points</p>"},{"location":"reference/components/#rompy_ww3.components.grid.Grid-functions","title":"Functions","text":""},{"location":"reference/components/#rompy_ww3.components.grid.Grid.validate_grid_closure","title":"validate_grid_closure","text":"<pre><code>validate_grid_closure() -&gt; Grid\n</code></pre> <p>Validate grid closure consistency.</p> <p>This validator checks for grid closure consistency: - If grid.rect is not None and grid.rect.nx * grid.rect.sx = 360,   then grid.grid.clos (GRID_NML%clos) should be set to 'SMPL'.</p> <p>Returns:</p> Name Type Description <code>Grid</code> <code>Grid</code> <p>The validated Grid component instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If grid closure inconsistency is detected</p> Source code in <code>rompy_ww3/components/grid.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_grid_closure(self) -&gt; \"Grid\":\n    \"\"\"Validate grid closure consistency.\n\n    This validator checks for grid closure consistency:\n    - If grid.rect is not None and grid.rect.nx * grid.rect.sx = 360,\n      then grid.grid.clos (GRID_NML%clos) should be set to 'SMPL'.\n\n    Returns:\n        Grid: The validated Grid component instance\n\n    Raises:\n        ValueError: If grid closure inconsistency is detected\n    \"\"\"\n    if self.rect is not None:\n        # Check if the grid spans 360 degrees in longitude (x-direction)\n        # which indicates a closed/periodic grid in longitude\n        longitude_extent = self.rect.nx * self.rect.sx\n        if (\n            abs(longitude_extent - 360.0) &lt; 1e-6\n        ):  # Account for floating point precision\n            # If grid closure is needed, ensure clos parameter is set to 'SMPL'\n            if self.grid is not None:\n                if self.grid.clos != \"SMPL\":\n                    logger.warning(\n                        f\"Grid spans 360 degrees longitude ({self.rect.nx} * {self.rect.sx} = {longitude_extent}), \"\n                        f\"but clos is set to '{self.grid.clos}'. Setting to 'SMPL' for proper closure.\"\n                    )\n                    self.grid.clos = \"SMPL\"\n            else:\n                # If grid namelist doesn't exist, create it with clos = 'SMPL'\n                logger.warning(\n                    f\"Grid spans 360 degrees longitude ({self.rect.nx} * {self.rect.sx} = {longitude_extent}), \"\n                    f\"but no GRID_NML component exists. Creating GRID_NML with clos='SMPL' for proper closure.\"\n                )\n                from ..namelists.grid import Grid as GridNML\n\n                self.grid = GridNML(clos=\"SMPL\")\n\n    return self\n</code></pre>"},{"location":"reference/components/#multi-grid-component","title":"Multi-Grid Component","text":"<p>The Multi component handles multi-grid WW3 configuration (ww3_multi.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi","title":"Multi","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_multi.nml containing multi-grid configuration.</p> <p>The Multi component represents the multi-grid configuration for WW3. It contains all the namelist objects needed for configuring the WW3 multi-grid program (ww3_multi.nml).</p> <p>This component manages: - DOMAIN_NML: Multi-grid model parameters including start/stop times and I/O settings - INPUT_GRID_NML: Input grid specification for multi-grid models - MODEL_GRID_NML: Model grid specification for multi-grid models - OUTPUT_TYPE_NML: Output type configuration for multi-grid models - OUTPUT_DATE_NML: Output date configuration for multi-grid models - HOMOG_COUNT_NML: Homogeneous input count configuration for multi-grid models</p> <p>The Multi component is used for multi-grid WW3 runs and provides a clean interface for configuring all aspects of the WW3 multi-grid program.</p> <p>Key Features: - Multi-Grid Support: Configuration for multiple interconnected grids - Grid Communication: Input/output grid specification and communication - Output Management: Multi-grid output type and date configuration - Homogeneous Inputs: Multi-grid homogeneous input count management</p> Usage Examples <pre><code>from rompy_ww3.components import Multi\nfrom rompy_ww3.namelists import Domain, InputGrid, ModelGrid\n\n# Create a multi-grid configuration\nmulti = Multi(\n    domain=Domain(\n        start=\"20230101 000000\",\n        stop=\"20230107 000000\",\n        iostyp=1\n    ),\n    input_grid=InputGrid(\n        name=\"coarse_grid\",\n        forcing={\"winds\": \"T\"}\n    )\n)\n\n# Render the namelist content\ncontent = multi.render()\n\n# Write to a file\nmulti.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/multi.py</code> <pre><code>class Multi(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_multi.nml containing multi-grid configuration.\n\n    The Multi component represents the multi-grid configuration for WW3.\n    It contains all the namelist objects needed for configuring the WW3 multi-grid\n    program (ww3_multi.nml).\n\n    This component manages:\n    - DOMAIN_NML: Multi-grid model parameters including start/stop times and I/O settings\n    - INPUT_GRID_NML: Input grid specification for multi-grid models\n    - MODEL_GRID_NML: Model grid specification for multi-grid models\n    - OUTPUT_TYPE_NML: Output type configuration for multi-grid models\n    - OUTPUT_DATE_NML: Output date configuration for multi-grid models\n    - HOMOG_COUNT_NML: Homogeneous input count configuration for multi-grid models\n\n    The Multi component is used for multi-grid WW3 runs and provides a clean interface\n    for configuring all aspects of the WW3 multi-grid program.\n\n    Key Features:\n    - **Multi-Grid Support**: Configuration for multiple interconnected grids\n    - **Grid Communication**: Input/output grid specification and communication\n    - **Output Management**: Multi-grid output type and date configuration\n    - **Homogeneous Inputs**: Multi-grid homogeneous input count management\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Multi\n        from rompy_ww3.namelists import Domain, InputGrid, ModelGrid\n\n        # Create a multi-grid configuration\n        multi = Multi(\n            domain=Domain(\n                start=\"20230101 000000\",\n                stop=\"20230107 000000\",\n                iostyp=1\n            ),\n            input_grid=InputGrid(\n                name=\"coarse_grid\",\n                forcing={\"winds\": \"T\"}\n            )\n        )\n\n        # Render the namelist content\n        content = multi.render()\n\n        # Write to a file\n        multi.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    domain: Optional[Domain] = PydanticField(\n        default=None,\n        description=(\n            \"DOMAIN_NML configuration for multi-grid model parameters. \"\n            \"Includes start/stop times, I/O settings, and multi-grid specific parameters \"\n            \"such as number of input grids (nrinp) and number of model grids (nrgrd).\"\n        )\n    )\n    input_grid: Optional[InputGrid] = PydanticField(\n        default=None,\n        description=(\n            \"INPUT_GRID_NML configuration for input grid specification. \"\n            \"Defines the input grids for multi-grid models including grid names and forcing parameters.\"\n        )\n    )\n    model_grid: Optional[ModelGrid] = PydanticField(\n        default=None,\n        description=(\n            \"MODEL_GRID_NML configuration for model grid specification. \"\n            \"Defines the model grids for multi-grid models including grid names and model parameters.\"\n        )\n    )\n    model_grids: Optional[List[ModelGrid]] = PydanticField(\n        default=None,\n        description=(\n            \"List of MODEL_GRID_NML configurations for multiple model grids. \"\n            \"Each model grid includes grid names and model parameters for multi-grid runs.\"\n        )\n    )\n    output_type: Optional[OutputType] = PydanticField(\n        default=None,\n        description=(\n            \"OUTPUT_TYPE_NML configuration for multi-grid output types. \"\n            \"Defines output types and parameters for multi-grid models including field lists and point outputs.\"\n        )\n    )\n    output_date: Optional[OutputDate] = PydanticField(\n        default=None,\n        description=(\n            \"OUTPUT_DATE_NML configuration for multi-grid output dates. \"\n            \"Defines output timing parameters for multi-grid models including start, stride, and stop times.\"\n        )\n    )\n    homog_count: Optional[HomogCount] = PydanticField(\n        default=None,\n        description=(\n            \"HOMOG_COUNT_NML configuration for multi-grid homogeneous input counts. \"\n            \"Defines the number of homogeneous inputs for multi-grid models.\"\n        )\n    )\n\n    def render(self) -&gt; str:\n        \"\"\"Render the multi-grid component as a combined namelist string.\n\n        Generates the complete namelist content for the WW3 multi-grid configuration by\n        rendering all contained namelist objects in the proper order.\n\n        The rendering order follows WW3 conventions:\n        1. DOMAIN_NML - Multi-grid model parameters\n        2. INPUT_GRID_NML - Input grid specification\n        3. MODEL_GRID_NML - Model grid specification\n        4. OUTPUT_TYPE_NML - Multi-grid output types\n        5. OUTPUT_DATE_NML - Multi-grid output dates\n        6. HOMOG_COUNT_NML - Multi-grid homogeneous input counts\n\n        Returns:\n            str: The rendered multi-grid configuration as a combined namelist string\n        \"\"\"\n        multi_content = []\n        multi_content.append(\"! WW3 multi-grid model configuration\")\n        multi_content.append(\"! Generated by rompy-ww3\")\n        multi_content.append(\"\")\n\n        # Add DOMAIN_NML (for multi-grid specific parameters)\n        if self.domain:\n            rendered = self.domain.render()\n            multi_content.extend(rendered.split(\"\\n\"))\n            multi_content.append(\"\")\n\n        # Add INPUT_GRID_NML if defined\n        if self.input_grid:\n            rendered = self.input_grid.render()\n            multi_content.extend(rendered.split(\"\\n\"))\n            multi_content.append(\"\")\n        elif self.model_grids:  # If we have model grids but no specific input grid\n            for i, model_grid in enumerate(self.model_grids):\n                # Assuming each model grid has corresponding input\n                if model_grid.name:\n                    input_grid_nml = f\"&amp;INPUT_GRID_NML\\n  INPUT({i + 1})%NAME = '{model_grid.name}'\\n/\\n\"\n                    multi_content.append(input_grid_nml)\n                    multi_content.append(\"\")\n\n        # Add MODEL_GRID_NML configurations\n        if self.model_grids:\n            for i, model_grid in enumerate(self.model_grids):\n                rendered = model_grid.render()\n                # Replace the namelist name to be MODEL_GRID_NML instead of whatever is in the render\n                lines = rendered.split(\"\\n\")\n                updated_lines = []\n                for line in lines:\n                    if line.strip().startswith(\"&amp;\"):\n                        updated_lines.append(\"&amp;MODEL_GRID_NML\")\n                    elif line.strip() == \"/\":\n                        updated_lines.append(\n                            f\"  MODEL_NAME = '{model_grid.name}'  ! Index: {i + 1}\"\n                        )\n                        updated_lines.append(\"/\")\n                    else:\n                        # Need to update the fields to use the proper indexed format\n                        updated_line = line.replace(\"MODEL%\", f\"MODEL({i + 1})%\")\n                        updated_lines.append(updated_line)\n                multi_content.extend(updated_lines)\n                multi_content.append(\"\")\n        elif self.model_grid:  # Single model grid\n            rendered = self.model_grid.render()\n            # Replace the namelist name and fields to use proper indexed format\n            lines = rendered.split(\"\\n\")\n            updated_lines = []\n            for line in lines:\n                if line.strip().startswith(\"&amp;\"):\n                    updated_lines.append(\"&amp;MODEL_GRID_NML\")\n                elif line.strip() == \"/\":\n                    updated_lines.append(\n                        f\"  MODEL_NAME = '{self.model_grid.name}'  ! Index: 1\"\n                    )\n                    updated_lines.append(\"/\")\n                else:\n                    updated_line = line.replace(\"MODEL%\", \"MODEL(1)%\")\n                    updated_lines.append(updated_line)\n            multi_content.extend(updated_lines)\n            multi_content.append(\"\")\n\n        # Add OUTPUT_TYPE_NML\n        if self.output_type:\n            rendered = self.output_type.render()\n            multi_content.extend(rendered.split(\"\\n\"))\n            multi_content.append(\"\")\n\n        # Add OUTPUT_DATE_NML\n        if self.output_date:\n            rendered = self.output_date.render()\n            multi_content.extend(rendered.split(\"\\n\"))\n            multi_content.append(\"\")\n\n        # Add HOMOG_COUNT_NML if needed for multi-grid\n        if self.homog_count:\n            rendered = self.homog_count.render()\n            multi_content.extend(rendered.split(\"\\n\"))\n            multi_content.append(\"\")\n\n        return \"\\n\".join(multi_content)\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.multi.Multi.domain","title":"domain  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>domain: Optional[Domain] = Field(default=None, description='DOMAIN_NML configuration for multi-grid model parameters. Includes start/stop times, I/O settings, and multi-grid specific parameters such as number of input grids (nrinp) and number of model grids (nrgrd).')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi.input_grid","title":"input_grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input_grid: Optional[InputGrid] = Field(default=None, description='INPUT_GRID_NML configuration for input grid specification. Defines the input grids for multi-grid models including grid names and forcing parameters.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi.model_grid","title":"model_grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_grid: Optional[ModelGrid] = Field(default=None, description='MODEL_GRID_NML configuration for model grid specification. Defines the model grids for multi-grid models including grid names and model parameters.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi.model_grids","title":"model_grids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_grids: Optional[List[ModelGrid]] = Field(default=None, description='List of MODEL_GRID_NML configurations for multiple model grids. Each model grid includes grid names and model parameters for multi-grid runs.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi.output_type","title":"output_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_type: Optional[OutputType] = Field(default=None, description='OUTPUT_TYPE_NML configuration for multi-grid output types. Defines output types and parameters for multi-grid models including field lists and point outputs.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi.output_date","title":"output_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_date: Optional[OutputDate] = Field(default=None, description='OUTPUT_DATE_NML configuration for multi-grid output dates. Defines output timing parameters for multi-grid models including start, stride, and stop times.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi.homog_count","title":"homog_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>homog_count: Optional[HomogCount] = Field(default=None, description='HOMOG_COUNT_NML configuration for multi-grid homogeneous input counts. Defines the number of homogeneous inputs for multi-grid models.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.multi.Multi-functions","title":"Functions","text":""},{"location":"reference/components/#rompy_ww3.components.multi.Multi.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Render the multi-grid component as a combined namelist string.</p> <p>Generates the complete namelist content for the WW3 multi-grid configuration by rendering all contained namelist objects in the proper order.</p> <p>The rendering order follows WW3 conventions: 1. DOMAIN_NML - Multi-grid model parameters 2. INPUT_GRID_NML - Input grid specification 3. MODEL_GRID_NML - Model grid specification 4. OUTPUT_TYPE_NML - Multi-grid output types 5. OUTPUT_DATE_NML - Multi-grid output dates 6. HOMOG_COUNT_NML - Multi-grid homogeneous input counts</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The rendered multi-grid configuration as a combined namelist string</p> Source code in <code>rompy_ww3/components/multi.py</code> <pre><code>def render(self) -&gt; str:\n    \"\"\"Render the multi-grid component as a combined namelist string.\n\n    Generates the complete namelist content for the WW3 multi-grid configuration by\n    rendering all contained namelist objects in the proper order.\n\n    The rendering order follows WW3 conventions:\n    1. DOMAIN_NML - Multi-grid model parameters\n    2. INPUT_GRID_NML - Input grid specification\n    3. MODEL_GRID_NML - Model grid specification\n    4. OUTPUT_TYPE_NML - Multi-grid output types\n    5. OUTPUT_DATE_NML - Multi-grid output dates\n    6. HOMOG_COUNT_NML - Multi-grid homogeneous input counts\n\n    Returns:\n        str: The rendered multi-grid configuration as a combined namelist string\n    \"\"\"\n    multi_content = []\n    multi_content.append(\"! WW3 multi-grid model configuration\")\n    multi_content.append(\"! Generated by rompy-ww3\")\n    multi_content.append(\"\")\n\n    # Add DOMAIN_NML (for multi-grid specific parameters)\n    if self.domain:\n        rendered = self.domain.render()\n        multi_content.extend(rendered.split(\"\\n\"))\n        multi_content.append(\"\")\n\n    # Add INPUT_GRID_NML if defined\n    if self.input_grid:\n        rendered = self.input_grid.render()\n        multi_content.extend(rendered.split(\"\\n\"))\n        multi_content.append(\"\")\n    elif self.model_grids:  # If we have model grids but no specific input grid\n        for i, model_grid in enumerate(self.model_grids):\n            # Assuming each model grid has corresponding input\n            if model_grid.name:\n                input_grid_nml = f\"&amp;INPUT_GRID_NML\\n  INPUT({i + 1})%NAME = '{model_grid.name}'\\n/\\n\"\n                multi_content.append(input_grid_nml)\n                multi_content.append(\"\")\n\n    # Add MODEL_GRID_NML configurations\n    if self.model_grids:\n        for i, model_grid in enumerate(self.model_grids):\n            rendered = model_grid.render()\n            # Replace the namelist name to be MODEL_GRID_NML instead of whatever is in the render\n            lines = rendered.split(\"\\n\")\n            updated_lines = []\n            for line in lines:\n                if line.strip().startswith(\"&amp;\"):\n                    updated_lines.append(\"&amp;MODEL_GRID_NML\")\n                elif line.strip() == \"/\":\n                    updated_lines.append(\n                        f\"  MODEL_NAME = '{model_grid.name}'  ! Index: {i + 1}\"\n                    )\n                    updated_lines.append(\"/\")\n                else:\n                    # Need to update the fields to use the proper indexed format\n                    updated_line = line.replace(\"MODEL%\", f\"MODEL({i + 1})%\")\n                    updated_lines.append(updated_line)\n            multi_content.extend(updated_lines)\n            multi_content.append(\"\")\n    elif self.model_grid:  # Single model grid\n        rendered = self.model_grid.render()\n        # Replace the namelist name and fields to use proper indexed format\n        lines = rendered.split(\"\\n\")\n        updated_lines = []\n        for line in lines:\n            if line.strip().startswith(\"&amp;\"):\n                updated_lines.append(\"&amp;MODEL_GRID_NML\")\n            elif line.strip() == \"/\":\n                updated_lines.append(\n                    f\"  MODEL_NAME = '{self.model_grid.name}'  ! Index: 1\"\n                )\n                updated_lines.append(\"/\")\n            else:\n                updated_line = line.replace(\"MODEL%\", \"MODEL(1)%\")\n                updated_lines.append(updated_line)\n        multi_content.extend(updated_lines)\n        multi_content.append(\"\")\n\n    # Add OUTPUT_TYPE_NML\n    if self.output_type:\n        rendered = self.output_type.render()\n        multi_content.extend(rendered.split(\"\\n\"))\n        multi_content.append(\"\")\n\n    # Add OUTPUT_DATE_NML\n    if self.output_date:\n        rendered = self.output_date.render()\n        multi_content.extend(rendered.split(\"\\n\"))\n        multi_content.append(\"\")\n\n    # Add HOMOG_COUNT_NML if needed for multi-grid\n    if self.homog_count:\n        rendered = self.homog_count.render()\n        multi_content.extend(rendered.split(\"\\n\"))\n        multi_content.append(\"\")\n\n    return \"\\n\".join(multi_content)\n</code></pre>"},{"location":"reference/components/#boundary-conditions-component","title":"Boundary Conditions Component","text":"<p>The Bounc component handles WW3 boundary condition generation (ww3_bounc.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.bounc.Bounc","title":"Bounc","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_bounc.nml containing boundary update configuration.</p> <p>The Bounc component represents the boundary update configuration for WW3 multi-grid runs. It contains the BOUND_NML namelist object needed for configuring the WW3 boundary update program (ww3_bounc.nml).</p> <p>This component manages: - BOUND_NML: Boundary preprocessing parameters including mode, interpolation, and verbosity</p> <p>The Bounc component is used for boundary update runs in multi-grid configurations and provides a clean interface for configuring all aspects of the WW3 boundary update program.</p> <p>Key Features: - Boundary Processing: Configuration for boundary data processing - Interpolation: Interpolation method selection for boundary data - Verbosity: Control over output verbosity during boundary processing - File Handling: Input/output file specification for boundary data</p> Usage Examples <pre><code>from rompy_ww3.components import Bounc\nfrom rompy_ww3.namelists import Bound\n\n# Create a boundary update configuration\nbounc = Bounc(\n    bound=Bound(\n        mode=\"WRITE\",\n        interp=2,\n        verbose=1\n    )\n)\n\n# Render the namelist content\ncontent = bounc.render()\n\n# Write to a file\nbounc.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/bounc.py</code> <pre><code>class Bounc(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_bounc.nml containing boundary update configuration.\n\n    The Bounc component represents the boundary update configuration for WW3 multi-grid runs.\n    It contains the BOUND_NML namelist object needed for configuring the WW3 boundary update\n    program (ww3_bounc.nml).\n\n    This component manages:\n    - BOUND_NML: Boundary preprocessing parameters including mode, interpolation, and verbosity\n\n    The Bounc component is used for boundary update runs in multi-grid configurations and provides\n    a clean interface for configuring all aspects of the WW3 boundary update program.\n\n    Key Features:\n    - **Boundary Processing**: Configuration for boundary data processing\n    - **Interpolation**: Interpolation method selection for boundary data\n    - **Verbosity**: Control over output verbosity during boundary processing\n    - **File Handling**: Input/output file specification for boundary data\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Bounc\n        from rompy_ww3.namelists import Bound\n\n        # Create a boundary update configuration\n        bounc = Bounc(\n            bound=Bound(\n                mode=\"WRITE\",\n                interp=2,\n                verbose=1\n            )\n        )\n\n        # Render the namelist content\n        content = bounc.render()\n\n        # Write to a file\n        bounc.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    bound: Optional[Bound] = Field(\n        default=None,\n        description=(\n            \"BOUND_NML configuration for boundary preprocessing. \"\n            \"Defines mode (WRITE/READ), interpolation method, verbosity level, \"\n            \"and input/output file specification for boundary data processing.\"\n        )\n    )\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.bounc.Bounc-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.bounc.Bounc.bound","title":"bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bound: Optional[Bound] = Field(default=None, description='BOUND_NML configuration for boundary preprocessing. Defines mode (WRITE/READ), interpolation method, verbosity level, and input/output file specification for boundary data processing.')\n</code></pre>"},{"location":"reference/components/#boundary-data-component","title":"Boundary Data Component","text":"<p>The BounD component handles WW3 boundary data extraction (ww3_bound.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.bound.Bound","title":"Bound","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_bound.nml containing boundary configuration.</p> <p>The Bound component represents the boundary preprocessing configuration for WW3. It contains the BOUND_NML namelist object needed for configuring the WW3 boundary preprocessing program (ww3_bound.nml).</p> <p>This component manages: - BOUND_NML: Boundary preprocessing parameters including mode, interpolation, and verbosity</p> <p>The Bound component is used for boundary preprocessing runs and provides a clean interface for configuring all aspects of the WW3 boundary preprocessing program.</p> <p>Key Features: - Boundary Processing: Configuration for boundary data processing - Interpolation: Interpolation method selection for boundary data - Verbosity: Control over output verbosity during boundary processing - File Handling: Input/output file specification for boundary data</p> Usage Examples <pre><code>from rompy_ww3.components import Bound\nfrom rompy_ww3.namelists import Bound as BoundNML\n\n# Create a boundary preprocessing configuration\nbound = Bound(\n    bound=BoundNML(\n        mode=\"READ\",\n        interp=2,\n        verbose=1\n    )\n)\n\n# Render the namelist content\ncontent = bound.render()\n\n# Write to a file\nbound.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/bound.py</code> <pre><code>class Bound(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_bound.nml containing boundary configuration.\n\n    The Bound component represents the boundary preprocessing configuration for WW3.\n    It contains the BOUND_NML namelist object needed for configuring the WW3 boundary\n    preprocessing program (ww3_bound.nml).\n\n    This component manages:\n    - BOUND_NML: Boundary preprocessing parameters including mode, interpolation, and verbosity\n\n    The Bound component is used for boundary preprocessing runs and provides a clean interface\n    for configuring all aspects of the WW3 boundary preprocessing program.\n\n    Key Features:\n    - **Boundary Processing**: Configuration for boundary data processing\n    - **Interpolation**: Interpolation method selection for boundary data\n    - **Verbosity**: Control over output verbosity during boundary processing\n    - **File Handling**: Input/output file specification for boundary data\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Bound\n        from rompy_ww3.namelists import Bound as BoundNML\n\n        # Create a boundary preprocessing configuration\n        bound = Bound(\n            bound=BoundNML(\n                mode=\"READ\",\n                interp=2,\n                verbose=1\n            )\n        )\n\n        # Render the namelist content\n        content = bound.render()\n\n        # Write to a file\n        bound.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    bound: Optional[BoundNML] = PydanticField(\n        default=None,\n        description=(\n            \"BOUND_NML configuration for boundary preprocessing. \"\n            \"Defines mode (READ/WRITE), interpolation method, verbosity level, \"\n            \"and input/output file specification for boundary data processing.\"\n        )\n    )\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.bound.Bound-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.bound.Bound.bound","title":"bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bound: Optional[Bound] = Field(default=None, description='BOUND_NML configuration for boundary preprocessing. Defines mode (READ/WRITE), interpolation method, verbosity level, and input/output file specification for boundary data processing.')\n</code></pre>"},{"location":"reference/components/#preprocessor-component","title":"Preprocessor Component","text":"<p>The Prnc component handles WW3 preprocessor configuration (ww3_prnc.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc","title":"Prnc","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_prnc.nml containing field preprocessing configuration.</p> <p>The Prnc component represents the field preprocessing configuration for WW3. It contains the FORCING_NML and FILE_NML namelist objects needed for configuring  the WW3 field preprocessing program (ww3_prnc.nml).</p> <p>This component manages: - FORCING_NML: Forcing field parameters for preprocessing - FILE_NML: Input file parameters for preprocessing</p> <p>The Prnc component is used for field preprocessing runs and provides a clean interface for configuring all aspects of the WW3 field preprocessing program.</p> <p>Key Features: - Forcing Field Preprocessing: Configuration for forcing field preprocessing - File Input Processing: Configuration for input file preprocessing - Automatic Naming: Automatic generation of namelist filenames based on forcing type - Symbolic Linking: Automatic setup of symbolic links for WW3 execution</p> Usage Examples <pre><code>from rompy_ww3.components import Prnc\nfrom rompy_ww3.namelists import Forcing, File\n\n# Create a field preprocessing configuration\nprnc = Prnc(\n    forcing=Forcing(\n        timestart=\"20230101 000000\",\n        timestop=\"20230107 000000\",\n        field={\"winds\": \"T\"},\n        grid={\"latlon\": \"T\"}\n    ),\n    file=File(\n        filename=\"wind.nc\",\n        longitude=\"longitude\",\n        latitude=\"latitude\",\n        var1=\"U\",\n        var2=\"V\"\n    )\n)\n\n# Get the namelist filename\nfilename = prnc.nml_filename  # Automatically generated based on forcing type\n\n# Get the prepend command\ncmd = prnc.prepend_cmd  # Sets up symbolic link\n\n# Render the namelist content\ncontent = prnc.render()\n\n# Write to a file\nprnc.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/prnc.py</code> <pre><code>class Prnc(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_prnc.nml containing field preprocessing configuration.\n\n    The Prnc component represents the field preprocessing configuration for WW3.\n    It contains the FORCING_NML and FILE_NML namelist objects needed for configuring \n    the WW3 field preprocessing program (ww3_prnc.nml).\n\n    This component manages:\n    - FORCING_NML: Forcing field parameters for preprocessing\n    - FILE_NML: Input file parameters for preprocessing\n\n    The Prnc component is used for field preprocessing runs and provides a clean interface\n    for configuring all aspects of the WW3 field preprocessing program.\n\n    Key Features:\n    - **Forcing Field Preprocessing**: Configuration for forcing field preprocessing\n    - **File Input Processing**: Configuration for input file preprocessing\n    - **Automatic Naming**: Automatic generation of namelist filenames based on forcing type\n    - **Symbolic Linking**: Automatic setup of symbolic links for WW3 execution\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Prnc\n        from rompy_ww3.namelists import Forcing, File\n\n        # Create a field preprocessing configuration\n        prnc = Prnc(\n            forcing=Forcing(\n                timestart=\"20230101 000000\",\n                timestop=\"20230107 000000\",\n                field={\"winds\": \"T\"},\n                grid={\"latlon\": \"T\"}\n            ),\n            file=File(\n                filename=\"wind.nc\",\n                longitude=\"longitude\",\n                latitude=\"latitude\",\n                var1=\"U\",\n                var2=\"V\"\n            )\n        )\n\n        # Get the namelist filename\n        filename = prnc.nml_filename  # Automatically generated based on forcing type\n\n        # Get the prepend command\n        cmd = prnc.prepend_cmd  # Sets up symbolic link\n\n        # Render the namelist content\n        content = prnc.render()\n\n        # Write to a file\n        prnc.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    forcing: Optional[Forcing] = PydanticField(\n        default=None,\n        description=(\n            \"FORCING_NML configuration for field preprocessing. \"\n            \"Defines forcing field parameters including start/stop times, field types, \"\n            \"grid types, and tidal constituents for preprocessing input data.\"\n        )\n    )\n    file: Optional[File] = PydanticField(\n        default=None,\n        description=(\n            \"FILE_NML configuration for input file preprocessing. \"\n            \"Defines input file parameters including filename, longitude/latitude dimension names, \"\n            \"variable names (var1, var2, var3), and time shift for preprocessing input data.\"\n        )\n    )\n\n    @property\n    def nml_filename(self) -&gt; str:\n        \"\"\"Get the default filename for this component.\n\n        Returns the WW3-standard filename for field preprocessing namelists based on\n        the forcing variable name. For example, if the forcing variable is 'WND',\n        returns 'ww3_prnc.wnd'.\n\n        Returns:\n            str: The default namelist filename based on forcing variable name\n        \"\"\"\n        if self.forcing and hasattr(self.forcing, 'ww3_var_name'):\n            return f\"ww3_prnc.{self.forcing.ww3_var_name}\"\n        return \"ww3_prnc.nml\"\n\n    @property\n    def prepend_cmd(self) -&gt; str:\n        \"\"\"Get the string to prepend to the namelist file.\n\n        Creates a symbolic link from the generated namelist filename to the standard\n        WW3 preprocessing namelist name 'ww3_prnc.nml'. This is needed because WW3\n        preprocessing programs expect the namelist file to be named 'ww3_prnc.nml'.\n\n        Returns:\n            str: Command to create symbolic link from generated filename to 'ww3_prnc.nml'\n        \"\"\"\n        return f\"ln -sf {self.nml_filename} ww3_prnc.nml\"\n\n    @model_validator(mode=\"after\")\n    def set_datasource_id(self):\n        \"\"\"Ensure id are constent with WW3DataGrid.\n\n        This validator ensures that the datasource IDs are consistent with WW3DataGrid\n        by setting the filename ID to match the forcing variable name in lowercase.\n\n        This is needed to maintain consistency between the Prnc component and the\n        WW3DataGrid data source specifications.\n\n        Returns:\n            Prnc: The validated Prnc component instance\n\n        Raises:\n            ValueError: If there are issues with the datasource ID configuration\n        \"\"\"\n        if isinstance(self.file.filename, (WW3DataBlob, WW3DataGrid)):\n            self.file.filename.id = self.forcing.ww3_var_name.lower()\n        return self\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc.forcing","title":"forcing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forcing: Optional[Forcing] = Field(default=None, description='FORCING_NML configuration for field preprocessing. Defines forcing field parameters including start/stop times, field types, grid types, and tidal constituents for preprocessing input data.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Optional[File] = Field(default=None, description='FILE_NML configuration for input file preprocessing. Defines input file parameters including filename, longitude/latitude dimension names, variable names (var1, var2, var3), and time shift for preprocessing input data.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc.nml_filename","title":"nml_filename  <code>property</code>","text":"<pre><code>nml_filename: str\n</code></pre> <p>Get the default filename for this component.</p> <p>Returns the WW3-standard filename for field preprocessing namelists based on the forcing variable name. For example, if the forcing variable is 'WND', returns 'ww3_prnc.wnd'.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The default namelist filename based on forcing variable name</p>"},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc.prepend_cmd","title":"prepend_cmd  <code>property</code>","text":"<pre><code>prepend_cmd: str\n</code></pre> <p>Get the string to prepend to the namelist file.</p> <p>Creates a symbolic link from the generated namelist filename to the standard WW3 preprocessing namelist name 'ww3_prnc.nml'. This is needed because WW3 preprocessing programs expect the namelist file to be named 'ww3_prnc.nml'.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Command to create symbolic link from generated filename to 'ww3_prnc.nml'</p>"},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc-functions","title":"Functions","text":""},{"location":"reference/components/#rompy_ww3.components.prnc.Prnc.set_datasource_id","title":"set_datasource_id","text":"<pre><code>set_datasource_id()\n</code></pre> <p>Ensure id are constent with WW3DataGrid.</p> <p>This validator ensures that the datasource IDs are consistent with WW3DataGrid by setting the filename ID to match the forcing variable name in lowercase.</p> <p>This is needed to maintain consistency between the Prnc component and the WW3DataGrid data source specifications.</p> <p>Returns:</p> Name Type Description <code>Prnc</code> <p>The validated Prnc component instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are issues with the datasource ID configuration</p> Source code in <code>rompy_ww3/components/prnc.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_datasource_id(self):\n    \"\"\"Ensure id are constent with WW3DataGrid.\n\n    This validator ensures that the datasource IDs are consistent with WW3DataGrid\n    by setting the filename ID to match the forcing variable name in lowercase.\n\n    This is needed to maintain consistency between the Prnc component and the\n    WW3DataGrid data source specifications.\n\n    Returns:\n        Prnc: The validated Prnc component instance\n\n    Raises:\n        ValueError: If there are issues with the datasource ID configuration\n    \"\"\"\n    if isinstance(self.file.filename, (WW3DataBlob, WW3DataGrid)):\n        self.file.filename.id = self.forcing.ww3_var_name.lower()\n    return self\n</code></pre>"},{"location":"reference/components/#track-component","title":"Track Component","text":"<p>The Trnc component handles WW3 track processor configuration (ww3_trnc.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.trnc.Trnc","title":"Trnc","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_trnc.nml containing track output configuration.</p> <p>The Trnc component represents the track output configuration for WW3. It contains the TRACK_NML namelist object needed for configuring the WW3 track output program (ww3_trnc.nml).</p> <p>This component manages: - TRACK_NML: Track output parameters including timing and format</p> <p>The Trnc component is used for track output runs and provides a clean interface for configuring all aspects of the WW3 track output program.</p> <p>Key Features: - Track Output: Configuration for track output generation - Timing Control: Control over track output timing (start, stride, stop) - Format Selection: Choice of formatted/unformatted output - File Management: Track output file naming and organization</p> Usage Examples <pre><code>from rompy_ww3.components import Trnc\nfrom rompy_ww3.namelists import Track\n\n# Create a track output configuration\ntrnc = Trnc(\n    track=Track(\n        timestart=\"20230101 000000\",\n        timestride=\"3600\",\n        timecount=\"100\",\n        timesplit=8\n    )\n)\n\n# Render the namelist content\ncontent = trnc.render()\n\n# Write to a file\ntrnc.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/trnc.py</code> <pre><code>class Trnc(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_trnc.nml containing track output configuration.\n\n    The Trnc component represents the track output configuration for WW3.\n    It contains the TRACK_NML namelist object needed for configuring the WW3 track\n    output program (ww3_trnc.nml).\n\n    This component manages:\n    - TRACK_NML: Track output parameters including timing and format\n\n    The Trnc component is used for track output runs and provides a clean interface\n    for configuring all aspects of the WW3 track output program.\n\n    Key Features:\n    - **Track Output**: Configuration for track output generation\n    - **Timing Control**: Control over track output timing (start, stride, stop)\n    - **Format Selection**: Choice of formatted/unformatted output\n    - **File Management**: Track output file naming and organization\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Trnc\n        from rompy_ww3.namelists import Track\n\n        # Create a track output configuration\n        trnc = Trnc(\n            track=Track(\n                timestart=\"20230101 000000\",\n                timestride=\"3600\",\n                timecount=\"100\",\n                timesplit=8\n            )\n        )\n\n        # Render the namelist content\n        content = trnc.render()\n\n        # Write to a file\n        trnc.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    track: Optional[Track] = PydanticField(\n        default=None,\n        description=(\n            \"TRACK_NML configuration for track output. \"\n            \"Defines track output parameters including timing (start, stride, count, split) \"\n            \"and format for track output generation in WW3.\"\n        )\n    )\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.trnc.Trnc-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.trnc.Trnc.track","title":"track  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>track: Optional[Track] = Field(default=None, description='TRACK_NML configuration for track output. Defines track output parameters including timing (start, stride, count, split) and format for track output generation in WW3.')\n</code></pre>"},{"location":"reference/components/#output-fields-component","title":"Output Fields Component","text":"<p>The Ounf component handles WW3 field output configuration (ww3_ounf.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.ounf.Ounf","title":"Ounf","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_ounf.nml containing field (NetCDF) output configuration.</p> <p>The Ounf component represents the field output configuration for WW3. It contains the FIELD_NML and FILE_NML namelist objects needed for configuring  the WW3 field output program (ww3_ounf.nml).</p> <p>This component manages: - FIELD_NML: Field output parameters including timing and field lists - FILE_NML: Output file parameters including naming and format</p> <p>The Ounf component is used for field output runs and provides a clean interface for configuring all aspects of the WW3 field output program.</p> <p>Key Features: - Field Output: Configuration for field output generation - Timing Control: Control over field output timing (start, stride, stop) - Field Selection: Choice of which fields to output - Format Selection: Choice of NetCDF format (version 3 or 4) - File Management: Field output file naming and organization</p> Usage Examples <pre><code>from rompy_ww3.components import Ounf\nfrom rompy_ww3.namelists import Field, File\n\n# Create a field output configuration\nounf = Ounf(\n    field=Field(\n        timestart=\"20230101 000000\",\n        timestride=\"3600\",\n        timecount=\"100\",\n        list=\"HS DIR SPR WND ICE CUR LEV\"\n    ),\n    file=File(\n        prefix=\"ww3_field.\",\n        netcdf=4\n    )\n)\n\n# Render the namelist content\ncontent = ounf.render()\n\n# Write to a file\nounf.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/ounf.py</code> <pre><code>class Ounf(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_ounf.nml containing field (NetCDF) output configuration.\n\n    The Ounf component represents the field output configuration for WW3.\n    It contains the FIELD_NML and FILE_NML namelist objects needed for configuring \n    the WW3 field output program (ww3_ounf.nml).\n\n    This component manages:\n    - FIELD_NML: Field output parameters including timing and field lists\n    - FILE_NML: Output file parameters including naming and format\n\n    The Ounf component is used for field output runs and provides a clean interface\n    for configuring all aspects of the WW3 field output program.\n\n    Key Features:\n    - **Field Output**: Configuration for field output generation\n    - **Timing Control**: Control over field output timing (start, stride, stop)\n    - **Field Selection**: Choice of which fields to output\n    - **Format Selection**: Choice of NetCDF format (version 3 or 4)\n    - **File Management**: Field output file naming and organization\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Ounf\n        from rompy_ww3.namelists import Field, File\n\n        # Create a field output configuration\n        ounf = Ounf(\n            field=Field(\n                timestart=\"20230101 000000\",\n                timestride=\"3600\",\n                timecount=\"100\",\n                list=\"HS DIR SPR WND ICE CUR LEV\"\n            ),\n            file=File(\n                prefix=\"ww3_field.\",\n                netcdf=4\n            )\n        )\n\n        # Render the namelist content\n        content = ounf.render()\n\n        # Write to a file\n        ounf.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    field: Optional[FieldNML] = PydanticField(\n        default=None,\n        description=(\n            \"FIELD_NML configuration for field output. \"\n            \"Defines field output parameters including timing (start, stride, count), \"\n            \"field lists, partitions, and format for field output generation in WW3.\"\n        )\n    )\n    file: Optional[FileNML] = PydanticField(\n        default=None,\n        description=(\n            \"FILE_NML configuration for output files. \"\n            \"Defines output file parameters including naming prefix, NetCDF version, \"\n            \"and spatial subsetting for field output files in WW3.\"\n        )\n    )\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.ounf.Ounf-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.ounf.Ounf.field","title":"field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field: Optional[Field] = Field(default=None, description='FIELD_NML configuration for field output. Defines field output parameters including timing (start, stride, count), field lists, partitions, and format for field output generation in WW3.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.ounf.Ounf.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Optional[File] = Field(default=None, description='FILE_NML configuration for output files. Defines output file parameters including naming prefix, NetCDF version, and spatial subsetting for field output files in WW3.')\n</code></pre>"},{"location":"reference/components/#output-points-component","title":"Output Points Component","text":"<p>The Ounp component handles WW3 point output configuration (ww3_ounp.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.ounp.Ounp","title":"Ounp","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_ounp.nml containing point (NetCDF) output configuration.</p> <p>The Ounp component represents the point output configuration for WW3. It contains the POINT_NML, FILE_NML, SPECTRA_NML, PARAM_NML, and SOURCE_NML  namelist objects needed for configuring the WW3 point output program (ww3_ounp.nml).</p> <p>This component manages: - POINT_NML: Point output fields configuration - FILE_NML: Point output file configuration - SPECTRA_NML: Spectra output configuration (type 1) - PARAM_NML: Mean parameter output configuration (type 2) - SOURCE_NML: Source terms output configuration (type 3)</p> <p>The Ounp component is used for point output runs and provides a clean interface for configuring all aspects of the WW3 point output program.</p> <p>Key Features: - Point Output: Configuration for point output generation at specific locations - Multiple Output Types: Support for spectra (type 1), mean parameters (type 2), and source terms (type 3) - Flexible Timing: Control over point output timing (start, stride, stop) - Location Specification: Definition of point locations for output - File Management: Point output file naming and organization</p> Usage Examples <pre><code>from rompy_ww3.components import Ounp\nfrom rompy_ww3.namelists import Point, PointFile, Spectra, Param, Source\n\n# Create a point output configuration\nounp = Ounp(\n    point_nml=Point(\n        timestart=\"20230101 000000\",\n        timestride=\"3600\",\n        timecount=\"100\",\n        list=\"all\"\n    ),\n    file_nml=PointFile(\n        prefix=\"ww3_points.\",\n        netcdf=4\n    ),\n    spectra_nml=Spectra(\n        output=1,\n        scale_fac=1,\n        output_fac=0\n    )\n)\n\n# Render the namelist content\ncontent = ounp.render()\n\n# Write to a file\nounp.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/ounp.py</code> <pre><code>class Ounp(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_ounp.nml containing point (NetCDF) output configuration.\n\n    The Ounp component represents the point output configuration for WW3.\n    It contains the POINT_NML, FILE_NML, SPECTRA_NML, PARAM_NML, and SOURCE_NML \n    namelist objects needed for configuring the WW3 point output program (ww3_ounp.nml).\n\n    This component manages:\n    - POINT_NML: Point output fields configuration\n    - FILE_NML: Point output file configuration\n    - SPECTRA_NML: Spectra output configuration (type 1)\n    - PARAM_NML: Mean parameter output configuration (type 2)\n    - SOURCE_NML: Source terms output configuration (type 3)\n\n    The Ounp component is used for point output runs and provides a clean interface\n    for configuring all aspects of the WW3 point output program.\n\n    Key Features:\n    - **Point Output**: Configuration for point output generation at specific locations\n    - **Multiple Output Types**: Support for spectra (type 1), mean parameters (type 2), and source terms (type 3)\n    - **Flexible Timing**: Control over point output timing (start, stride, stop)\n    - **Location Specification**: Definition of point locations for output\n    - **File Management**: Point output file naming and organization\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Ounp\n        from rompy_ww3.namelists import Point, PointFile, Spectra, Param, Source\n\n        # Create a point output configuration\n        ounp = Ounp(\n            point_nml=Point(\n                timestart=\"20230101 000000\",\n                timestride=\"3600\",\n                timecount=\"100\",\n                list=\"all\"\n            ),\n            file_nml=PointFile(\n                prefix=\"ww3_points.\",\n                netcdf=4\n            ),\n            spectra_nml=Spectra(\n                output=1,\n                scale_fac=1,\n                output_fac=0\n            )\n        )\n\n        # Render the namelist content\n        content = ounp.render()\n\n        # Write to a file\n        ounp.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    # POINT_NML - Output fields configuration\n    point_nml: Optional[Point] = PydanticField(\n        default=None, \n        description=(\n            \"POINT_NML configuration for output fields. \"\n            \"Defines point output parameters including timing (start, stride, count), \"\n            \"point lists, and format for point output generation in WW3.\"\n        )\n    )\n\n    # FILE_NML - Output file configuration\n    file_nml: Optional[PointFile] = PydanticField(\n        default=None, \n        description=(\n            \"FILE_NML configuration for output files. \"\n            \"Defines point output file parameters including naming prefix, NetCDF version, \"\n            \"and format for point output files in WW3.\"\n        )\n    )\n\n    # SPECTRA_NML - Spectra output configuration (type 1)\n    spectra_nml: Optional[Spectra] = PydanticField(\n        default=None, \n        description=(\n            \"SPECTRA_NML configuration for spectra output (type 1). \"\n            \"Defines spectra output parameters including output type, scale factor, \"\n            \"and output factor for spectra output generation in WW3.\"\n        )\n    )\n\n    # PARAM_NML - Mean parameter output configuration (type 2)\n    param_nml: Optional[Param] = PydanticField(\n        default=None, \n        description=(\n            \"PARAM_NML configuration for mean parameter output (type 2). \"\n            \"Defines mean parameter output parameters including output type \"\n            \"for mean parameter output generation in WW3.\"\n        )\n    )\n\n    # SOURCE_NML - Source terms output configuration (type 3)\n    source_nml: Optional[Source] = PydanticField(\n        default=None, \n        description=(\n            \"SOURCE_NML configuration for source terms output (type 3). \"\n            \"Defines source terms output parameters including output type, scale factor, \"\n            \"output factor, table factor, and flags for source terms output generation in WW3.\"\n        )\n    )\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.ounp.Ounp-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.ounp.Ounp.point_nml","title":"point_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_nml: Optional[Point] = Field(default=None, description='POINT_NML configuration for output fields. Defines point output parameters including timing (start, stride, count), point lists, and format for point output generation in WW3.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.ounp.Ounp.file_nml","title":"file_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_nml: Optional[PointFile] = Field(default=None, description='FILE_NML configuration for output files. Defines point output file parameters including naming prefix, NetCDF version, and format for point output files in WW3.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.ounp.Ounp.spectra_nml","title":"spectra_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spectra_nml: Optional[Spectra] = Field(default=None, description='SPECTRA_NML configuration for spectra output (type 1). Defines spectra output parameters including output type, scale factor, and output factor for spectra output generation in WW3.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.ounp.Ounp.param_nml","title":"param_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>param_nml: Optional[Param] = Field(default=None, description='PARAM_NML configuration for mean parameter output (type 2). Defines mean parameter output parameters including output type for mean parameter output generation in WW3.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.ounp.Ounp.source_nml","title":"source_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_nml: Optional[Source] = Field(default=None, description='SOURCE_NML configuration for source terms output (type 3). Defines source terms output parameters including output type, scale factor, output factor, table factor, and flags for source terms output generation in WW3.')\n</code></pre>"},{"location":"reference/components/#restart-update-component","title":"Restart Update Component","text":"<p>The Uptstr component handles WW3 restart update configuration (ww3_upstr.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.uptstr.Uptstr","title":"Uptstr","text":"<p>               Bases: <code>WW3ComponentBaseModel</code></p> <p>Component for ww3_uprstr.nml containing restart update configuration.</p> <p>The Uptstr component represents the restart configuration for WW3. It contains the RESTART_UPDATE_NML namelist object needed for configuring the WW3 restart update program (ww3_uprstr.nml).</p> <p>This component manages: - RESTART_UPDATE_NML: Restart file update parameters including timing and update method</p> <p>The Uptstr component is used for restart update runs and provides a clean interface for configuring all aspects of the WW3 restart update program.</p> <p>Key Features: - Restart File Updates: Configuration for updating existing restart files - Timing Control: Control over when restart updates occur (time, stride) - Update Methods: Choice of update method (replace, add, multiply) - Field Selection: Selection of which fields to update (wave, water level, current, ice, wind) - File Management: Input/output restart file specification</p> Usage Examples <pre><code>from rompy_ww3.components import Uptstr\nfrom rompy_ww3.namelists import RestartUpdate\n\n# Create a restart update configuration\nuptstr = Uptstr(\n    restart_update=RestartUpdate(\n        update_time=\"20230101 000000\",\n        update_stride=\"43200\",\n        input_restart=\"restart_in.nc\",\n        output_restart=\"restart_out.nc\",\n        wave_field=True,\n        water_level=True,\n        current=True,\n        ice=True,\n        wind=True,\n        update_method=\"replace\"\n    )\n)\n\n# Render the namelist content\ncontent = uptstr.render()\n\n# Write to a file\nuptstr.write_nml(\"./namelists\")\n</code></pre> Source code in <code>rompy_ww3/components/uptstr.py</code> <pre><code>class Uptstr(WW3ComponentBaseModel):\n    \"\"\"Component for ww3_uprstr.nml containing restart update configuration.\n\n    The Uptstr component represents the restart configuration for WW3.\n    It contains the RESTART_UPDATE_NML namelist object needed for configuring\n    the WW3 restart update program (ww3_uprstr.nml).\n\n    This component manages:\n    - RESTART_UPDATE_NML: Restart file update parameters including timing and update method\n\n    The Uptstr component is used for restart update runs and provides a clean interface\n    for configuring all aspects of the WW3 restart update program.\n\n    Key Features:\n    - **Restart File Updates**: Configuration for updating existing restart files\n    - **Timing Control**: Control over when restart updates occur (time, stride)\n    - **Update Methods**: Choice of update method (replace, add, multiply)\n    - **Field Selection**: Selection of which fields to update (wave, water level, current, ice, wind)\n    - **File Management**: Input/output restart file specification\n\n    Usage Examples:\n        ```python\n        from rompy_ww3.components import Uptstr\n        from rompy_ww3.namelists import RestartUpdate\n\n        # Create a restart update configuration\n        uptstr = Uptstr(\n            restart_update=RestartUpdate(\n                update_time=\"20230101 000000\",\n                update_stride=\"43200\",\n                input_restart=\"restart_in.nc\",\n                output_restart=\"restart_out.nc\",\n                wave_field=True,\n                water_level=True,\n                current=True,\n                ice=True,\n                wind=True,\n                update_method=\"replace\"\n            )\n        )\n\n        # Render the namelist content\n        content = uptstr.render()\n\n        # Write to a file\n        uptstr.write_nml(\"./namelists\")\n        ```\n    \"\"\"\n\n    restart_update: Optional[RestartUpdate] = Field(\n        default=None,\n        description=(\n            \"RESTART_UPDATE_NML configuration for restart file updates. \"\n            \"Defines restart file update parameters including timing (time, stride), \"\n            \"input/output file specification, field selection (wave, water level, current, ice, wind), \"\n            \"and update method (replace, add, multiply) for restart file updates in WW3.\"\n        ),\n    )\n\n    @property\n    def nml_filename(self) -&gt; str:\n        \"\"\"Get the default filename for this component.\n\n        Returns:\n            str: The default namelist filename 'ww3_uprstr.nml'\n        \"\"\"\n        return \"ww3_uprstr.nml\"\n\n    @property\n    def run_cmd(self) -&gt; str:\n        \"\"\"Get the default run command for this component.\n\n        Returns:\n            str: The command to run the WW3 restart update executable 'ww3_uprstr'\n        \"\"\"\n        return \"ww3_uprstr\"\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.uptstr.Uptstr-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.uptstr.Uptstr.restart_update","title":"restart_update  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>restart_update: Optional[RestartUpdate] = Field(default=None, description='RESTART_UPDATE_NML configuration for restart file updates. Defines restart file update parameters including timing (time, stride), input/output file specification, field selection (wave, water level, current, ice, wind), and update method (replace, add, multiply) for restart file updates in WW3.')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.uptstr.Uptstr.nml_filename","title":"nml_filename  <code>property</code>","text":"<pre><code>nml_filename: str\n</code></pre> <p>Get the default filename for this component.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The default namelist filename 'ww3_uprstr.nml'</p>"},{"location":"reference/components/#rompy_ww3.components.uptstr.Uptstr.run_cmd","title":"run_cmd  <code>property</code>","text":"<pre><code>run_cmd: str\n</code></pre> <p>Get the default run command for this component.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The command to run the WW3 restart update executable 'ww3_uprstr'</p>"},{"location":"reference/components/#physics-parameters-component","title":"Physics Parameters Component","text":"<p>The Namelists component handles WW3 physics parameter configuration for source terms, propagation schemes, and other model physics (namelists.nml).</p>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists","title":"Namelists","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>Container for all WW3 physics parameter namelists.</p> <p>This model contains all the individual physics parameter components that make up the namelists.nml file in WW3.</p> Source code in <code>rompy_ww3/components/namelists.py</code> <pre><code>class Namelists(NamelistBaseModel):\n    \"\"\"Container for all WW3 physics parameter namelists.\n\n    This model contains all the individual physics parameter components\n    that make up the namelists.nml file in WW3.\n    \"\"\"\n\n    misc: Optional[MISC] = Field(\n        default=None, description=\"MISC namelist for miscellaneous parameters\"\n    )\n    flx: Optional[FLX] = Field(\n        default=None, description=\"FLX namelist for flux parameters\"\n    )\n    sin1: Optional[SIN1] = Field(\n        default=None,\n        description=\"SIN1 namelist for first wind input physics parameters\",\n    )\n    sin2: Optional[SIN2] = Field(\n        default=None,\n        description=\"SIN2 namelist for second wind input physics parameters\",\n    )\n    sin3: Optional[SIN3] = Field(\n        default=None,\n        description=\"SIN3 namelist for third wind input physics parameters\",\n    )\n    sin4: Optional[SIN4] = Field(\n        default=None,\n        description=\"SIN4 namelist for fourth wind input physics parameters\",\n    )\n    snl1: Optional[SNL1] = Field(\n        default=None,\n        description=\"SNL1 namelist for first nonlinear interaction physics parameters\",\n    )\n    snl2: Optional[SNL2] = Field(\n        default=None,\n        description=\"SNL2 namelist for second nonlinear interaction physics parameters\",\n    )\n    snl3: Optional[SNL3] = Field(\n        default=None,\n        description=\"SNL3 namelist for third nonlinear interaction physics parameters\",\n    )\n    snl4: Optional[SNL4] = Field(\n        default=None,\n        description=\"SNL4 namelist for fourth nonlinear interaction physics parameters\",\n    )\n    sds1: Optional[SDS1] = Field(\n        default=None,\n        description=\"SDS1 namelist for first whitecapping physics parameters\",\n    )\n    sds2: Optional[SDS2] = Field(\n        default=None,\n        description=\"SDS2 namelist for second whitecapping physics parameters\",\n    )\n    sds3: Optional[SDS3] = Field(\n        default=None,\n        description=\"SDS3 namelist for third whitecapping physics parameters\",\n    )\n    sds4: Optional[SDS4] = Field(\n        default=None,\n        description=\"SDS4 namelist for fourth whitecapping physics parameters\",\n    )\n    sbt: Optional[SBT] = Field(\n        default=None, description=\"SBT namelist for bottom friction physics parameters\"\n    )\n    sdb: Optional[SDB] = Field(\n        default=None,\n        description=\"SDB namelist for surf/depth-induced breaking physics parameters\",\n    )\n    pro1: Optional[PRO1] = Field(\n        default=None,\n        description=\"PRO1 namelist for first propagation scheme parameters\",\n    )\n    pro2: Optional[PRO2] = Field(\n        default=None,\n        description=\"PRO2 namelist for second propagation scheme parameters\",\n    )\n    pro3: Optional[PRO3] = Field(\n        default=None,\n        description=\"PRO3 namelist for third propagation scheme parameters\",\n    )\n    pro4: Optional[PRO4] = Field(\n        default=None,\n        description=\"PRO4 namelist for fourth propagation scheme parameters\",\n    )\n\n    def render(self, *args, **kwargs) -&gt; str:\n        \"\"\"Custom render  for namelists as a string.\"\"\"\n\n        content = []\n        # Get the model data\n        model_data = self.model_dump()\n        for key, value in model_data.items():\n            if value is None:\n                continue\n            line = f\"&amp;{key.upper()}\"\n            separator = \" \"\n            for sub_key, sub_value in value.items():\n                line += f\"{separator}{sub_key.upper()} = {sub_value}\"\n                separator = \", \"\n            line += \" /\"\n            content.append(line)\n\n        content.append(\"END OF NAMELISTS\")\n        return \"\\n\".join(content)\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists-attributes","title":"Attributes","text":""},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.misc","title":"misc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>misc: Optional[MISC] = Field(default=None, description='MISC namelist for miscellaneous parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.flx","title":"flx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flx: Optional[FLX] = Field(default=None, description='FLX namelist for flux parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sin1","title":"sin1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sin1: Optional[SIN1] = Field(default=None, description='SIN1 namelist for first wind input physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sin2","title":"sin2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sin2: Optional[SIN2] = Field(default=None, description='SIN2 namelist for second wind input physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sin3","title":"sin3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sin3: Optional[SIN3] = Field(default=None, description='SIN3 namelist for third wind input physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sin4","title":"sin4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sin4: Optional[SIN4] = Field(default=None, description='SIN4 namelist for fourth wind input physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.snl1","title":"snl1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>snl1: Optional[SNL1] = Field(default=None, description='SNL1 namelist for first nonlinear interaction physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.snl2","title":"snl2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>snl2: Optional[SNL2] = Field(default=None, description='SNL2 namelist for second nonlinear interaction physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.snl3","title":"snl3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>snl3: Optional[SNL3] = Field(default=None, description='SNL3 namelist for third nonlinear interaction physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.snl4","title":"snl4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>snl4: Optional[SNL4] = Field(default=None, description='SNL4 namelist for fourth nonlinear interaction physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sds1","title":"sds1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sds1: Optional[SDS1] = Field(default=None, description='SDS1 namelist for first whitecapping physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sds2","title":"sds2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sds2: Optional[SDS2] = Field(default=None, description='SDS2 namelist for second whitecapping physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sds3","title":"sds3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sds3: Optional[SDS3] = Field(default=None, description='SDS3 namelist for third whitecapping physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sds4","title":"sds4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sds4: Optional[SDS4] = Field(default=None, description='SDS4 namelist for fourth whitecapping physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sbt","title":"sbt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sbt: Optional[SBT] = Field(default=None, description='SBT namelist for bottom friction physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.sdb","title":"sdb  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sdb: Optional[SDB] = Field(default=None, description='SDB namelist for surf/depth-induced breaking physics parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.pro1","title":"pro1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pro1: Optional[PRO1] = Field(default=None, description='PRO1 namelist for first propagation scheme parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.pro2","title":"pro2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pro2: Optional[PRO2] = Field(default=None, description='PRO2 namelist for second propagation scheme parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.pro3","title":"pro3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pro3: Optional[PRO3] = Field(default=None, description='PRO3 namelist for third propagation scheme parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.pro4","title":"pro4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pro4: Optional[PRO4] = Field(default=None, description='PRO4 namelist for fourth propagation scheme parameters')\n</code></pre>"},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists-functions","title":"Functions","text":""},{"location":"reference/components/#rompy_ww3.components.namelists.Namelists.render","title":"render","text":"<pre><code>render(*args, **kwargs) -&gt; str\n</code></pre> <p>Custom render  for namelists as a string.</p> Source code in <code>rompy_ww3/components/namelists.py</code> <pre><code>def render(self, *args, **kwargs) -&gt; str:\n    \"\"\"Custom render  for namelists as a string.\"\"\"\n\n    content = []\n    # Get the model data\n    model_data = self.model_dump()\n    for key, value in model_data.items():\n        if value is None:\n            continue\n        line = f\"&amp;{key.upper()}\"\n        separator = \" \"\n        for sub_key, sub_value in value.items():\n            line += f\"{separator}{sub_key.upper()} = {sub_value}\"\n            separator = \", \"\n        line += \" /\"\n        content.append(line)\n\n    content.append(\"END OF NAMELISTS\")\n    return \"\\n\".join(content)\n</code></pre>"},{"location":"reference/config/","title":"Config API Reference","text":""},{"location":"reference/config/#rompy_ww3.config.NMLConfig","title":"NMLConfig","text":"<p>               Bases: <code>BaseWW3Config</code></p> <p>WW3 namelist-based config class. This class provides direct control over WW3 namelists via component objects.</p> Source code in <code>rompy_ww3/config.py</code> <pre><code>class NMLConfig(BaseWW3Config):\n    \"\"\"WW3 namelist-based config class.\n    This class provides direct control over WW3 namelists via component objects.\n    \"\"\"\n\n    model_type: Literal[\"nml\"] = PydanticField(\n        default=\"nml\",\n        description=\"Model type discriminator\",\n    )\n\n    @property\n    def main_template(self) -&gt; str:\n        \"\"\"Return the path to the main template file.\"\"\"\n        return str(HERE / \"templates\" / \"base\" / \"ww3_shel.nml\")\n\n    # WW3-specific component configurations\n    ww3_shel: Optional[Shel] = PydanticField(\n        default=None, description=\"Shell component (ww3_shel.nml) configuration\"\n    )\n    ww3_grid: Optional[Grid] = PydanticField(\n        default=None, description=\"Grid component (ww3_grid.nml) configuration\"\n    )\n    multi_component: Optional[Multi] = PydanticField(\n        default=None, description=\"Multi-grid component (ww3_multi.nml) configuration\"\n    )\n    ww3_bounc: Optional[Bounc] = PydanticField(\n        default=None,\n        description=\"Boundary component (ww3_bounc.nml) configuration\",\n    )\n    ww3_prnc: Optional[list[Prnc]] = PydanticField(\n        default=None,\n        description=\"Field preprocessor component (ww3_prnc.nml) configuration\",\n    )\n    ww3_track: Optional[Trnc] = PydanticField(\n        default=None, description=\"Track component (ww3_trnc.nml) configuration\"\n    )\n    ww3_ounf: Optional[Ounf] = PydanticField(\n        default=None,\n        description=\"Field output component (ww3_ounf.nml) configuration\",\n    )\n    ww3_ounp: Optional[Ounp] = PydanticField(\n        default=None, description=\"Point output component (ww3_ounp.nml) configuration\"\n    )\n    ww3_upstr: Optional[Uptstr] = PydanticField(\n        default=None,\n        description=\"Restart update component (ww3_uprstr.nml) configuration\",\n    )\n    namelists: Optional[Namelists] = PydanticField(\n        default=None, description=\"Namelists component (namelists.nml) configuration\"\n    )\n\n    @model_validator(mode=\"after\")\n    def sync_component_fields(self):\n        \"\"\"\n        Synchronize field list between shell output_type and field output components.\n        If ww3_shel.output_type.field.list is set but ww3_ounf.field.list is not set,\n        then set ww3_ounf.field.list to the same value.\n        Also synchronize forcing parameters: if ww3_prnc.forcing[n].field.winds='T',\n        then ww3_shel.input_nml.forcing.winds should also be 'T' and so on for all forcing types.\n        \"\"\"\n        # Check if ww3_shel and its output_type exist and have field.list set\n        if (\n            self.ww3_shel\n            and self.ww3_shel.output_type\n            and self.ww3_shel.output_type.field\n        ):\n            shel_field_list = self.ww3_shel.output_type.field.list\n            # Check if ww3_ounf exists and its field.list is not set\n            if (\n                self.ww3_ounf\n                and self.ww3_ounf.field\n                and shel_field_list is not None\n                and self.ww3_ounf.field.list is None\n            ):\n                # Set the field list from shel to ounf\n                self.ww3_ounf.field.list = shel_field_list\n\n        # Define mapping between forcing field boolean attributes and input forcing string attributes\n        # Both share the same attribute names for the forcing types\n        forcing_mapping = [\n            \"winds\",\n            \"currents\",\n            \"water_levels\",\n            \"atm_momentum\",\n            \"air_density\",\n            \"ice_conc\",\n            \"ice_param1\",\n            \"ice_param2\",\n            \"ice_param3\",\n            \"ice_param4\",\n            \"ice_param5\",\n            \"mud_density\",\n            \"mud_thickness\",\n            \"mud_viscosity\",\n        ]\n\n        # Synchronize forcing parameters between ww3_prnc and ww3_shel.input_nml\n        # For each active forcing in ww3_prnc, set the corresponding input forcing flag to 'T'\n        # Make it cumulative across multiple PRNC components\n        if self.ww3_prnc and isinstance(self.ww3_prnc, list):\n            # Process all PRNC components to collect all active forcing types\n            active_forcings = {}\n\n            for prnc_component in self.ww3_prnc:\n                if (\n                    prnc_component\n                    and prnc_component.forcing\n                    and prnc_component.forcing.field\n                ):\n                    # Check each forcing type in the mapping\n                    for forcing_type in forcing_mapping:\n                        forcing_attr = getattr(\n                            prnc_component.forcing.field, forcing_type, None\n                        )\n                        if forcing_attr is True:  # If the forcing is active in prnc\n                            active_forcings[forcing_type] = \"T\"\n\n            # Apply all active forcings to the shel input\n            if active_forcings:  # If we found any active forcings\n                # Ensure ww3_shel exists\n                if self.ww3_shel:\n                    # Ensure input_nml exists\n                    if not self.ww3_shel.input_nml:\n                        from rompy_ww3.namelists.input import Input\n\n                        self.ww3_shel.input_nml = Input()\n\n                    # Ensure input_nml.forcing exists\n                    if not self.ww3_shel.input_nml.forcing:\n                        from rompy_ww3.namelists.input import InputForcing\n\n                        self.ww3_shel.input_nml.forcing = InputForcing()\n\n                    # Apply each active forcing if not already set\n                    for forcing_type, value in active_forcings.items():\n                        current_value = getattr(\n                            self.ww3_shel.input_nml.forcing, forcing_type\n                        )\n                        if current_value is None:\n                            setattr(\n                                self.ww3_shel.input_nml.forcing, forcing_type, value\n                            )\n        return self\n\n    def __call__(self, runtime) -&gt; dict:\n        \"\"\"Callable where data and config are interfaced and CMD is rendered.\"\"\"\n\n        # Set default dates from the runtime period if available\n        self._set_default_dates(runtime)\n\n        # Generate WW3 control namelist files\n        self.write_control_files(runtime)\n\n        # Generate execution scripts based on what files and executables are needed\n        self.generate_run_script(runtime.staging_dir)\n\n    def _set_default_dates(self, runtime):\n        \"\"\"Set default start and end dates from the runtime period if not already set in components.\"\"\"\n        # Get the period from runtime if available\n        period = getattr(runtime, \"period\", None)\n        if not period:\n            return  # No period to use for defaults\n\n        # Convert interval to seconds if it exists\n        interval_seconds = None\n        if hasattr(period, \"interval\") and period.interval:\n            interval_seconds = int(period.interval.total_seconds())\n\n        # Special handling for shell component: if output_type is active but output_date is not set,\n        # initialize output_date and its sub-components to ensure dates are set properly\n        if self.ww3_shel and self.ww3_shel.output_type:\n            from rompy_ww3.namelists.output_date import (\n                OutputDate,\n                OutputDateField,\n                OutputDatePoint,\n                OutputDateTrack,\n                OutputDateRestart,\n                OutputDatePartition,\n                OutputDateCoupling,\n            )\n\n            # Check if any output type is active (not None) and initialize corresponding output_date components\n            needs_output_date = (\n                self.ww3_shel.output_type.field\n                or self.ww3_shel.output_type.point\n                or self.ww3_shel.output_type.track\n                or self.ww3_shel.output_type.partition\n                or self.ww3_shel.output_type.coupling\n                or self.ww3_shel.output_type.restart\n            )\n\n            if needs_output_date:\n                # If output_date is None, create an empty one\n                if self.ww3_shel.output_date is None:\n                    self.ww3_shel.output_date = OutputDate()\n\n                # Initialize specific output_date components that correspond to active output_types\n                if (\n                    self.ww3_shel.output_type.field\n                    and self.ww3_shel.output_date.field is None\n                ):\n                    self.ww3_shel.output_date.field = OutputDateField()\n                if (\n                    self.ww3_shel.output_type.point\n                    and self.ww3_shel.output_date.point is None\n                ):\n                    self.ww3_shel.output_date.point = OutputDatePoint()\n                if (\n                    self.ww3_shel.output_type.track\n                    and self.ww3_shel.output_date.track is None\n                ):\n                    self.ww3_shel.output_date.track = OutputDateTrack()\n                if (\n                    self.ww3_shel.output_type.restart\n                    and self.ww3_shel.output_date.restart is None\n                ):\n                    self.ww3_shel.output_date.restart = OutputDateRestart()\n                if (\n                    self.ww3_shel.output_type.partition\n                    and self.ww3_shel.output_date.partition is None\n                ):\n                    self.ww3_shel.output_date.partition = OutputDatePartition()\n                if (\n                    self.ww3_shel.output_type.coupling\n                    and self.ww3_shel.output_date.coupling is None\n                ):\n                    self.ww3_shel.output_date.coupling = OutputDateCoupling()\n\n        # Iterate through all attributes of this config instance\n        for attr_name in self.components:\n            component = getattr(self, attr_name)\n            if component is not None:\n                self._set_component_dates_recursive(component, period)\n                # Also set stride if interval exists\n                if interval_seconds is not None:\n                    self._set_component_stride_recursive(component, interval_seconds)\n            if isinstance(component, list):\n                for sub_component in component:\n                    self._set_component_dates_recursive(sub_component, period)\n                    # Also set stride if interval exists\n                    if interval_seconds is not None:\n                        self._set_component_stride_recursive(\n                            sub_component, interval_seconds\n                        )\n\n    def _set_component_dates_recursive(self, obj, period):\n        \"\"\"\n        Recursively find and set date fields in a component and its nested objects.\n\n        Args:\n            obj: The object to process\n            period: The time period to use for default dates\n        \"\"\"\n        # If this is a namelist object, use its built-in date setting method\n        if hasattr(obj, \"set_default_dates\"):\n            obj.set_default_dates(period)\n        # For non-namelist objects, process their fields recursively\n        elif hasattr(obj, \"__dict__\") or hasattr(obj, \"__pydantic_fields__\"):\n            if hasattr(obj, \"model_fields\"):\n                # Process Pydantic model fields\n                for field_name in obj.model_fields:\n                    field_value = getattr(obj, field_name)\n                    # Recursively process nested objects\n                    if hasattr(field_value, \"__dict__\") or hasattr(\n                        field_value, \"__pydantic_fields__\"\n                    ):\n                        if field_value is not None and not isinstance(\n                            field_value, (str, int, float, bool, list, dict)\n                        ):\n                            self._set_component_dates_recursive(field_value, period)\n                    # Also process lists of objects\n                    elif isinstance(field_value, list):\n                        for item in field_value:\n                            if hasattr(item, \"__dict__\") or hasattr(\n                                item, \"__pydantic_fields__\"\n                            ):\n                                if item is not None and not isinstance(\n                                    item, (str, int, float, bool, dict)\n                                ):\n                                    self._set_component_dates_recursive(item, period)\n\n    def _set_component_stride_recursive(self, obj, interval_seconds):\n        \"\"\"\n        Recursively find and set stride fields in a component and its nested objects.\n\n        Args:\n            obj: The object to process\n            interval_seconds: The time interval in seconds to use for default stride\n        \"\"\"\n        # If this is a namelist object with stride attribute, set it if not already set\n        if hasattr(obj, \"stride\") and getattr(obj, \"stride\") is None:\n            obj.stride = str(interval_seconds)\n        # If this is a namelist object with timestride attribute, set it if not already set\n        if hasattr(obj, \"timestride\") and getattr(obj, \"timestride\") is None:\n            obj.timestride = str(interval_seconds)\n\n        # For non-namelist objects, process their fields recursively\n        elif hasattr(obj, \"__dict__\") or hasattr(obj, \"__pydantic_fields__\"):\n            if hasattr(obj, \"model_fields\"):\n                # Process Pydantic model fields\n                for field_name in obj.model_fields:\n                    field_value = getattr(obj, field_name)\n                    # Recursively process nested objects\n                    if hasattr(field_value, \"__dict__\") or hasattr(\n                        field_value, \"__pydantic_fields__\"\n                    ):\n                        if field_value is not None and not isinstance(\n                            field_value, (str, int, float, bool, list, dict)\n                        ):\n                            self._set_component_stride_recursive(\n                                field_value, interval_seconds\n                            )\n                    # Also process lists of objects\n                    elif isinstance(field_value, list):\n                        for item in field_value:\n                            if hasattr(item, \"__dict__\") or hasattr(\n                                item, \"__pydantic_fields__\"\n                            ):\n                                if item is not None and not isinstance(\n                                    item, (str, int, float, bool, dict)\n                                ):\n                                    self._set_component_stride_recursive(\n                                        item, interval_seconds\n                                    )\n\n    def render_namelists(self) -&gt; Dict[str, str]:\n        \"\"\"Render all component namelists as a dictionary of strings.\n\n        Returns:\n            Dictionary containing rendered namelist content keyed by filename\n        \"\"\"\n        namelists = {}\n\n        # Render each component's namelist if it exists\n        for component_name in self.components:\n            component = getattr(self, component_name, None)\n            if component is not None:\n                # Handle both single components and lists of components\n                if isinstance(component, list):\n                    for idx, sub_component in enumerate(component):\n                        if hasattr(sub_component, \"render\"):\n                            key = f\"{component_name}_{idx}.nml\"\n                            namelists[key] = sub_component.render()\n                        elif hasattr(\n                            sub_component, \"get_template_context\"\n                        ):  # If it's a custom component\n                            sub_context = sub_component.get_template_context()\n                            if \"namelists\" in sub_context:\n                                for sub_key, sub_content in sub_context[\n                                    \"namelists\"\n                                ].items():\n                                    namelists[f\"{component_name}_{idx}_{sub_key}\"] = (\n                                        sub_content\n                                    )\n                else:\n                    if hasattr(component, \"render\"):\n                        key = f\"{component_name}.nml\"\n                        namelists[key] = component.render()\n                    elif hasattr(\n                        component, \"get_template_context\"\n                    ):  # If it's a custom component\n                        sub_context = component.get_template_context()\n                        if \"namelists\" in sub_context:\n                            for sub_key, sub_content in sub_context[\n                                \"namelists\"\n                            ].items():\n                                namelists[f\"{sub_key}\"] = sub_content\n\n        return namelists\n\n    def get_template_context(self) -&gt; Dict[str, Any]:\n        \"\"\"Generate template context for Jinja2 templates.\n\n        Returns:\n            Dictionary containing context variables for templates\n        \"\"\"\n        context = {\n            \"config\": self,\n        }\n\n        # Add rendered namelists to context\n        context[\"namelists\"] = self.render_namelists()\n\n        return context\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig-attributes","title":"Attributes","text":""},{"location":"reference/config/#rompy_ww3.config.NMLConfig.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['nml'] = Field(default='nml', description='Model type discriminator')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.main_template","title":"main_template  <code>property</code>","text":"<pre><code>main_template: str\n</code></pre> <p>Return the path to the main template file.</p>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_shel","title":"ww3_shel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_shel: Optional[Shel] = Field(default=None, description='Shell component (ww3_shel.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_grid","title":"ww3_grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_grid: Optional[Grid] = Field(default=None, description='Grid component (ww3_grid.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.multi_component","title":"multi_component  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multi_component: Optional[Multi] = Field(default=None, description='Multi-grid component (ww3_multi.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_bounc","title":"ww3_bounc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_bounc: Optional[Bounc] = Field(default=None, description='Boundary component (ww3_bounc.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_prnc","title":"ww3_prnc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_prnc: Optional[list[Prnc]] = Field(default=None, description='Field preprocessor component (ww3_prnc.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_track","title":"ww3_track  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_track: Optional[Trnc] = Field(default=None, description='Track component (ww3_trnc.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_ounf","title":"ww3_ounf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_ounf: Optional[Ounf] = Field(default=None, description='Field output component (ww3_ounf.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_ounp","title":"ww3_ounp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_ounp: Optional[Ounp] = Field(default=None, description='Point output component (ww3_ounp.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.ww3_upstr","title":"ww3_upstr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ww3_upstr: Optional[Uptstr] = Field(default=None, description='Restart update component (ww3_uprstr.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.namelists","title":"namelists  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>namelists: Optional[Namelists] = Field(default=None, description='Namelists component (namelists.nml) configuration')\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig-functions","title":"Functions","text":""},{"location":"reference/config/#rompy_ww3.config.NMLConfig.sync_component_fields","title":"sync_component_fields","text":"<pre><code>sync_component_fields()\n</code></pre> <p>Synchronize field list between shell output_type and field output components. If ww3_shel.output_type.field.list is set but ww3_ounf.field.list is not set, then set ww3_ounf.field.list to the same value. Also synchronize forcing parameters: if ww3_prnc.forcing[n].field.winds='T', then ww3_shel.input_nml.forcing.winds should also be 'T' and so on for all forcing types.</p> Source code in <code>rompy_ww3/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef sync_component_fields(self):\n    \"\"\"\n    Synchronize field list between shell output_type and field output components.\n    If ww3_shel.output_type.field.list is set but ww3_ounf.field.list is not set,\n    then set ww3_ounf.field.list to the same value.\n    Also synchronize forcing parameters: if ww3_prnc.forcing[n].field.winds='T',\n    then ww3_shel.input_nml.forcing.winds should also be 'T' and so on for all forcing types.\n    \"\"\"\n    # Check if ww3_shel and its output_type exist and have field.list set\n    if (\n        self.ww3_shel\n        and self.ww3_shel.output_type\n        and self.ww3_shel.output_type.field\n    ):\n        shel_field_list = self.ww3_shel.output_type.field.list\n        # Check if ww3_ounf exists and its field.list is not set\n        if (\n            self.ww3_ounf\n            and self.ww3_ounf.field\n            and shel_field_list is not None\n            and self.ww3_ounf.field.list is None\n        ):\n            # Set the field list from shel to ounf\n            self.ww3_ounf.field.list = shel_field_list\n\n    # Define mapping between forcing field boolean attributes and input forcing string attributes\n    # Both share the same attribute names for the forcing types\n    forcing_mapping = [\n        \"winds\",\n        \"currents\",\n        \"water_levels\",\n        \"atm_momentum\",\n        \"air_density\",\n        \"ice_conc\",\n        \"ice_param1\",\n        \"ice_param2\",\n        \"ice_param3\",\n        \"ice_param4\",\n        \"ice_param5\",\n        \"mud_density\",\n        \"mud_thickness\",\n        \"mud_viscosity\",\n    ]\n\n    # Synchronize forcing parameters between ww3_prnc and ww3_shel.input_nml\n    # For each active forcing in ww3_prnc, set the corresponding input forcing flag to 'T'\n    # Make it cumulative across multiple PRNC components\n    if self.ww3_prnc and isinstance(self.ww3_prnc, list):\n        # Process all PRNC components to collect all active forcing types\n        active_forcings = {}\n\n        for prnc_component in self.ww3_prnc:\n            if (\n                prnc_component\n                and prnc_component.forcing\n                and prnc_component.forcing.field\n            ):\n                # Check each forcing type in the mapping\n                for forcing_type in forcing_mapping:\n                    forcing_attr = getattr(\n                        prnc_component.forcing.field, forcing_type, None\n                    )\n                    if forcing_attr is True:  # If the forcing is active in prnc\n                        active_forcings[forcing_type] = \"T\"\n\n        # Apply all active forcings to the shel input\n        if active_forcings:  # If we found any active forcings\n            # Ensure ww3_shel exists\n            if self.ww3_shel:\n                # Ensure input_nml exists\n                if not self.ww3_shel.input_nml:\n                    from rompy_ww3.namelists.input import Input\n\n                    self.ww3_shel.input_nml = Input()\n\n                # Ensure input_nml.forcing exists\n                if not self.ww3_shel.input_nml.forcing:\n                    from rompy_ww3.namelists.input import InputForcing\n\n                    self.ww3_shel.input_nml.forcing = InputForcing()\n\n                # Apply each active forcing if not already set\n                for forcing_type, value in active_forcings.items():\n                    current_value = getattr(\n                        self.ww3_shel.input_nml.forcing, forcing_type\n                    )\n                    if current_value is None:\n                        setattr(\n                            self.ww3_shel.input_nml.forcing, forcing_type, value\n                        )\n    return self\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.render_namelists","title":"render_namelists","text":"<pre><code>render_namelists() -&gt; Dict[str, str]\n</code></pre> <p>Render all component namelists as a dictionary of strings.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary containing rendered namelist content keyed by filename</p> Source code in <code>rompy_ww3/config.py</code> <pre><code>def render_namelists(self) -&gt; Dict[str, str]:\n    \"\"\"Render all component namelists as a dictionary of strings.\n\n    Returns:\n        Dictionary containing rendered namelist content keyed by filename\n    \"\"\"\n    namelists = {}\n\n    # Render each component's namelist if it exists\n    for component_name in self.components:\n        component = getattr(self, component_name, None)\n        if component is not None:\n            # Handle both single components and lists of components\n            if isinstance(component, list):\n                for idx, sub_component in enumerate(component):\n                    if hasattr(sub_component, \"render\"):\n                        key = f\"{component_name}_{idx}.nml\"\n                        namelists[key] = sub_component.render()\n                    elif hasattr(\n                        sub_component, \"get_template_context\"\n                    ):  # If it's a custom component\n                        sub_context = sub_component.get_template_context()\n                        if \"namelists\" in sub_context:\n                            for sub_key, sub_content in sub_context[\n                                \"namelists\"\n                            ].items():\n                                namelists[f\"{component_name}_{idx}_{sub_key}\"] = (\n                                    sub_content\n                                )\n            else:\n                if hasattr(component, \"render\"):\n                    key = f\"{component_name}.nml\"\n                    namelists[key] = component.render()\n                elif hasattr(\n                    component, \"get_template_context\"\n                ):  # If it's a custom component\n                    sub_context = component.get_template_context()\n                    if \"namelists\" in sub_context:\n                        for sub_key, sub_content in sub_context[\n                            \"namelists\"\n                        ].items():\n                            namelists[f\"{sub_key}\"] = sub_content\n\n    return namelists\n</code></pre>"},{"location":"reference/config/#rompy_ww3.config.NMLConfig.get_template_context","title":"get_template_context","text":"<pre><code>get_template_context() -&gt; Dict[str, Any]\n</code></pre> <p>Generate template context for Jinja2 templates.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing context variables for templates</p> Source code in <code>rompy_ww3/config.py</code> <pre><code>def get_template_context(self) -&gt; Dict[str, Any]:\n    \"\"\"Generate template context for Jinja2 templates.\n\n    Returns:\n        Dictionary containing context variables for templates\n    \"\"\"\n    context = {\n        \"config\": self,\n    }\n\n    # Add rendered namelists to context\n    context[\"namelists\"] = self.render_namelists()\n\n    return context\n</code></pre>"},{"location":"reference/config/#usage","title":"Usage","text":"<p>The Config class is the main entry point for configuring WW3 models in rompy-ww3. It accepts namelist objects directly and supports the new clean grid architecture.</p>"},{"location":"reference/config/#basic-usage","title":"Basic Usage","text":"<pre><code>from rompy_ww3.config import Config\nfrom rompy_ww3.grid import RectGrid\nfrom rompy_ww3.namelists.grid import Grid as GRID_NML, Rect\nfrom rompy_ww3.namelists.timesteps import Timesteps\n\n# Create grid with direct namelist objects\ngrid = RectGrid(\n    grid_type=\"base\",\n    model_type=\"ww3_rect\",\n    grid_nml=GRID_NML(\n        name=\"Clean Grid\",\n        type=\"RECT\",\n        coord=\"SPHE\",\n        clos=\"SMPL\",\n        zlim=-0.2,\n        dmin=3.0,\n    ),\n    rect_nml=Rect(\n        nx=300,\n        ny=150,\n        sx=0.1,\n        sy=0.1,\n        sf=1.5,\n        x0=180.0,\n        y0=20.0,\n        sf0=2.0,\n    ),\n)\n\n# Create config with the clean grid architecture\nconfig = Config(\n    grid=grid,  # Accepts AnyWw3Grid union type\n    timesteps=Timesteps(\n        dt=1800.0,\n        dtfield=3600.0,\n        dtpoint=3600.0,\n        dtmax=180.0,\n        dtxy=60.0,\n        dtkth=30.0,\n        dtmin=10.0,\n    ),\n)\n</code></pre>"},{"location":"reference/config/#multi-grid-support","title":"Multi-Grid Support","text":"<pre><code>from rompy_ww3.config import Config\nfrom rompy_ww3.grid import RectGrid, CurvGrid\n\n# Create multiple grids of different types\nrect_grid = RectGrid(\n    grid_type=\"base\",\n    model_type=\"ww3_rect\",\n    grid_nml=GRID_NML(...),\n    rect_nml=Rect(...),\n)\n\ncurv_grid = CurvGrid(\n    grid_type=\"base\", \n    model_type=\"ww3_curv\",\n    grid_nml=GRID_NML(...),\n    curv_nml=Curv(...),\n    x_coord_file=Path(\"x_coords.dat\"),\n    y_coord_file=Path(\"y_coords.dat\"),\n)\n\n# Config supports both single and multi-grid configurations\nsingle_grid_config = Config(grid=rect_grid)\nmulti_grid_config = Config(grid=rect_grid, grids=[rect_grid, curv_grid])\n</code></pre>"},{"location":"reference/config/#direct-namelist-access","title":"Direct Namelist Access","text":"<pre><code># Access namelist objects directly through config\ngrid_nml_content = config.grid.grid_nml.render()\nrect_nml_content = config.grid.rect_nml.render()\n\n# Generate all namelists at once\nall_namelists = config.render_namelists()\n</code></pre>"},{"location":"reference/data/","title":"Data API Reference","text":""},{"location":"reference/data/#rompy_ww3.data.DataAssimilation","title":"DataAssimilation","text":"<p>               Bases: <code>DataBase</code></p> <p>Ww3 data class with WW3-specific data handling capabilities.</p> <p>This class extends DataBase with WW3-specific data handling for wave model inputs. It uses rompy Source objects to read large lazy datasets, crops the required area and time from the data, writes to the rompy WW3 workspace, and updates the appropriate nml objects internally to point to the processed files.</p> Source code in <code>rompy_ww3/data.py</code> <pre><code>class DataAssimilation(DataBase):\n    \"\"\"Ww3 data class with WW3-specific data handling capabilities.\n\n    This class extends DataBase with WW3-specific data handling for wave model inputs.\n    It uses rompy Source objects to read large lazy datasets, crops the required\n    area and time from the data, writes to the rompy WW3 workspace, and updates\n    the appropriate nml objects internally to point to the processed files.\n    \"\"\"\n\n    model_type: Literal[\"assimilation\"] = Field(\n        default=\"ww3\",\n        description=\"Model type discriminator\",\n    )\n\n    assimilation_values: Optional[List[float]] = Field(\n        default=None,\n        description=\"Assimilation values for data (used when assim_flag = 'T')\",\n    )\n\n    def assimilation_flag(self) -&gt; str:\n        \"\"\"Return the assimilation flag for assimilation data.\"\"\"\n        return \"T\"\n\n    def description(self) -&gt; str:\n        \"\"\"Return a description of the assimilation data.\"\"\"\n        return \"This class handles assimilation data specifically for the WW3 model.\"\n\n    def get(self, destdir: Union[str, Path], *args, **kwargs) -&gt; Path:\n        \"\"\"Retrieve, process and save WW3 assimilation data.\n\n        This method will use the source to retrieve data, then process it\n        by cropping to the required time and area, and save the processed\n        netCDF file to the specified destination. It also creates the namelist\n        file needed for external ww3_prnc processing.\n\n        Args:\n            destdir: Destination directory to save the processed file and namelist\n            *args: Additional positional arguments\n            **kwargs: Additional keyword arguments\n        Returns:\n            Path to the WW3-ready output file (after external ww3_prnc processing)\n        \"\"\"\n        raise NotImplementedError(\"Assimilation data handling is not yet implemented.\")\n</code></pre>"},{"location":"reference/data/#rompy_ww3.data.DataAssimilation-attributes","title":"Attributes","text":""},{"location":"reference/data/#rompy_ww3.data.DataAssimilation.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['assimilation'] = Field(default='ww3', description='Model type discriminator')\n</code></pre>"},{"location":"reference/data/#rompy_ww3.data.DataAssimilation.assimilation_values","title":"assimilation_values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>assimilation_values: Optional[List[float]] = Field(default=None, description=\"Assimilation values for data (used when assim_flag = 'T')\")\n</code></pre>"},{"location":"reference/data/#rompy_ww3.data.DataAssimilation-functions","title":"Functions","text":""},{"location":"reference/data/#rompy_ww3.data.DataAssimilation.assimilation_flag","title":"assimilation_flag","text":"<pre><code>assimilation_flag() -&gt; str\n</code></pre> <p>Return the assimilation flag for assimilation data.</p> Source code in <code>rompy_ww3/data.py</code> <pre><code>def assimilation_flag(self) -&gt; str:\n    \"\"\"Return the assimilation flag for assimilation data.\"\"\"\n    return \"T\"\n</code></pre>"},{"location":"reference/data/#rompy_ww3.data.DataAssimilation.description","title":"description","text":"<pre><code>description() -&gt; str\n</code></pre> <p>Return a description of the assimilation data.</p> Source code in <code>rompy_ww3/data.py</code> <pre><code>def description(self) -&gt; str:\n    \"\"\"Return a description of the assimilation data.\"\"\"\n    return \"This class handles assimilation data specifically for the WW3 model.\"\n</code></pre>"},{"location":"reference/data/#rompy_ww3.data.DataAssimilation.get","title":"get","text":"<pre><code>get(destdir: Union[str, Path], *args, **kwargs) -&gt; Path\n</code></pre> <p>Retrieve, process and save WW3 assimilation data.</p> <p>This method will use the source to retrieve data, then process it by cropping to the required time and area, and save the processed netCDF file to the specified destination. It also creates the namelist file needed for external ww3_prnc processing.</p> <p>Parameters:</p> Name Type Description Default <code>destdir</code> <code>Union[str, Path]</code> <p>Destination directory to save the processed file and namelist</p> required <code>*args</code> <p>Additional positional arguments</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:     Path to the WW3-ready output file (after external ww3_prnc processing)</p> Source code in <code>rompy_ww3/data.py</code> <pre><code>def get(self, destdir: Union[str, Path], *args, **kwargs) -&gt; Path:\n    \"\"\"Retrieve, process and save WW3 assimilation data.\n\n    This method will use the source to retrieve data, then process it\n    by cropping to the required time and area, and save the processed\n    netCDF file to the specified destination. It also creates the namelist\n    file needed for external ww3_prnc processing.\n\n    Args:\n        destdir: Destination directory to save the processed file and namelist\n        *args: Additional positional arguments\n        **kwargs: Additional keyword arguments\n    Returns:\n        Path to the WW3-ready output file (after external ww3_prnc processing)\n    \"\"\"\n    raise NotImplementedError(\"Assimilation data handling is not yet implemented.\")\n</code></pre>"},{"location":"reference/grid/","title":"Grid API Reference","text":"<p>The rompy-ww3 plugin provides separate grid classes for each WW3 grid type, following a clean architecture where users pass actual namelist objects directly instead of individual parameters.</p>"},{"location":"reference/grid/#new-grid-architecture","title":"New Grid Architecture","text":"<p>Instead of a single generic <code>Grid</code> class, rompy-ww3 now provides specific classes for each grid type:</p> <ul> <li><code>RectGrid</code> - Rectilinear grids</li> <li><code>CurvGrid</code> - Curvilinear grids  </li> <li><code>UnstGrid</code> - Unstructured grids</li> <li><code>SmcGrid</code> - Spherical Multiple-Cell (SMC) grids</li> </ul> <p>Each grid type accepts only the namelist objects relevant to that specific grid type, eliminating redundant parameters and validation complexity.</p>"},{"location":"reference/grid/#grid-classes","title":"Grid Classes","text":""},{"location":"reference/grid/#rectgrid","title":"RectGrid","text":"<p>               Bases: <code>BaseWW3Grid</code></p> <p>Rectilinear WW3 grid class.</p>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid-attributes","title":"Attributes","text":""},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ww3_rect'] = Field(default='ww3_rect', description='Model type discriminator for rectilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.rect","title":"rect  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rect: Rect = Field(..., description='RECT_NML namelist object for rectilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.depth","title":"depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>depth: Optional[Depth] = Field(default=None, description='Depth namelist object for rectilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.mask","title":"mask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mask: Optional[Mask] = Field(default=None, description='Mask namelist object for rectilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.obst","title":"obst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obst: Optional[Obstacle] = Field(default=None, description='Obstruction namelist object for rectilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.slope","title":"slope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slope: Optional[Slope] = Field(default=None, description='Slope namelist object for rectilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.sed","title":"sed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sed: Optional[Sediment] = Field(default=None, description='Sediment namelist object for rectilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.x","title":"x  <code>property</code>","text":"<pre><code>x: ndarray\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.y","title":"y  <code>property</code>","text":"<pre><code>y: ndarray\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.grid_specific_nml","title":"grid_specific_nml  <code>property</code>","text":"<pre><code>grid_specific_nml: Rect\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.grid_specific_name","title":"grid_specific_name  <code>property</code>","text":"<pre><code>grid_specific_name: str\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.RectGrid.namelist_file_attrs","title":"namelist_file_attrs  <code>property</code>","text":"<pre><code>namelist_file_attrs: List[Tuple[str, str]]\n</code></pre> <p>Return list of (attribute_name, filename_attribute) for optional namelist files.</p>"},{"location":"reference/grid/#curvgrid","title":"CurvGrid","text":"<p>               Bases: <code>BaseWW3Grid</code></p> <p>Curvilinear WW3 grid class.</p>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid-attributes","title":"Attributes","text":""},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ww3_curv'] = Field(default='ww3_curv', description='Model type discriminator for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.curv_nml","title":"curv_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>curv_nml: Curv = Field(description='CURV_NML namelist object for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.x_coord_file","title":"x_coord_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x_coord_file: Path = Field(description='Path to x-coordinate file for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.y_coord_file","title":"y_coord_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_coord_file: Path = Field(description='Path to y-coordinate file for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.depth","title":"depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>depth: Optional[Depth] = Field(default=None, description='Depth namelist object for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.mask","title":"mask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mask: Optional[Mask] = Field(default=None, description='Mask namelist object for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.obst","title":"obst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>obst: Optional[Obstacle] = Field(default=None, description='Obstruction namelist object for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.slope","title":"slope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slope: Optional[Slope] = Field(default=None, description='Slope namelist object for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.sed","title":"sed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sed: Optional[Sediment] = Field(default=None, description='Sediment namelist object for curvilinear grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.grid_specific_nml","title":"grid_specific_nml  <code>property</code>","text":"<pre><code>grid_specific_nml: Curv\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.grid_specific_name","title":"grid_specific_name  <code>property</code>","text":"<pre><code>grid_specific_name: str\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.additional_file_attrs","title":"additional_file_attrs  <code>property</code>","text":"<pre><code>additional_file_attrs: List[str]\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.CurvGrid.namelist_file_attrs","title":"namelist_file_attrs  <code>property</code>","text":"<pre><code>namelist_file_attrs: List[Tuple[str, str]]\n</code></pre> <p>Return list of (attribute_name, filename_attribute) for optional namelist files.</p>"},{"location":"reference/grid/#unstgrid","title":"UnstGrid","text":"<p>               Bases: <code>BaseWW3Grid</code></p> <p>Unstructured WW3 grid class.</p>"},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid-attributes","title":"Attributes","text":""},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ww3_unst'] = Field(default='ww3_unst', description='Model type discriminator for unstructured grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid.unst_nml","title":"unst_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unst_nml: Unst = Field(description='UNST_NML namelist object for unstructured grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid.unst_obc_file","title":"unst_obc_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unst_obc_file: Optional[Path] = Field(default=None, description='Path to additional boundary list file for unstructured grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid.grid_specific_nml","title":"grid_specific_nml  <code>property</code>","text":"<pre><code>grid_specific_nml: Unst\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid.grid_specific_name","title":"grid_specific_name  <code>property</code>","text":"<pre><code>grid_specific_name: str\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid.additional_file_attrs","title":"additional_file_attrs  <code>property</code>","text":"<pre><code>additional_file_attrs: List[str]\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.UnstGrid.namelist_file_attrs","title":"namelist_file_attrs  <code>property</code>","text":"<pre><code>namelist_file_attrs: List[Tuple[str, str]]\n</code></pre> <p>Return empty list as UNST grids don't typically use optional namelist files.</p>"},{"location":"reference/grid/#smcgrid","title":"SmcGrid","text":"<p>               Bases: <code>BaseWW3Grid</code></p> <p>SMC (Spherical Multiple-Cell) WW3 grid class.</p>"},{"location":"reference/grid/#rompy_ww3.grid.SmcGrid-attributes","title":"Attributes","text":""},{"location":"reference/grid/#rompy_ww3.grid.SmcGrid.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ww3_smc'] = Field(default='ww3_smc', description='Model type discriminator for SMC grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.SmcGrid.smc_nml","title":"smc_nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smc_nml: Smc = Field(description='SMC_NML namelist object for SMC grid')\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.SmcGrid.grid_specific_nml","title":"grid_specific_nml  <code>property</code>","text":"<pre><code>grid_specific_nml: Smc\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.SmcGrid.grid_specific_name","title":"grid_specific_name  <code>property</code>","text":"<pre><code>grid_specific_name: str\n</code></pre>"},{"location":"reference/grid/#rompy_ww3.grid.SmcGrid.additional_file_attrs","title":"additional_file_attrs  <code>property</code>","text":"<pre><code>additional_file_attrs: List[str]\n</code></pre> <p>Return list of additional file attributes specific to the grid type.</p>"},{"location":"reference/grid/#rompy_ww3.grid.SmcGrid.namelist_file_attrs","title":"namelist_file_attrs  <code>property</code>","text":"<pre><code>namelist_file_attrs: List[Tuple[str, str]]\n</code></pre> <p>Return empty list as SMC grids don't typically use optional namelist files.</p>"},{"location":"reference/grid/#union-type","title":"Union Type","text":""},{"location":"reference/grid/#usage-pattern","title":"Usage Pattern","text":"<p>The new clean architecture eliminates redundant interfaces and provides direct access to full WW3 namelist objects:</p> <pre><code>from rompy_ww3.grid import RectGrid\nfrom rompy_ww3.namelists.grid import Grid as GRID_NML, Rect\nfrom rompy_ww3.namelists.depth import Depth\n\n# Create namelist objects with full API access\ngrid_nml = GRID_NML(\n    name=\"Clean Implementation\",\n    nml=\"clean.nml\",\n    type=\"RECT\",\n    coord=\"SPHE\",\n    clos=\"SMPL\",\n    zlim=-0.2,\n    dmin=3.0,\n)\n\nrect_nml = Rect(\n    nx=300,\n    ny=150,\n    sx=0.1,\n    sy=0.1,\n    sf=1.5,\n    x0=180.0,\n    y0=20.0,\n    sf0=2.0,\n)\n\ndepth_nml = Depth(\n    filename=\"/path/to/depth.dat\",\n    sf=0.002,\n    idf=60,\n    idla=2,\n)\n\n# Pass actual namelist objects directly - NO REDUNDANT PARAMETERS!\ngrid = RectGrid(\n    grid_type=\"base\",\n    model_type=\"ww3_rect\",\n    grid_nml=grid_nml,    # Actual GRID_NML object\n    rect_nml=rect_nml,    # Actual Rect object\n    depth=depth_nml,     # Actual Depth object\n)\n\n# Generate namelist content directly\nnml_content = grid.grid_nml.render()  # Direct call to render()\n</code></pre>"},{"location":"reference/namelists/","title":"Namelists API Reference","text":"<p>This section documents the various namelist components available in rompy-ww3. All namelist classes include comprehensive documentation and validation for every parameter.</p>"},{"location":"reference/namelists/#domain-namelist","title":"Domain Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain","title":"Domain","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>DOMAIN_NML namelist for WW3.</p> <p>The DOMAIN_NML namelist defines top-level model parameters for WAVEWATCH III. This namelist is used by both single-grid (ww3_shel) and multi-grid (ww3_multi) programs.</p> <p>For single-grid implementation: - IOSTYP defines the output server mode for parallel implementation - START and STOP define the simulation time period</p> <p>For multi-grid implementation: - NRINP defines the number of grids for input fields - NRGRD defines the number of wave model grids - Various flags control output behavior in multi-grid runs</p> Source code in <code>rompy_ww3/namelists/domain.py</code> <pre><code>class Domain(NamelistBaseModel):\n    \"\"\"DOMAIN_NML namelist for WW3.\n\n    The DOMAIN_NML namelist defines top-level model parameters for WAVEWATCH III.\n    This namelist is used by both single-grid (ww3_shel) and multi-grid (ww3_multi) programs.\n\n    For single-grid implementation:\n    - IOSTYP defines the output server mode for parallel implementation\n    - START and STOP define the simulation time period\n\n    For multi-grid implementation:\n    - NRINP defines the number of grids for input fields\n    - NRGRD defines the number of wave model grids\n    - Various flags control output behavior in multi-grid runs\n    \"\"\"\n\n    # Single-grid parameters\n    start: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Start date for the entire model in format 'YYYYMMDD HHMMSS'. \"\n            \"This sets the starting time for the wave model simulation. \"\n            \"Example: '20100101 120000' for January 1, 2010 at 12:00:00 UTC.\"\n        )\n    )\n    stop: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Stop date for the entire model in format 'YYYYMMDD HHMMSS'. \"\n            \"This sets the ending time for the wave model simulation. \"\n            \"Example: '20101231 000000' for December 31, 2010 at 00:00:00 UTC.\"\n        )\n    )\n    iostyp: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Output server type defining how output is handled in parallel implementation:\\n\"\n            \"  0: No data server processes, direct access output from each process \"\n            \"(requires true parallel file system)\\n\"\n            \"  1: No data server process. All output for each type performed by process \"\n            \"that performs computations too\\n\"\n            \"  2: Last process is reserved for all output, and does no computing\\n\"\n            \"  3: Multiple dedicated output processes\"\n        ),\n        ge=0,\n        le=3\n    )\n\n    # Multi-grid parameters\n    nrinp: Optional[int] = Field(\n        default=None,\n        description=\"Number of grids defining input fields (for multi-grid runs).\",\n        ge=1\n    )\n    nrgrd: Optional[int] = Field(\n        default=None,\n        description=\"Number of wave model grids (for multi-grid runs).\",\n        ge=1\n    )\n    unipts: Optional[bool] = Field(\n        default=None,\n        description=\"Flag for using unified point output file (for multi-grid runs).\"\n    )\n    upproc: Optional[bool] = Field(\n        default=None,\n        description=\"Flag for dedicated process for unified point output (for multi-grid runs).\"\n    )\n    pshare: Optional[bool] = Field(\n        default=None,\n        description=\"Flag for grids sharing dedicated output processes (for multi-grid runs).\"\n    )\n    flghg1: Optional[bool] = Field(\n        default=None,\n        description=\"Flag for masking computation in two-way nesting (for multi-grid runs).\"\n    )\n    flghg2: Optional[bool] = Field(\n        default=None,\n        description=\"Flag for masking at printout time (for multi-grid runs).\"\n    )\n\n    @field_validator('start', 'stop')\n    @classmethod\n    def validate_date_fields(cls, v):\n        \"\"\"Validate date format for start and stop fields.\"\"\"\n        if v is not None:\n            return validate_date_format(v)\n        return v\n\n    @field_validator('iostyp')\n    @classmethod\n    def validate_iostyp_field(cls, v):\n        \"\"\"Validate IOSTYP field value.\"\"\"\n        if v is not None:\n            return validate_io_type(v)\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start: Optional[str] = Field(default=None, description=\"Start date for the entire model in format 'YYYYMMDD HHMMSS'. This sets the starting time for the wave model simulation. Example: '20100101 120000' for January 1, 2010 at 12:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.stop","title":"stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop: Optional[str] = Field(default=None, description=\"Stop date for the entire model in format 'YYYYMMDD HHMMSS'. This sets the ending time for the wave model simulation. Example: '20101231 000000' for December 31, 2010 at 00:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.iostyp","title":"iostyp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iostyp: Optional[int] = Field(default=None, description='Output server type defining how output is handled in parallel implementation:\\n  0: No data server processes, direct access output from each process (requires true parallel file system)\\n  1: No data server process. All output for each type performed by process that performs computations too\\n  2: Last process is reserved for all output, and does no computing\\n  3: Multiple dedicated output processes', ge=0, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.nrinp","title":"nrinp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nrinp: Optional[int] = Field(default=None, description='Number of grids defining input fields (for multi-grid runs).', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.nrgrd","title":"nrgrd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nrgrd: Optional[int] = Field(default=None, description='Number of wave model grids (for multi-grid runs).', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.unipts","title":"unipts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unipts: Optional[bool] = Field(default=None, description='Flag for using unified point output file (for multi-grid runs).')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.upproc","title":"upproc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upproc: Optional[bool] = Field(default=None, description='Flag for dedicated process for unified point output (for multi-grid runs).')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.pshare","title":"pshare  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pshare: Optional[bool] = Field(default=None, description='Flag for grids sharing dedicated output processes (for multi-grid runs).')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.flghg1","title":"flghg1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flghg1: Optional[bool] = Field(default=None, description='Flag for masking computation in two-way nesting (for multi-grid runs).')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.flghg2","title":"flghg2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flghg2: Optional[bool] = Field(default=None, description='Flag for masking at printout time (for multi-grid runs).')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.validate_date_fields","title":"validate_date_fields  <code>classmethod</code>","text":"<pre><code>validate_date_fields(v)\n</code></pre> <p>Validate date format for start and stop fields.</p> Source code in <code>rompy_ww3/namelists/domain.py</code> <pre><code>@field_validator('start', 'stop')\n@classmethod\ndef validate_date_fields(cls, v):\n    \"\"\"Validate date format for start and stop fields.\"\"\"\n    if v is not None:\n        return validate_date_format(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.domain.Domain.validate_iostyp_field","title":"validate_iostyp_field  <code>classmethod</code>","text":"<pre><code>validate_iostyp_field(v)\n</code></pre> <p>Validate IOSTYP field value.</p> Source code in <code>rompy_ww3/namelists/domain.py</code> <pre><code>@field_validator('iostyp')\n@classmethod\ndef validate_iostyp_field(cls, v):\n    \"\"\"Validate IOSTYP field value.\"\"\"\n    if v is not None:\n        return validate_io_type(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#input-namelist","title":"Input Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.input.Input","title":"Input","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>INPUT_NML namelist for WW3 (single-grid).</p> <p>The INPUT_NML namelist defines the forcing and data assimilation inputs for  single-grid WAVEWATCH III runs. This namelist is read by the ww3_shel program.</p> <p>The namelist contains: - FORCING: External forcing files for water levels, currents, winds, ice, etc. - ASSIM: Data assimilation flags for mean waves, 1D/2D spectra</p> Source code in <code>rompy_ww3/namelists/input.py</code> <pre><code>class Input(NamelistBaseModel):\n    \"\"\"INPUT_NML namelist for WW3 (single-grid).\n\n    The INPUT_NML namelist defines the forcing and data assimilation inputs for \n    single-grid WAVEWATCH III runs. This namelist is read by the ww3_shel program.\n\n    The namelist contains:\n    - FORCING: External forcing files for water levels, currents, winds, ice, etc.\n    - ASSIM: Data assimilation flags for mean waves, 1D/2D spectra\n    \"\"\"\n\n    forcing: Optional[InputForcing] = Field(\n        default=None, description=\"Forcing input parameters including water levels, currents, winds, ice, etc.\"\n    )\n    assim: Optional[InputAssim] = Field(\n        default=None, description=\"Data assimilation parameters for mean waves and 1D/2D spectra\"\n    )\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.input.Input-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.input.Input.forcing","title":"forcing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forcing: Optional[InputForcing] = Field(default=None, description='Forcing input parameters including water levels, currents, winds, ice, etc.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.input.Input.assim","title":"assim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>assim: Optional[InputAssim] = Field(default=None, description='Data assimilation parameters for mean waves and 1D/2D spectra')\n</code></pre>"},{"location":"reference/namelists/#output-type-namelist","title":"Output Type Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType","title":"OutputType","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>TYPE section of OUTPUT_TYPE_NML for WW3 (single-grid).</p> <p>The OUTPUT_TYPE_NML namelist defines the output types and parameters for  single-grid WAVEWATCH III runs. This namelist is read by the ww3_shel program.</p> <p>The namelist contains: - FIELD: Field output parameters specifying which parameters to output - POINT: Point output parameters defining specific point locations - TRACK: Track output format parameters - PARTITION: Partitioned output region parameters - COUPLING: Coupling exchange parameters for coupled models - RESTART: Restart output parameters</p> Source code in <code>rompy_ww3/namelists/output_type.py</code> <pre><code>class OutputType(NamelistBaseModel):\n    \"\"\"TYPE section of OUTPUT_TYPE_NML for WW3 (single-grid).\n\n    The OUTPUT_TYPE_NML namelist defines the output types and parameters for \n    single-grid WAVEWATCH III runs. This namelist is read by the ww3_shel program.\n\n    The namelist contains:\n    - FIELD: Field output parameters specifying which parameters to output\n    - POINT: Point output parameters defining specific point locations\n    - TRACK: Track output format parameters\n    - PARTITION: Partitioned output region parameters\n    - COUPLING: Coupling exchange parameters for coupled models\n    - RESTART: Restart output parameters\n    \"\"\"\n\n    field: Optional[OutputTypeField] = Field(\n        default=None, description=\"Field output parameters specifying which wave model parameters to output\"\n    )\n    point: Optional[OutputTypePoint] = Field(\n        default=None, description=\"Point output parameters defining specific point locations for output\"\n    )\n    track: Optional[OutputTypeTrack] = Field(\n        default=None, description=\"Track output format parameters (formatted/unformatted)\"\n    )\n    partition: Optional[OutputTypePartition] = Field(\n        default=None, description=\"Partitioned output region parameters defining sub-regions for output\"\n    )\n    coupling: Optional[OutputTypeCoupling] = Field(\n        default=None, description=\"Coupling exchange parameters for coupled model interactions\"\n    )\n    restart: Optional[OutputTypeRestart] = Field(\n        default=None, description=\"Restart output parameters specifying additional fields for restart files\"\n    )\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType.field","title":"field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field: Optional[OutputTypeField] = Field(default=None, description='Field output parameters specifying which wave model parameters to output')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType.point","title":"point  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point: Optional[OutputTypePoint] = Field(default=None, description='Point output parameters defining specific point locations for output')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType.track","title":"track  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>track: Optional[OutputTypeTrack] = Field(default=None, description='Track output format parameters (formatted/unformatted)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType.partition","title":"partition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partition: Optional[OutputTypePartition] = Field(default=None, description='Partitioned output region parameters defining sub-regions for output')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType.coupling","title":"coupling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coupling: Optional[OutputTypeCoupling] = Field(default=None, description='Coupling exchange parameters for coupled model interactions')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_type.OutputType.restart","title":"restart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>restart: Optional[OutputTypeRestart] = Field(default=None, description='Restart output parameters specifying additional fields for restart files')\n</code></pre>"},{"location":"reference/namelists/#output-date-namelist","title":"Output Date Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate","title":"OutputDate","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>DATE section of OUTPUT_DATE_NML for WW3 (single-grid).</p> <p>The OUTPUT_DATE_NML namelist defines the output timing parameters for  single-grid WAVEWATCH III runs. This namelist is read by the ww3_shel program.</p> <p>The namelist contains sections for: - FIELD: Field output timing (start, stride, stop times) - POINT: Point output timing (start, stride, stop times) - TRACK: Track output timing (start, stride, stop times) - RESTART: Restart output timing (start, stride, stop times) - BOUNDARY: Boundary output timing (start, stride, stop times) - PARTITION: Partition output timing (start, stride, stop times) - COUPLING: Coupling output timing (start, stride, stop times)</p> <p>Timing parameters follow the format: - Start/Stop times in 'YYYYMMDD HHMMSS' format - Stride in seconds as a string (e.g., '3600' for 1 hour) - Setting stride to '0' disables that output type</p> Source code in <code>rompy_ww3/namelists/output_date.py</code> <pre><code>class OutputDate(NamelistBaseModel):\n    \"\"\"DATE section of OUTPUT_DATE_NML for WW3 (single-grid).\n\n    The OUTPUT_DATE_NML namelist defines the output timing parameters for \n    single-grid WAVEWATCH III runs. This namelist is read by the ww3_shel program.\n\n    The namelist contains sections for:\n    - FIELD: Field output timing (start, stride, stop times)\n    - POINT: Point output timing (start, stride, stop times)\n    - TRACK: Track output timing (start, stride, stop times)\n    - RESTART: Restart output timing (start, stride, stop times)\n    - BOUNDARY: Boundary output timing (start, stride, stop times)\n    - PARTITION: Partition output timing (start, stride, stop times)\n    - COUPLING: Coupling output timing (start, stride, stop times)\n\n    Timing parameters follow the format:\n    - Start/Stop times in 'YYYYMMDD HHMMSS' format\n    - Stride in seconds as a string (e.g., '3600' for 1 hour)\n    - Setting stride to '0' disables that output type\n    \"\"\"\n\n    field: Optional[OutputDateField] = Field(\n        default=None, \n        description=\"Field output date parameters defining when and how frequently field output is written\"\n    )\n    point: Optional[OutputDatePoint] = Field(\n        default=None, \n        description=\"Point output date parameters defining when and how frequently point output is written\"\n    )\n    track: Optional[OutputDateTrack] = Field(\n        default=None, \n        description=\"Track output date parameters defining when and how frequently track output is written\"\n    )\n    restart: Optional[OutputDateRestart] = Field(\n        default=None, \n        description=\"Restart output date parameters defining when and how frequently restart output is written\"\n    )\n    boundary: Optional[OutputDateBoundary] = Field(\n        default=None, \n        description=\"Boundary output date parameters defining when and how frequently boundary output is written\"\n    )\n    partition: Optional[OutputDatePartition] = Field(\n        default=None, \n        description=\"Partition output date parameters defining when and how frequently partition output is written\"\n    )\n    coupling: Optional[OutputDateCoupling] = Field(\n        default=None, \n        description=\"Coupling output date parameters defining when and how frequently coupling output is written\"\n    )\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate.field","title":"field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field: Optional[OutputDateField] = Field(default=None, description='Field output date parameters defining when and how frequently field output is written')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate.point","title":"point  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point: Optional[OutputDatePoint] = Field(default=None, description='Point output date parameters defining when and how frequently point output is written')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate.track","title":"track  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>track: Optional[OutputDateTrack] = Field(default=None, description='Track output date parameters defining when and how frequently track output is written')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate.restart","title":"restart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>restart: Optional[OutputDateRestart] = Field(default=None, description='Restart output date parameters defining when and how frequently restart output is written')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate.boundary","title":"boundary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>boundary: Optional[OutputDateBoundary] = Field(default=None, description='Boundary output date parameters defining when and how frequently boundary output is written')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate.partition","title":"partition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partition: Optional[OutputDatePartition] = Field(default=None, description='Partition output date parameters defining when and how frequently partition output is written')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.output_date.OutputDate.coupling","title":"coupling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coupling: Optional[OutputDateCoupling] = Field(default=None, description='Coupling output date parameters defining when and how frequently coupling output is written')\n</code></pre>"},{"location":"reference/namelists/#spectrum-namelist","title":"Spectrum Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum","title":"Spectrum","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>SPECTRUM_NML namelist for WW3.</p> <p>The SPECTRUM_NML namelist defines the spectral parameterization for WAVEWATCH III. This namelist specifies the frequency and direction discretization of the wave spectrum.</p> <p>The wave spectrum is discretized in frequency and direction. The frequency space is typically logarithmically spaced, while the direction space is evenly spaced.</p> Source code in <code>rompy_ww3/namelists/spectrum.py</code> <pre><code>class Spectrum(NamelistBaseModel):\n    \"\"\"SPECTRUM_NML namelist for WW3.\n\n    The SPECTRUM_NML namelist defines the spectral parameterization for WAVEWATCH III.\n    This namelist specifies the frequency and direction discretization of the wave spectrum.\n\n    The wave spectrum is discretized in frequency and direction. The frequency space\n    is typically logarithmically spaced, while the direction space is evenly spaced.\n    \"\"\"\n\n    xfr: Optional[float] = Field(\n        default=1.1,\n        description=(\n            \"Frequency increment factor, defines the logarithmic spacing of frequency bins. \"\n            \"The frequency spacing follows: f(i) = freq1 * xfr^(i-1) for i=1,...,nk. \"\n            \"Typical values range from about 1.05 to 1.2, representing 5% to 20% frequency increments.\"\n        ),\n        gt=1.0  # Must be greater than 1 for logarithmic spacing\n    )\n    freq1: Optional[float] = Field(\n        default=0.035714,\n        description=(\n            \"First frequency in the spectrum (Hz). This is the lowest frequency in the wave spectrum. \"\n            \"Typical values for ocean applications range from 0.03 Hz (about 33s period) to 0.5 Hz (2s period).\"\n        ),\n        gt=0.0  # Must be positive\n    )\n    nk: Optional[int] = Field(\n        default=25,\n        description=\"Number of frequency bins in the spectrum. This defines spectral resolution in frequency space.\",\n        ge=2,  # Must have at least 2 frequencies for a spectrum\n        le=100  # Reasonable upper limit\n    )\n    nth: Optional[int] = Field(\n        default=25,\n        description=\"Number of direction bins in the spectrum. This defines spectral resolution in direction space.\",\n        ge=2,  # Must have at least 2 directions for directional spectrum\n        le=720  # Reasonable upper limit\n    )\n    thoff: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Relative offset of first direction [-0.5, 0.5], as a fraction of the direction bin size. \"\n            \"This parameter shifts the directional grid. A value of 0 means no offset. \"\n            \"Values of -0.5 or 0.5 create a grid offset by half a bin width.\"\n        ),\n        ge=-0.5,  # Lower bound\n        le=0.5  # Upper bound\n    )\n\n    @field_validator('xfr')\n    @classmethod\n    def validate_xfr(cls, v):\n        \"\"\"Validate frequency increment factor.\"\"\"\n        if v is not None:\n            if v &lt;= 1.0:\n                raise ValueError(f\"Frequency increment factor (xfr) must be &gt; 1.0, got {v}\")\n            if v &gt; 2.0:  # Reasonable upper limit\n                raise ValueError(f\"Frequency increment factor (xfr) seems too high: {v}\")\n        return v\n\n    @field_validator('freq1')\n    @classmethod\n    def validate_freq1(cls, v):\n        \"\"\"Validate first frequency.\"\"\"\n        if v is not None:\n            if v &lt;= 0.0:\n                raise ValueError(f\"First frequency (freq1) must be positive, got {v}\")\n            if v &gt; 1.0:  # Frequencies &gt; 1 Hz are extremely high for ocean waves\n                raise ValueError(f\"First frequency (freq1) seems too high: {v}\")\n        return v\n\n    @field_validator('nk')\n    @classmethod\n    def validate_nk(cls, v):\n        \"\"\"Validate number of frequency bins.\"\"\"\n        if v is not None:\n            if v &lt; 2:\n                raise ValueError(f\"Number of frequency bins (nk) must be at least 2, got {v}\")\n        return v\n\n    @field_validator('nth')\n    @classmethod\n    def validate_nth(cls, v):\n        \"\"\"Validate number of direction bins.\"\"\"\n        if v is not None:\n            if v &lt; 2:\n                raise ValueError(f\"Number of direction bins (nth) must be at least 2, got {v}\")\n        return v\n\n    @field_validator('thoff')\n    @classmethod\n    def validate_thoff(cls, v):\n        \"\"\"Validate direction offset.\"\"\"\n        if v is not None:\n            if v &lt; -0.5 or v &gt; 0.5:\n                raise ValueError(f\"Direction offset (thoff) must be between -0.5 and 0.5, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.xfr","title":"xfr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xfr: Optional[float] = Field(default=1.1, description='Frequency increment factor, defines the logarithmic spacing of frequency bins. The frequency spacing follows: f(i) = freq1 * xfr^(i-1) for i=1,...,nk. Typical values range from about 1.05 to 1.2, representing 5% to 20% frequency increments.', gt=1.0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.freq1","title":"freq1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>freq1: Optional[float] = Field(default=0.035714, description='First frequency in the spectrum (Hz). This is the lowest frequency in the wave spectrum. Typical values for ocean applications range from 0.03 Hz (about 33s period) to 0.5 Hz (2s period).', gt=0.0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.nk","title":"nk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nk: Optional[int] = Field(default=25, description='Number of frequency bins in the spectrum. This defines spectral resolution in frequency space.', ge=2, le=100)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.nth","title":"nth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nth: Optional[int] = Field(default=25, description='Number of direction bins in the spectrum. This defines spectral resolution in direction space.', ge=2, le=720)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.thoff","title":"thoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>thoff: Optional[float] = Field(default=None, description='Relative offset of first direction [-0.5, 0.5], as a fraction of the direction bin size. This parameter shifts the directional grid. A value of 0 means no offset. Values of -0.5 or 0.5 create a grid offset by half a bin width.', ge=-0.5, le=0.5)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.validate_xfr","title":"validate_xfr  <code>classmethod</code>","text":"<pre><code>validate_xfr(v)\n</code></pre> <p>Validate frequency increment factor.</p> Source code in <code>rompy_ww3/namelists/spectrum.py</code> <pre><code>@field_validator('xfr')\n@classmethod\ndef validate_xfr(cls, v):\n    \"\"\"Validate frequency increment factor.\"\"\"\n    if v is not None:\n        if v &lt;= 1.0:\n            raise ValueError(f\"Frequency increment factor (xfr) must be &gt; 1.0, got {v}\")\n        if v &gt; 2.0:  # Reasonable upper limit\n            raise ValueError(f\"Frequency increment factor (xfr) seems too high: {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.validate_freq1","title":"validate_freq1  <code>classmethod</code>","text":"<pre><code>validate_freq1(v)\n</code></pre> <p>Validate first frequency.</p> Source code in <code>rompy_ww3/namelists/spectrum.py</code> <pre><code>@field_validator('freq1')\n@classmethod\ndef validate_freq1(cls, v):\n    \"\"\"Validate first frequency.\"\"\"\n    if v is not None:\n        if v &lt;= 0.0:\n            raise ValueError(f\"First frequency (freq1) must be positive, got {v}\")\n        if v &gt; 1.0:  # Frequencies &gt; 1 Hz are extremely high for ocean waves\n            raise ValueError(f\"First frequency (freq1) seems too high: {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.validate_nk","title":"validate_nk  <code>classmethod</code>","text":"<pre><code>validate_nk(v)\n</code></pre> <p>Validate number of frequency bins.</p> Source code in <code>rompy_ww3/namelists/spectrum.py</code> <pre><code>@field_validator('nk')\n@classmethod\ndef validate_nk(cls, v):\n    \"\"\"Validate number of frequency bins.\"\"\"\n    if v is not None:\n        if v &lt; 2:\n            raise ValueError(f\"Number of frequency bins (nk) must be at least 2, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.validate_nth","title":"validate_nth  <code>classmethod</code>","text":"<pre><code>validate_nth(v)\n</code></pre> <p>Validate number of direction bins.</p> Source code in <code>rompy_ww3/namelists/spectrum.py</code> <pre><code>@field_validator('nth')\n@classmethod\ndef validate_nth(cls, v):\n    \"\"\"Validate number of direction bins.\"\"\"\n    if v is not None:\n        if v &lt; 2:\n            raise ValueError(f\"Number of direction bins (nth) must be at least 2, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectrum.Spectrum.validate_thoff","title":"validate_thoff  <code>classmethod</code>","text":"<pre><code>validate_thoff(v)\n</code></pre> <p>Validate direction offset.</p> Source code in <code>rompy_ww3/namelists/spectrum.py</code> <pre><code>@field_validator('thoff')\n@classmethod\ndef validate_thoff(cls, v):\n    \"\"\"Validate direction offset.\"\"\"\n    if v is not None:\n        if v &lt; -0.5 or v &gt; 0.5:\n            raise ValueError(f\"Direction offset (thoff) must be between -0.5 and 0.5, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#run-namelist","title":"Run Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run","title":"Run","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>RUN_NML namelist for WW3.</p> <p>The RUN_NML namelist defines the run parameterization for WAVEWATCH III. This namelist controls which physical processes are active during the simulation. Each flag enables or disables a specific component of the wave model physics.</p> Source code in <code>rompy_ww3/namelists/run.py</code> <pre><code>class Run(NamelistBaseModel):\n    \"\"\"RUN_NML namelist for WW3.\n\n    The RUN_NML namelist defines the run parameterization for WAVEWATCH III.\n    This namelist controls which physical processes are active during the simulation.\n    Each flag enables or disables a specific component of the wave model physics.\n    \"\"\"\n\n    fldry: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Dry run flag. If true, performs I/O operations only without calculations. \"\n            \"This is useful for testing file operations and namelist parsing without \"\n            \"executing the full model simulation. When enabled, the model will go through \"\n            \"the motions of reading and writing files but will not perform wave calculations.\"\n        )\n    )\n    flcx: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"X-component of propagation flag. If true, enables propagation in the X direction. \"\n            \"This controls the spatial advection of wave energy in the X (typically longitudinal) \"\n            \"direction. Disabling this would prevent wave energy from moving in the X direction.\"\n        )\n    )\n    flcy: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Y-component of propagation flag. If true, enables propagation in the Y direction. \"\n            \"This controls the spatial advection of wave energy in the Y (typically latitudinal) \"\n            \"direction. Disabling this would prevent wave energy from moving in the Y direction.\"\n        )\n    )\n    flcth: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Direction shift flag. If true, enables directional shifting of the wave spectrum. \"\n            \"This controls the propagation of wave energy in directional space (theta-advection). \"\n            \"This process accounts for changes in wave direction due to refraction, current effects, etc.\"\n        )\n    )\n    flck: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Wavenumber shift flag. If true, enables wavenumber shifting of the wave spectrum. \"\n            \"This controls the propagation of wave energy in wavenumber space (k-advection). \"\n            \"This process accounts for changes in wave frequency due to current and depth variations.\"\n        )\n    )\n    flsou: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Source terms flag. If true, enables source terms (wind input, nonlinear wave-wave \"\n            \"interactions, and dissipation). This controls the energy input and output processes \"\n            \"that affect the wave spectrum. Disabling this would result in wave energy being \"\n            \"only advected without any gain or loss of energy.\"\n        )\n    )\n\n    @field_validator('fldry', 'flcx', 'flcy', 'flcth', 'flck', 'flsou')\n    @classmethod\n    def validate_boolean_flags(cls, v):\n        \"\"\"Validate that all flags are boolean values.\"\"\"\n        if v is not None and not isinstance(v, bool):\n            raise ValueError(f\"Flag must be a boolean value, got {type(v)}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run.fldry","title":"fldry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fldry: Optional[bool] = Field(default=None, description='Dry run flag. If true, performs I/O operations only without calculations. This is useful for testing file operations and namelist parsing without executing the full model simulation. When enabled, the model will go through the motions of reading and writing files but will not perform wave calculations.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run.flcx","title":"flcx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flcx: Optional[bool] = Field(default=None, description='X-component of propagation flag. If true, enables propagation in the X direction. This controls the spatial advection of wave energy in the X (typically longitudinal) direction. Disabling this would prevent wave energy from moving in the X direction.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run.flcy","title":"flcy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flcy: Optional[bool] = Field(default=None, description='Y-component of propagation flag. If true, enables propagation in the Y direction. This controls the spatial advection of wave energy in the Y (typically latitudinal) direction. Disabling this would prevent wave energy from moving in the Y direction.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run.flcth","title":"flcth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flcth: Optional[bool] = Field(default=None, description='Direction shift flag. If true, enables directional shifting of the wave spectrum. This controls the propagation of wave energy in directional space (theta-advection). This process accounts for changes in wave direction due to refraction, current effects, etc.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run.flck","title":"flck  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flck: Optional[bool] = Field(default=None, description='Wavenumber shift flag. If true, enables wavenumber shifting of the wave spectrum. This controls the propagation of wave energy in wavenumber space (k-advection). This process accounts for changes in wave frequency due to current and depth variations.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run.flsou","title":"flsou  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flsou: Optional[bool] = Field(default=None, description='Source terms flag. If true, enables source terms (wind input, nonlinear wave-wave interactions, and dissipation). This controls the energy input and output processes that affect the wave spectrum. Disabling this would result in wave energy being only advected without any gain or loss of energy.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.run.Run.validate_boolean_flags","title":"validate_boolean_flags  <code>classmethod</code>","text":"<pre><code>validate_boolean_flags(v)\n</code></pre> <p>Validate that all flags are boolean values.</p> Source code in <code>rompy_ww3/namelists/run.py</code> <pre><code>@field_validator('fldry', 'flcx', 'flcy', 'flcth', 'flck', 'flsou')\n@classmethod\ndef validate_boolean_flags(cls, v):\n    \"\"\"Validate that all flags are boolean values.\"\"\"\n    if v is not None and not isinstance(v, bool):\n        raise ValueError(f\"Flag must be a boolean value, got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#timeteps-namelist","title":"Timeteps Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps","title":"Timesteps","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>TIMESTEPS_NML namelist for WW3.</p> <p>The TIMESTEPS_NML namelist defines the timestep parameterization for WAVEWATCH III. Proper timestep selection is critical for model stability and accuracy.</p> <p>The timesteps should be set up as multiples of each other for best results. The time step relationships recommended by WW3 documentation are: - DTXY is the maximum CFL time step for x-y propagation - DTMAX is the maximum global time step (typically \u2248 3 \u00d7 DTXY) - DTKTH is the maximum CFL time step for k-theta propagation (typically DTMAX/2 to DTMAX/10) - DTMIN is the minimum source term time step (typically between 5-60 seconds)</p> Source code in <code>rompy_ww3/namelists/timesteps.py</code> <pre><code>class Timesteps(NamelistBaseModel):\n    \"\"\"TIMESTEPS_NML namelist for WW3.\n\n    The TIMESTEPS_NML namelist defines the timestep parameterization for WAVEWATCH III.\n    Proper timestep selection is critical for model stability and accuracy.\n\n    The timesteps should be set up as multiples of each other for best results.\n    The time step relationships recommended by WW3 documentation are:\n    - DTXY is the maximum CFL time step for x-y propagation\n    - DTMAX is the maximum global time step (typically \u2248 3 \u00d7 DTXY)\n    - DTKTH is the maximum CFL time step for k-theta propagation (typically DTMAX/2 to DTMAX/10)\n    - DTMIN is the minimum source term time step (typically between 5-60 seconds)\n    \"\"\"\n\n    dtmax: Optional[float] = Field(\n        ...,\n        description=(\n            \"Maximum global time step (seconds). This is the largest time step allowed \"\n            \"in the model, typically about 3 times the DTXY step to satisfy CFL criteria. \"\n            \"The formula for the CFL time step depends on the lowest frequency (FREQ1) \"\n            \"and the lowest spatial grid resolution (DXY): Tcfl = DXY / (G / (FREQ1*4*Pi)) \"\n            \"where G=9.8m/s\u00b2. DTMAX is typically around 3 \u00d7 DTXY.\"\n        ),\n        gt=0  # Must be positive\n    )\n    dtxy: Optional[float] = Field(\n        ...,\n        description=(\n            \"Maximum CFL time step for x-y propagation (seconds). This time step controls \"\n            \"the spatial advection of wave energy in geographical space. It should be set \"\n            \"based on the CFL condition and is typically about 90% of the theoretical CFL \"\n            \"limit: DTXY \u2248 0.9 * DXY / (G / (FREQ1*4*Pi)) where G=9.8m/s\u00b2.\"\n        ),\n        gt=0  # Must be positive\n    )\n    dtkth: Optional[float] = Field(\n        ...,\n        description=(\n            \"Maximum CFL time step for k-theta propagation (seconds). This time step controls \"\n            \"the propagation of wave energy in spectral space (wavenumber and direction). \"\n            \"The value depends on current velocities: for no/light currents, DTKTH \u2248 DTMAX/2, \"\n            \"while for strong currents, DTKTH \u2248 DTMAX/10.\"\n        ),\n        gt=0  # Must be positive\n    )\n    dtmin: Optional[float] = Field(\n        default=10,\n        description=(\n            \"Minimum source term time step (seconds). This controls the time step for \"\n            \"source term calculations (wind input, nonlinear interactions, dissipation). \"\n            \"Typical values range between 5 and 60 seconds, with 10 seconds being common.\"\n        ),\n        ge=0.1,  # Reasonable minimum\n        le=3600  # Reasonable maximum (1 hour)\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_timesteps(self) -&gt; \"Timesteps\":\n        \"\"\"Validate timestep relationships and ranges.\"\"\"\n        # dtmax \u2248 3 \u00d7 dtxy (\u00b110%)\n        if self.dtmax is not None and self.dtxy is not None:\n            expected_dtmax = 3 * self.dtxy\n            if not (0.9 * expected_dtmax &lt;= self.dtmax &lt;= 1.1 * expected_dtmax):\n                raise ValueError(\n                    f\"dtmax ({self.dtmax}) should be about 3 \u00d7 dtxy ({self.dtxy})\"\n                )\n\n        # dtkth \u2248 dtmax/2 or dtmax/10 (\u00b110%)\n        if self.dtkth is not None and self.dtmax is not None:\n            dtkth_half = self.dtmax / 2\n            dtkth_tenth = self.dtmax / 10\n            if not (dtkth_tenth &lt;= self.dtkth &lt;= dtkth_half):\n                raise ValueError(\n                    f\"dtkth ({self.dtkth}) should be between  dtmax/10 ({dtkth_tenth}) and dtmax/2 ({dtkth_half})\"\n                )\n\n        # dtmin between 5 and 60\n        if self.dtmin is not None:\n            if not (5 &lt;= self.dtmin &lt;= 60):\n                raise ValueError(\n                    f\"dtmin ({self.dtmin}) should be between 5 and 60 seconds\"\n                )\n\n        return self\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps.dtmax","title":"dtmax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dtmax: Optional[float] = Field(..., description='Maximum global time step (seconds). This is the largest time step allowed in the model, typically about 3 times the DTXY step to satisfy CFL criteria. The formula for the CFL time step depends on the lowest frequency (FREQ1) and the lowest spatial grid resolution (DXY): Tcfl = DXY / (G / (FREQ1*4*Pi)) where G=9.8m/s\u00b2. DTMAX is typically around 3 \u00d7 DTXY.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps.dtxy","title":"dtxy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dtxy: Optional[float] = Field(..., description='Maximum CFL time step for x-y propagation (seconds). This time step controls the spatial advection of wave energy in geographical space. It should be set based on the CFL condition and is typically about 90% of the theoretical CFL limit: DTXY \u2248 0.9 * DXY / (G / (FREQ1*4*Pi)) where G=9.8m/s\u00b2.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps.dtkth","title":"dtkth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dtkth: Optional[float] = Field(..., description='Maximum CFL time step for k-theta propagation (seconds). This time step controls the propagation of wave energy in spectral space (wavenumber and direction). The value depends on current velocities: for no/light currents, DTKTH \u2248 DTMAX/2, while for strong currents, DTKTH \u2248 DTMAX/10.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps.dtmin","title":"dtmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dtmin: Optional[float] = Field(default=10, description='Minimum source term time step (seconds). This controls the time step for source term calculations (wind input, nonlinear interactions, dissipation). Typical values range between 5 and 60 seconds, with 10 seconds being common.', ge=0.1, le=3600)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.timesteps.Timesteps.validate_timesteps","title":"validate_timesteps","text":"<pre><code>validate_timesteps() -&gt; Timesteps\n</code></pre> <p>Validate timestep relationships and ranges.</p> Source code in <code>rompy_ww3/namelists/timesteps.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_timesteps(self) -&gt; \"Timesteps\":\n    \"\"\"Validate timestep relationships and ranges.\"\"\"\n    # dtmax \u2248 3 \u00d7 dtxy (\u00b110%)\n    if self.dtmax is not None and self.dtxy is not None:\n        expected_dtmax = 3 * self.dtxy\n        if not (0.9 * expected_dtmax &lt;= self.dtmax &lt;= 1.1 * expected_dtmax):\n            raise ValueError(\n                f\"dtmax ({self.dtmax}) should be about 3 \u00d7 dtxy ({self.dtxy})\"\n            )\n\n    # dtkth \u2248 dtmax/2 or dtmax/10 (\u00b110%)\n    if self.dtkth is not None and self.dtmax is not None:\n        dtkth_half = self.dtmax / 2\n        dtkth_tenth = self.dtmax / 10\n        if not (dtkth_tenth &lt;= self.dtkth &lt;= dtkth_half):\n            raise ValueError(\n                f\"dtkth ({self.dtkth}) should be between  dtmax/10 ({dtkth_tenth}) and dtmax/2 ({dtkth_half})\"\n            )\n\n    # dtmin between 5 and 60\n    if self.dtmin is not None:\n        if not (5 &lt;= self.dtmin &lt;= 60):\n            raise ValueError(\n                f\"dtmin ({self.dtmin}) should be between 5 and 60 seconds\"\n            )\n\n    return self\n</code></pre>"},{"location":"reference/namelists/#grid-namelist","title":"Grid Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid","title":"Grid","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>GRID_NML namelist for WW3.</p> <p>The GRID_NML namelist defines the grid to preprocess for WAVEWATCH III. This namelist sets up the basic characteristics of the computational grid.</p> <p>The WW3 model supports several grid types and coordinate systems, with options for grid closure to handle special cases like tripole grids.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>class Grid(NamelistBaseModel):\n    \"\"\"GRID_NML namelist for WW3.\n\n    The GRID_NML namelist defines the grid to preprocess for WAVEWATCH III.\n    This namelist sets up the basic characteristics of the computational grid.\n\n    The WW3 model supports several grid types and coordinate systems, with options\n    for grid closure to handle special cases like tripole grids.\n    \"\"\"\n\n    name: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Grid name for identification, used for naming and referencing this grid \"\n            \"in model output and processing. Should be descriptive and unique.\"\n        )\n    )\n    nml: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Namelist file name that contains additional grid-dependent parameters. \"\n            \"This points to another namelist file that may contain grid-specific settings \"\n            \"beyond those defined in this namelist.\"\n        )\n    )\n    type: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Grid type defining the grid geometry:\\n\"\n            \"  'RECT': Rectilinear grid with constant x,y spacing\\n\"\n            \"  'CURV': Curvilinear grid with variable spacing\\n\"\n            \"  'UNST': Unstructured grid (triangle-based)\\n\"\n            \"  'SMC': Spherical Multiple-Cell grid\"\n        )\n    )\n    coord: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Coordinate system for the grid:\\n\"\n            \"  'SPHE': Spherical coordinates (degrees)\\n\"\n            \"  'CART': Cartesian coordinates (meters)\\n\"\n            \"Note: Grid closure can only be applied in spherical coordinates.\"\n        )\n    )\n    clos: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Grid closure type for handling domain boundaries:\\n\"\n            \"  'NONE': No closure applied (standard boundaries)\\n\"\n            \"  'SMPL': Simple grid closure - grid is periodic in i-index and wraps at i=NX+1.\\n\"\n            \"          In other words, (NX+1,J) =&gt; (1,J). Works with RECT and CURV grids.\\n\"\n            \"  'TRPL': Tripole grid closure - grid is periodic in i-index and has closure at j=NY+1.\\n\"\n            \"          (NX+1,J&lt;=NY) =&gt; (1,J) and (I,NY+1) =&gt; (NX-I+1,NY). Works with CURV grids only.\\n\"\n            \"          NX must be even for tripole closure.\"\n        )\n    )\n    zlim: Optional[float] = Field(\n        default=-0.1,\n        description=(\n            \"Coastline limit depth (meters) in negative values below mean sea level. \"\n            \"This value distinguishes sea points from land points. All points with depth \"\n            \"values (ZBIN) greater than this limit (ZLIM) will be considered as excluded \"\n            \"points and will never be wet points, even if water level rises above. \"\n            \"It can only overwrite the status of a sea point to a land point. \"\n            \"The value must be negative (below mean sea level).\"\n        ),\n        le=0  # Must be less than or equal to 0 (below sea level)\n    )\n    dmin: Optional[float] = Field(\n        default=2.5,\n        description=(\n            \"Absolute minimum depth allowed for wave propagation (meters). \"\n            \"This is the depth value used in the model if input depth is lower, \"\n            \"to prevent model instability. Values below this will be set to DMIN \"\n            \"to avoid model blow-up in very shallow areas.\"\n        ),\n        gt=0  # Must be positive\n    )\n\n    @field_validator('type')\n    @classmethod\n    def validate_grid_type_field(cls, v):\n        \"\"\"Validate grid type field.\"\"\"\n        if v is not None:\n            return validate_grid_type(v)\n        return v\n\n    @field_validator('coord')\n    @classmethod\n    def validate_coord_type_field(cls, v):\n        \"\"\"Validate coordinate type field.\"\"\"\n        if v is not None:\n            return validate_coord_type(v)\n        return v\n\n    @field_validator('clos')\n    @classmethod\n    def validate_clos_type_field(cls, v):\n        \"\"\"Validate grid closure type field.\"\"\"\n        if v is not None:\n            return validate_clos_type(v)\n        return v\n\n    @field_validator('zlim')\n    @classmethod\n    def validate_zlim(cls, v):\n        \"\"\"Validate coastline limit depth.\"\"\"\n        if v is not None:\n            if v &gt; 0:\n                raise ValueError(f\"Coastline limit depth (zlim) must be &lt;= 0 (below sea level), got {v}\")\n        return v\n\n    @field_validator('dmin')\n    @classmethod\n    def validate_dmin(cls, v):\n        \"\"\"Validate minimum depth for wave propagation.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"Minimum depth (dmin) must be positive, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(default=None, description='Grid name for identification, used for naming and referencing this grid in model output and processing. Should be descriptive and unique.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.nml","title":"nml  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nml: Optional[str] = Field(default=None, description='Namelist file name that contains additional grid-dependent parameters. This points to another namelist file that may contain grid-specific settings beyond those defined in this namelist.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Optional[str] = Field(default=None, description=\"Grid type defining the grid geometry:\\n  'RECT': Rectilinear grid with constant x,y spacing\\n  'CURV': Curvilinear grid with variable spacing\\n  'UNST': Unstructured grid (triangle-based)\\n  'SMC': Spherical Multiple-Cell grid\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.coord","title":"coord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>coord: Optional[str] = Field(default=None, description=\"Coordinate system for the grid:\\n  'SPHE': Spherical coordinates (degrees)\\n  'CART': Cartesian coordinates (meters)\\nNote: Grid closure can only be applied in spherical coordinates.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.clos","title":"clos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clos: Optional[str] = Field(default=None, description=\"Grid closure type for handling domain boundaries:\\n  'NONE': No closure applied (standard boundaries)\\n  'SMPL': Simple grid closure - grid is periodic in i-index and wraps at i=NX+1.\\n          In other words, (NX+1,J) =&gt; (1,J). Works with RECT and CURV grids.\\n  'TRPL': Tripole grid closure - grid is periodic in i-index and has closure at j=NY+1.\\n          (NX+1,J&lt;=NY) =&gt; (1,J) and (I,NY+1) =&gt; (NX-I+1,NY). Works with CURV grids only.\\n          NX must be even for tripole closure.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.zlim","title":"zlim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zlim: Optional[float] = Field(default=-0.1, description='Coastline limit depth (meters) in negative values below mean sea level. This value distinguishes sea points from land points. All points with depth values (ZBIN) greater than this limit (ZLIM) will be considered as excluded points and will never be wet points, even if water level rises above. It can only overwrite the status of a sea point to a land point. The value must be negative (below mean sea level).', le=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.dmin","title":"dmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dmin: Optional[float] = Field(default=2.5, description='Absolute minimum depth allowed for wave propagation (meters). This is the depth value used in the model if input depth is lower, to prevent model instability. Values below this will be set to DMIN to avoid model blow-up in very shallow areas.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.validate_grid_type_field","title":"validate_grid_type_field  <code>classmethod</code>","text":"<pre><code>validate_grid_type_field(v)\n</code></pre> <p>Validate grid type field.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>@field_validator('type')\n@classmethod\ndef validate_grid_type_field(cls, v):\n    \"\"\"Validate grid type field.\"\"\"\n    if v is not None:\n        return validate_grid_type(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.validate_coord_type_field","title":"validate_coord_type_field  <code>classmethod</code>","text":"<pre><code>validate_coord_type_field(v)\n</code></pre> <p>Validate coordinate type field.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>@field_validator('coord')\n@classmethod\ndef validate_coord_type_field(cls, v):\n    \"\"\"Validate coordinate type field.\"\"\"\n    if v is not None:\n        return validate_coord_type(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.validate_clos_type_field","title":"validate_clos_type_field  <code>classmethod</code>","text":"<pre><code>validate_clos_type_field(v)\n</code></pre> <p>Validate grid closure type field.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>@field_validator('clos')\n@classmethod\ndef validate_clos_type_field(cls, v):\n    \"\"\"Validate grid closure type field.\"\"\"\n    if v is not None:\n        return validate_clos_type(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.validate_zlim","title":"validate_zlim  <code>classmethod</code>","text":"<pre><code>validate_zlim(v)\n</code></pre> <p>Validate coastline limit depth.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>@field_validator('zlim')\n@classmethod\ndef validate_zlim(cls, v):\n    \"\"\"Validate coastline limit depth.\"\"\"\n    if v is not None:\n        if v &gt; 0:\n            raise ValueError(f\"Coastline limit depth (zlim) must be &lt;= 0 (below sea level), got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Grid.validate_dmin","title":"validate_dmin  <code>classmethod</code>","text":"<pre><code>validate_dmin(v)\n</code></pre> <p>Validate minimum depth for wave propagation.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>@field_validator('dmin')\n@classmethod\ndef validate_dmin(cls, v):\n    \"\"\"Validate minimum depth for wave propagation.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"Minimum depth (dmin) must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rect-namelist","title":"Rect Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect","title":"Rect","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>RECT_NML namelist for WW3.</p> <p>The RECT_NML namelist defines the parameters for rectilinear grids in WAVEWATCH III. Rectilinear grids have constant spacing in each direction and form a regular grid.</p> <p>The minimum grid size is 3x3. The coordinate increments (SX, SY) define the spacing between grid points and depend on the coordinate system (spherical or cartesian).</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>class Rect(NamelistBaseModel):\n    \"\"\"RECT_NML namelist for WW3.\n\n    The RECT_NML namelist defines the parameters for rectilinear grids in WAVEWATCH III.\n    Rectilinear grids have constant spacing in each direction and form a regular grid.\n\n    The minimum grid size is 3x3. The coordinate increments (SX, SY) define the spacing\n    between grid points and depend on the coordinate system (spherical or cartesian).\n    \"\"\"\n\n    nx: Optional[int] = Field(\n        default=None,\n        description=\"Number of points along the x-axis of the rectilinear grid. Minimum size is 3x3 grid.\",\n        ge=3  # Minimum grid size is 3x3\n    )\n    ny: Optional[int] = Field(\n        default=None,\n        description=\"Number of points along the y-axis of the rectilinear grid. Minimum size is 3x3 grid.\",\n        ge=3  # Minimum grid size is 3x3\n    )\n    sx: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Grid increment along x-axis. In spherical coordinates (degrees), this is the \"\n            \"longitude increment. In cartesian coordinates (meters), this is the x-direction spacing. \"\n            \"If grid increments are given in minutes of arc, the scaling factor SF must be set to 60 \"\n            \"to provide an increment factor in degrees.\"\n        ),\n        gt=0  # Must be positive\n    )\n    sy: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Grid increment along y-axis. In spherical coordinates (degrees), this is the \"\n            \"latitude increment. In cartesian coordinates (meters), this is the y-direction spacing. \"\n            \"If grid increments are given in minutes of arc, the scaling factor SF must be set to 60 \"\n            \"to provide an increment factor in degrees.\"\n        ),\n        gt=0  # Must be positive\n    )\n    sf: Optional[float] = Field(\n        default=1.0,\n        description=(\n            \"Scaling division factor for x-y axis. Used when grid increments are given in \"\n            \"different units. For example, if SX and SY are in minutes of arc, set SF to 60 \"\n            \"to convert to degrees. Value = value_read / scale_fac.\"\n        ),\n        gt=0  # Must be positive\n    )\n    x0: Optional[float] = Field(\n        default=None,\n        description=(\n            \"X-coordinate of the lower-left corner of the grid. In spherical coordinates, \"\n            \"this is the longitude of the SW corner. In cartesian coordinates, this is \"\n            \"the x-coordinate of the SW corner. If CSTRG='SMPL', then SX is forced to 360/NX.\"\n        )\n    )\n    y0: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Y-coordinate of the lower-left corner of the grid. In spherical coordinates, \"\n            \"this is the latitude of the SW corner. In cartesian coordinates, this is \"\n            \"the y-coordinate of the SW corner.\"\n        )\n    )\n    sf0: Optional[float] = Field(\n        default=1.0,\n        description=(\n            \"Scaling division factor for x0,y0 coordinates. Used when the corner coordinates \"\n            \"are given in different units. Value = value_read / scale_fac.\"\n        ),\n        gt=0  # Must be positive\n    )\n\n    @field_validator('nx', 'ny')\n    @classmethod\n    def validate_grid_dimensions(cls, v):\n        \"\"\"Validate grid dimensions.\"\"\"\n        if v is not None:\n            if v &lt; 3:\n                raise ValueError(f\"Grid dimension must be at least 3, got {v}\")\n        return v\n\n    @field_validator('sx', 'sy', 'sf', 'sf0')\n    @classmethod\n    def validate_positive_values(cls, v):\n        \"\"\"Validate that spacing and scaling factors are positive.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"Spacing and scaling factors must be positive, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.nx","title":"nx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nx: Optional[int] = Field(default=None, description='Number of points along the x-axis of the rectilinear grid. Minimum size is 3x3 grid.', ge=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.ny","title":"ny  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ny: Optional[int] = Field(default=None, description='Number of points along the y-axis of the rectilinear grid. Minimum size is 3x3 grid.', ge=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.sx","title":"sx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sx: Optional[float] = Field(default=None, description='Grid increment along x-axis. In spherical coordinates (degrees), this is the longitude increment. In cartesian coordinates (meters), this is the x-direction spacing. If grid increments are given in minutes of arc, the scaling factor SF must be set to 60 to provide an increment factor in degrees.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.sy","title":"sy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sy: Optional[float] = Field(default=None, description='Grid increment along y-axis. In spherical coordinates (degrees), this is the latitude increment. In cartesian coordinates (meters), this is the y-direction spacing. If grid increments are given in minutes of arc, the scaling factor SF must be set to 60 to provide an increment factor in degrees.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.sf","title":"sf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sf: Optional[float] = Field(default=1.0, description='Scaling division factor for x-y axis. Used when grid increments are given in different units. For example, if SX and SY are in minutes of arc, set SF to 60 to convert to degrees. Value = value_read / scale_fac.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.x0","title":"x0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x0: Optional[float] = Field(default=None, description=\"X-coordinate of the lower-left corner of the grid. In spherical coordinates, this is the longitude of the SW corner. In cartesian coordinates, this is the x-coordinate of the SW corner. If CSTRG='SMPL', then SX is forced to 360/NX.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.y0","title":"y0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y0: Optional[float] = Field(default=None, description='Y-coordinate of the lower-left corner of the grid. In spherical coordinates, this is the latitude of the SW corner. In cartesian coordinates, this is the y-coordinate of the SW corner.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.sf0","title":"sf0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sf0: Optional[float] = Field(default=1.0, description='Scaling division factor for x0,y0 coordinates. Used when the corner coordinates are given in different units. Value = value_read / scale_fac.', gt=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.validate_grid_dimensions","title":"validate_grid_dimensions  <code>classmethod</code>","text":"<pre><code>validate_grid_dimensions(v)\n</code></pre> <p>Validate grid dimensions.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>@field_validator('nx', 'ny')\n@classmethod\ndef validate_grid_dimensions(cls, v):\n    \"\"\"Validate grid dimensions.\"\"\"\n    if v is not None:\n        if v &lt; 3:\n            raise ValueError(f\"Grid dimension must be at least 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.grid.Rect.validate_positive_values","title":"validate_positive_values  <code>classmethod</code>","text":"<pre><code>validate_positive_values(v)\n</code></pre> <p>Validate that spacing and scaling factors are positive.</p> Source code in <code>rompy_ww3/namelists/grid.py</code> <pre><code>@field_validator('sx', 'sy', 'sf', 'sf0')\n@classmethod\ndef validate_positive_values(cls, v):\n    \"\"\"Validate that spacing and scaling factors are positive.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"Spacing and scaling factors must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#curv-namelist","title":"Curv Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv","title":"Curv","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>CURV_NML namelist for WW3.</p> <p>The CURV_NML namelist defines the parameters for curvilinear grids in WAVEWATCH III. Curvilinear grids have variable spacing and can adapt to complex coastlines and bathymetry.</p> <p>The minimum grid size is 3x3. The coordinate data (xcoord and ycoord) specify how coordinate values are read from input files for each grid point. Each coordinate dimension has its own CoordData specification.</p> Source code in <code>rompy_ww3/namelists/curv.py</code> <pre><code>class Curv(NamelistBaseModel):\n    \"\"\"CURV_NML namelist for WW3.\n\n    The CURV_NML namelist defines the parameters for curvilinear grids in WAVEWATCH III.\n    Curvilinear grids have variable spacing and can adapt to complex coastlines and bathymetry.\n\n    The minimum grid size is 3x3. The coordinate data (xcoord and ycoord) specify how\n    coordinate values are read from input files for each grid point.\n    Each coordinate dimension has its own CoordData specification.\n    \"\"\"\n\n    nx: Optional[int] = Field(\n        default=None,\n        description=\"Number of points along the x-axis of the curvilinear grid. Minimum size is 3x3 grid.\",\n        ge=3  # Minimum grid size is 3x3\n    )\n    ny: Optional[int] = Field(\n        default=None,\n        description=\"Number of points along the y-axis of the curvilinear grid. Minimum size is 3x3 grid.\",\n        ge=3  # Minimum grid size is 3x3\n    )\n    xcoord: Optional[CoordData] = Field(\n        default=None,\n        description=(\n            \"X-coordinate data specification defining how longitude/x-coordinates \"\n            \"are read from the input file for the curvilinear grid.\"\n        )\n    )\n    ycoord: Optional[CoordData] = Field(\n        default=None,\n        description=(\n            \"Y-coordinate data specification defining how latitude/y-coordinates \"\n            \"are read from the input file for the curvilinear grid.\"\n        )\n    )\n\n    @field_validator('nx', 'ny')\n    @classmethod\n    def validate_grid_dimensions(cls, v):\n        \"\"\"Validate grid dimensions.\"\"\"\n        if v is not None:\n            if v &lt; 3:\n                raise ValueError(f\"Grid dimension must be at least 3, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv.nx","title":"nx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nx: Optional[int] = Field(default=None, description='Number of points along the x-axis of the curvilinear grid. Minimum size is 3x3 grid.', ge=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv.ny","title":"ny  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ny: Optional[int] = Field(default=None, description='Number of points along the y-axis of the curvilinear grid. Minimum size is 3x3 grid.', ge=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv.xcoord","title":"xcoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>xcoord: Optional[CoordData] = Field(default=None, description='X-coordinate data specification defining how longitude/x-coordinates are read from the input file for the curvilinear grid.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv.ycoord","title":"ycoord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ycoord: Optional[CoordData] = Field(default=None, description='Y-coordinate data specification defining how latitude/y-coordinates are read from the input file for the curvilinear grid.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.curv.Curv.validate_grid_dimensions","title":"validate_grid_dimensions  <code>classmethod</code>","text":"<pre><code>validate_grid_dimensions(v)\n</code></pre> <p>Validate grid dimensions.</p> Source code in <code>rompy_ww3/namelists/curv.py</code> <pre><code>@field_validator('nx', 'ny')\n@classmethod\ndef validate_grid_dimensions(cls, v):\n    \"\"\"Validate grid dimensions.\"\"\"\n    if v is not None:\n        if v &lt; 3:\n            raise ValueError(f\"Grid dimension must be at least 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#unst-namelist","title":"Unst Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst","title":"Unst","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>UNST_NML namelist for WW3.</p> <p>The UNST_NML namelist defines the parameters for unstructured grids in WAVEWATCH III. Unstructured grids use triangular elements to represent the domain, allowing for flexible resolution that can be refined in areas of interest.</p> <p>The unstructured grid file must be a GMESH grid file containing node and element lists. The depth values must have negative values under the mean sea level, and the map values define different types of grid points as documented below.</p> Source code in <code>rompy_ww3/namelists/unst.py</code> <pre><code>class Unst(NamelistBaseModel):\n    \"\"\"UNST_NML namelist for WW3.\n\n    The UNST_NML namelist defines the parameters for unstructured grids in WAVEWATCH III.\n    Unstructured grids use triangular elements to represent the domain, allowing for\n    flexible resolution that can be refined in areas of interest.\n\n    The unstructured grid file must be a GMESH grid file containing node and element lists.\n    The depth values must have negative values under the mean sea level, and the map values\n    define different types of grid points as documented below.\n    \"\"\"\n\n    sf: Optional[float] = Field(\n        default=1.0,\n        description=(\n            \"Unstructured grid scale factor used to convert from file values to model coordinates. \"\n            \"The final coordinate value is calculated as: scale_factor * value_read. \"\n            \"For depth files, use a negative value to ensure depths are negative (below sea level).\"\n        )\n    )\n    filename: Optional[Union[str, WW3DataBlob]] = Field(\n        default=\"unset\",\n        description=(\n            \"Filename or data blob containing the unstructured grid data. This file should be \"\n            \"a GMESH grid file format containing the node and element lists for the triangular mesh.\"\n        )\n    )\n    idf: Optional[int] = Field(\n        default=20,\n        description=(\n            \"File unit number for the unstructured grid file. Each file in WW3 is assigned a unique \"\n            \"unit number to distinguish between different input files during processing.\"\n        ),\n        ge=1  # Must be positive file unit number\n    )\n    idla: Optional[int] = Field(\n        default=1,\n        description=(\n            \"Layout indicator for reading unstructured grid data:\\n\"\n            \"  1: Read line-by-line from bottom to top (default)\\n\"\n            \"  2: Like 1, with a single read statement\\n\"\n            \"  3: Read line-by-line from top to bottom\\n\"\n            \"  4: Like 3, with a single read statement\"\n        ),\n        ge=1,\n        le=4\n    )\n    idfm: Optional[int] = Field(\n        default=1,\n        description=(\n            \"Format indicator for reading unstructured grid data:\\n\"\n            \"  1: Free format (default)\\n\"\n            \"  2: Fixed format\\n\"\n            \"  3: Unformatted\"\n        ),\n        ge=1,\n        le=3\n    )\n    format: Optional[str] = Field(\n        default=\"(....)\",\n        description=(\n            \"Formatted read format specification, like '(20f10.2)' for float type. \"\n            \"Use '(....)' for auto detection of the format. This specifies how the \"\n            \"unstructured grid values should be read from the file.\"\n        )\n    )\n    ugobcfile: Optional[str] = Field(\n        default=\"unset\",\n        description=(\n            \"Additional boundary list file with UGOBCFILE in namelist. This file contains \"\n            \"extra open boundary information for the unstructured grid. An example is given \"\n            \"in the WW3 regression test ww3_tp2.7.\"\n        )\n    )\n\n    @field_validator('sf')\n    @classmethod\n    def validate_scale_factor(cls, v):\n        \"\"\"Validate scale factor is not zero.\"\"\"\n        if v is not None:\n            if v == 0:\n                raise ValueError(f\"Scale factor must not be zero, got {v}\")\n        return v\n\n    @field_validator('idf')\n    @classmethod\n    def validate_file_unit(cls, v):\n        \"\"\"Validate file unit number.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"File unit number must be positive, got {v}\")\n        return v\n\n    @field_validator('idla')\n    @classmethod\n    def validate_idla(cls, v):\n        \"\"\"Validate layout indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n        return v\n\n    @field_validator('idfm')\n    @classmethod\n    def validate_idfm(cls, v):\n        \"\"\"Validate format indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3]:\n            raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.sf","title":"sf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sf: Optional[float] = Field(default=1.0, description='Unstructured grid scale factor used to convert from file values to model coordinates. The final coordinate value is calculated as: scale_factor * value_read. For depth files, use a negative value to ensure depths are negative (below sea level).')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.filename","title":"filename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filename: Optional[Union[str, WW3DataBlob]] = Field(default='unset', description='Filename or data blob containing the unstructured grid data. This file should be a GMESH grid file format containing the node and element lists for the triangular mesh.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.idf","title":"idf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idf: Optional[int] = Field(default=20, description='File unit number for the unstructured grid file. Each file in WW3 is assigned a unique unit number to distinguish between different input files during processing.', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[int] = Field(default=1, description='Layout indicator for reading unstructured grid data:\\n  1: Read line-by-line from bottom to top (default)\\n  2: Like 1, with a single read statement\\n  3: Read line-by-line from top to bottom\\n  4: Like 3, with a single read statement', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.idfm","title":"idfm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idfm: Optional[int] = Field(default=1, description='Format indicator for reading unstructured grid data:\\n  1: Free format (default)\\n  2: Fixed format\\n  3: Unformatted', ge=1, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[str] = Field(default='(....)', description=\"Formatted read format specification, like '(20f10.2)' for float type. Use '(....)' for auto detection of the format. This specifies how the unstructured grid values should be read from the file.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.ugobcfile","title":"ugobcfile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ugobcfile: Optional[str] = Field(default='unset', description='Additional boundary list file with UGOBCFILE in namelist. This file contains extra open boundary information for the unstructured grid. An example is given in the WW3 regression test ww3_tp2.7.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.validate_scale_factor","title":"validate_scale_factor  <code>classmethod</code>","text":"<pre><code>validate_scale_factor(v)\n</code></pre> <p>Validate scale factor is not zero.</p> Source code in <code>rompy_ww3/namelists/unst.py</code> <pre><code>@field_validator('sf')\n@classmethod\ndef validate_scale_factor(cls, v):\n    \"\"\"Validate scale factor is not zero.\"\"\"\n    if v is not None:\n        if v == 0:\n            raise ValueError(f\"Scale factor must not be zero, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.validate_file_unit","title":"validate_file_unit  <code>classmethod</code>","text":"<pre><code>validate_file_unit(v)\n</code></pre> <p>Validate file unit number.</p> Source code in <code>rompy_ww3/namelists/unst.py</code> <pre><code>@field_validator('idf')\n@classmethod\ndef validate_file_unit(cls, v):\n    \"\"\"Validate file unit number.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"File unit number must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(v)\n</code></pre> <p>Validate layout indicator.</p> Source code in <code>rompy_ww3/namelists/unst.py</code> <pre><code>@field_validator('idla')\n@classmethod\ndef validate_idla(cls, v):\n    \"\"\"Validate layout indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.unst.Unst.validate_idfm","title":"validate_idfm  <code>classmethod</code>","text":"<pre><code>validate_idfm(v)\n</code></pre> <p>Validate format indicator.</p> Source code in <code>rompy_ww3/namelists/unst.py</code> <pre><code>@field_validator('idfm')\n@classmethod\ndef validate_idfm(cls, v):\n    \"\"\"Validate format indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3]:\n        raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#smc-namelist","title":"SMC Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc","title":"Smc","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>SMC_NML namelist for WW3.</p> <p>The SMC_NML namelist defines the parameters for spherical multiple-cell (SMC) grids in WAVEWATCH III. SMC grids use a multi-resolution approach with nested grids for different regions.</p> <p>The SMC grid configuration involves multiple files containing: - MCELS: SMC cell arrays (MCels.dat) - ISIDE &amp; JSIDE: Face arrays (ISide.dat, JSide.dat) - SUBTR: Obstruction ratio data (Subtr.dat) - BUNDY: Boundary cell list file (Bundy.dat) - only needed when NBISMC &gt; 0 - MBArc: Extra cell arrays for Arctic part (MBArc.dat) - if ARC switch selected - AISid &amp; AJSid: Extra face arrays for Arctic part (AISid.dat, AJSid.dat)</p> <p>These grids are especially useful for global applications where higher resolution is  needed in certain areas while maintaining coarser resolution elsewhere.</p> Source code in <code>rompy_ww3/namelists/smc.py</code> <pre><code>class Smc(NamelistBaseModel):\n    \"\"\"SMC_NML namelist for WW3.\n\n    The SMC_NML namelist defines the parameters for spherical multiple-cell (SMC) grids in WAVEWATCH III.\n    SMC grids use a multi-resolution approach with nested grids for different regions.\n\n    The SMC grid configuration involves multiple files containing:\n    - MCELS: SMC cell arrays (MCels.dat)\n    - ISIDE &amp; JSIDE: Face arrays (ISide.dat, JSide.dat)\n    - SUBTR: Obstruction ratio data (Subtr.dat)\n    - BUNDY: Boundary cell list file (Bundy.dat) - only needed when NBISMC &gt; 0\n    - MBArc: Extra cell arrays for Arctic part (MBArc.dat) - if ARC switch selected\n    - AISid &amp; AJSid: Extra face arrays for Arctic part (AISid.dat, AJSid.dat)\n\n    These grids are especially useful for global applications where higher resolution is \n    needed in certain areas while maintaining coarser resolution elsewhere.\n    \"\"\"\n\n    mcel: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"MCels (Multiple-Cell elements) data file containing the SMC cell array information. \"\n            \"This file (typically 'S6125MCels.dat') contains the basic grid cell definitions \"\n            \"for the SMC grid structure.\"\n        )\n    )\n    iside: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"ISide data file containing the I-direction face information for the SMC grid. \"\n            \"This file (typically 'S6125ISide.dat') contains the face connections in the I-direction \"\n            \"for the spherical multiple-cell grid.\"\n        )\n    )\n    jside: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"JSide data file containing the J-direction face information for the SMC grid. \"\n            \"This file (typically 'S6125JSide.dat') contains the face connections in the J-direction \"\n            \"for the spherical multiple-cell grid.\"\n        )\n    )\n    subtr: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"Subtr (Subtraction) data file containing the obstruction ratio information. \"\n            \"This file (typically 'SMC25Subtr.dat') contains the data for handling \"\n            \"obstructions at cell boundaries or centers in the SMC grid.\"\n        )\n    )\n    bundy: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"Bundy data file containing the boundary cell list information. \"\n            \"This file (typically 'S6125Bundy.dat') is only needed when NBISMC &gt; 0. \"\n            \"The boundary cell ID numbers should be the sequential numbers in the \"\n            \"cell array (unit 31) of the SMC cell file.\"\n        )\n    )\n    mbarc: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"MBArc (Multiple-Cell Arctic) data file containing extra cell arrays for Arctic regions. \"\n            \"This file (typically 'S6125MBArc.dat') is used when Arctic part switches are selected \"\n            \"to provide additional grid information for the Arctic region.\"\n        )\n    )\n    aisid: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"AISid (Arctic I-Side) data file containing extra face arrays for Arctic I-direction. \"\n            \"This file (typically 'S6125AISid.dat') is used when Arctic part switches are selected \"\n            \"to provide additional face information for the Arctic region.\"\n        )\n    )\n    ajsid: Optional[SMCFile] = Field(\n        default=None,\n        description=(\n            \"AJSid (Arctic J-Side) data file containing extra face arrays for Arctic J-direction. \"\n            \"This file (typically 'S6125AJSid.dat') is used when Arctic part switches are selected \"\n            \"to provide additional face information for the Arctic region.\"\n        )\n    )\n\n    @field_validator('mcel', 'iside', 'jside', 'subtr', 'bundy', 'mbarc', 'aisid', 'ajsid')\n    @classmethod\n    def validate_smc_files(cls, v):\n        \"\"\"Validate SMC file specifications.\"\"\"\n        if v is not None:\n            if not isinstance(v, SMCFile):\n                raise ValueError(f\"SMC file data must be of type SMCFile, got {type(v)}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.mcel","title":"mcel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mcel: Optional[SMCFile] = Field(default=None, description=\"MCels (Multiple-Cell elements) data file containing the SMC cell array information. This file (typically 'S6125MCels.dat') contains the basic grid cell definitions for the SMC grid structure.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.iside","title":"iside  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iside: Optional[SMCFile] = Field(default=None, description=\"ISide data file containing the I-direction face information for the SMC grid. This file (typically 'S6125ISide.dat') contains the face connections in the I-direction for the spherical multiple-cell grid.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.jside","title":"jside  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jside: Optional[SMCFile] = Field(default=None, description=\"JSide data file containing the J-direction face information for the SMC grid. This file (typically 'S6125JSide.dat') contains the face connections in the J-direction for the spherical multiple-cell grid.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.subtr","title":"subtr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subtr: Optional[SMCFile] = Field(default=None, description=\"Subtr (Subtraction) data file containing the obstruction ratio information. This file (typically 'SMC25Subtr.dat') contains the data for handling obstructions at cell boundaries or centers in the SMC grid.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.bundy","title":"bundy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bundy: Optional[SMCFile] = Field(default=None, description=\"Bundy data file containing the boundary cell list information. This file (typically 'S6125Bundy.dat') is only needed when NBISMC &gt; 0. The boundary cell ID numbers should be the sequential numbers in the cell array (unit 31) of the SMC cell file.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.mbarc","title":"mbarc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mbarc: Optional[SMCFile] = Field(default=None, description=\"MBArc (Multiple-Cell Arctic) data file containing extra cell arrays for Arctic regions. This file (typically 'S6125MBArc.dat') is used when Arctic part switches are selected to provide additional grid information for the Arctic region.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.aisid","title":"aisid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aisid: Optional[SMCFile] = Field(default=None, description=\"AISid (Arctic I-Side) data file containing extra face arrays for Arctic I-direction. This file (typically 'S6125AISid.dat') is used when Arctic part switches are selected to provide additional face information for the Arctic region.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.ajsid","title":"ajsid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ajsid: Optional[SMCFile] = Field(default=None, description=\"AJSid (Arctic J-Side) data file containing extra face arrays for Arctic J-direction. This file (typically 'S6125AJSid.dat') is used when Arctic part switches are selected to provide additional face information for the Arctic region.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.smc.Smc.validate_smc_files","title":"validate_smc_files  <code>classmethod</code>","text":"<pre><code>validate_smc_files(v)\n</code></pre> <p>Validate SMC file specifications.</p> Source code in <code>rompy_ww3/namelists/smc.py</code> <pre><code>@field_validator('mcel', 'iside', 'jside', 'subtr', 'bundy', 'mbarc', 'aisid', 'ajsid')\n@classmethod\ndef validate_smc_files(cls, v):\n    \"\"\"Validate SMC file specifications.\"\"\"\n    if v is not None:\n        if not isinstance(v, SMCFile):\n            raise ValueError(f\"SMC file data must be of type SMCFile, got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#depth-namelist","title":"Depth Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth","title":"Depth","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>DEPTH_NML namelist for WW3.</p> <p>The DEPTH_NML namelist defines the bathymetry depth data to preprocess for WAVEWATCH III. This namelist specifies how depth values are read from input files and applied to the grid.</p> <p>The depth values must have negative values under the mean sea level. The scale factor is used to convert the values from the input file to the proper depth values needed by WW3. For example, if the file contains positive depth values in millimeters, use a scale factor of -0.001 to convert to negative meters (below sea level).</p> <p>If no obstruction subgrid is used, need to set &amp;MISC FLAGTR = 0 in param.nml.</p> Source code in <code>rompy_ww3/namelists/depth.py</code> <pre><code>class Depth(NamelistBaseModel):\n    \"\"\"DEPTH_NML namelist for WW3.\n\n    The DEPTH_NML namelist defines the bathymetry depth data to preprocess for WAVEWATCH III.\n    This namelist specifies how depth values are read from input files and applied to the grid.\n\n    The depth values must have negative values under the mean sea level. The scale factor\n    is used to convert the values from the input file to the proper depth values needed by WW3.\n    For example, if the file contains positive depth values in millimeters, use a scale factor\n    of -0.001 to convert to negative meters (below sea level).\n\n    If no obstruction subgrid is used, need to set &amp;MISC FLAGTR = 0 in param.nml.\n    \"\"\"\n\n    sf: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scale factor to apply to depth values from the input file. \"\n            \"The final depth value is calculated as: depth = value_read * scale_factor. \"\n            \"For typical bathymetry files with positive depths, a negative scale factor \"\n            \"should be used to ensure the resulting depths are negative (below sea level). \"\n            \"For example, if the file contains positive depths in millimeters, use -0.001 \"\n            \"to convert to negative meters.\"\n        )\n    )\n    filename: Optional[Union[str, WW3DataBlob]] = Field(\n        default=None,\n        description=(\n            \"Filename or data blob containing the depth data for the grid. This file should contain \"\n            \"the bathymetry/elevation data in the format specified by the idfm and format parameters.\"\n        )\n    )\n    idf: Optional[int] = Field(\n        default=None,\n        description=(\n            \"File unit number for the depth file. Each file in WW3 is assigned a unique \"\n            \"unit number to distinguish between different input files during processing.\"\n        ),\n        ge=1  # Must be positive file unit number\n    )\n    idla: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Layout indicator for reading depth data:\\n\"\n            \"  1: Read line-by-line from bottom to top (default)\\n\"\n            \"  2: Like 1, but with a single read statement\\n\"\n            \"  3: Read line-by-line from top to bottom\\n\"\n            \"  4: Like 3, but with a single read statement\"\n        ),\n        ge=1,\n        le=4\n    )\n    idfm: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Format indicator for reading depth data:\\n\"\n            \"  1: Free format (default)\\n\"\n            \"  2: Fixed format\\n\"\n            \"  3: Unformatted\"\n        ),\n        ge=1,\n        le=3\n    )\n    format: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Formatted read format specification, like '(f10.6)' for float type. \"\n            \"Use '(....)' for auto detection of the format. This specifies how the \"\n            \"depth values should be read from the file.\"\n        )\n    )\n\n    @field_validator('sf')\n    @classmethod\n    def validate_scale_factor(cls, v):\n        \"\"\"Validate scale factor is not zero.\"\"\"\n        if v is not None:\n            if v == 0:\n                raise ValueError(f\"Scale factor must not be zero, got {v}\")\n        return v\n\n    @field_validator('idf')\n    @classmethod\n    def validate_file_unit(cls, v):\n        \"\"\"Validate file unit number.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"File unit number must be positive, got {v}\")\n        return v\n\n    @field_validator('idla')\n    @classmethod\n    def validate_idla(cls, v):\n        \"\"\"Validate layout indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n        return v\n\n    @field_validator('idfm')\n    @classmethod\n    def validate_idfm(cls, v):\n        \"\"\"Validate format indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3]:\n            raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.sf","title":"sf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sf: Optional[float] = Field(default=None, description='Scale factor to apply to depth values from the input file. The final depth value is calculated as: depth = value_read * scale_factor. For typical bathymetry files with positive depths, a negative scale factor should be used to ensure the resulting depths are negative (below sea level). For example, if the file contains positive depths in millimeters, use -0.001 to convert to negative meters.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.filename","title":"filename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filename: Optional[Union[str, WW3DataBlob]] = Field(default=None, description='Filename or data blob containing the depth data for the grid. This file should contain the bathymetry/elevation data in the format specified by the idfm and format parameters.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.idf","title":"idf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idf: Optional[int] = Field(default=None, description='File unit number for the depth file. Each file in WW3 is assigned a unique unit number to distinguish between different input files during processing.', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[int] = Field(default=None, description='Layout indicator for reading depth data:\\n  1: Read line-by-line from bottom to top (default)\\n  2: Like 1, but with a single read statement\\n  3: Read line-by-line from top to bottom\\n  4: Like 3, but with a single read statement', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.idfm","title":"idfm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idfm: Optional[int] = Field(default=None, description='Format indicator for reading depth data:\\n  1: Free format (default)\\n  2: Fixed format\\n  3: Unformatted', ge=1, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[str] = Field(default=None, description=\"Formatted read format specification, like '(f10.6)' for float type. Use '(....)' for auto detection of the format. This specifies how the depth values should be read from the file.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.validate_scale_factor","title":"validate_scale_factor  <code>classmethod</code>","text":"<pre><code>validate_scale_factor(v)\n</code></pre> <p>Validate scale factor is not zero.</p> Source code in <code>rompy_ww3/namelists/depth.py</code> <pre><code>@field_validator('sf')\n@classmethod\ndef validate_scale_factor(cls, v):\n    \"\"\"Validate scale factor is not zero.\"\"\"\n    if v is not None:\n        if v == 0:\n            raise ValueError(f\"Scale factor must not be zero, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.validate_file_unit","title":"validate_file_unit  <code>classmethod</code>","text":"<pre><code>validate_file_unit(v)\n</code></pre> <p>Validate file unit number.</p> Source code in <code>rompy_ww3/namelists/depth.py</code> <pre><code>@field_validator('idf')\n@classmethod\ndef validate_file_unit(cls, v):\n    \"\"\"Validate file unit number.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"File unit number must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(v)\n</code></pre> <p>Validate layout indicator.</p> Source code in <code>rompy_ww3/namelists/depth.py</code> <pre><code>@field_validator('idla')\n@classmethod\ndef validate_idla(cls, v):\n    \"\"\"Validate layout indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.depth.Depth.validate_idfm","title":"validate_idfm  <code>classmethod</code>","text":"<pre><code>validate_idfm(v)\n</code></pre> <p>Validate format indicator.</p> Source code in <code>rompy_ww3/namelists/depth.py</code> <pre><code>@field_validator('idfm')\n@classmethod\ndef validate_idfm(cls, v):\n    \"\"\"Validate format indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3]:\n        raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#mask-namelist","title":"Mask Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask","title":"Mask","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>MASK_NML namelist for WW3.</p> <p>The MASK_NML namelist defines the point status map for WAVEWATCH III grids. The mask defines the status of each grid point as land, sea, boundary, etc. This is used to determine which points participate in the wave modeling.</p> <p>If no mask is defined, the INBOUND option can be used to set active boundaries. The legend for the input map is:  -2 : Excluded boundary point (covered by ice)  -1 : Excluded sea point (covered by ice)   0 : Excluded land point   1 : Sea point   2 : Active boundary point   3 : Excluded grid point   7 : Ice point</p> Source code in <code>rompy_ww3/namelists/mask.py</code> <pre><code>class Mask(NamelistBaseModel):\n    \"\"\"MASK_NML namelist for WW3.\n\n    The MASK_NML namelist defines the point status map for WAVEWATCH III grids.\n    The mask defines the status of each grid point as land, sea, boundary, etc.\n    This is used to determine which points participate in the wave modeling.\n\n    If no mask is defined, the INBOUND option can be used to set active boundaries.\n    The legend for the input map is:\n     -2 : Excluded boundary point (covered by ice)\n     -1 : Excluded sea point (covered by ice)\n      0 : Excluded land point\n      1 : Sea point\n      2 : Active boundary point\n      3 : Excluded grid point\n      7 : Ice point\n    \"\"\"\n\n    filename: Optional[Union[str, WW3DataBlob]] = Field(\n        default=None,\n        description=(\n            \"Filename or data blob containing the mask data for the grid. This file should contain \"\n            \"the point status values in the format specified by the idfm and format parameters.\"\n        )\n    )\n    idf: Optional[int] = Field(\n        default=None,\n        description=(\n            \"File unit number for the mask file. Each file in WW3 is assigned a unique \"\n            \"unit number to distinguish between different input files during processing.\"\n        ),\n        ge=1  # Must be positive file unit number\n    )\n    idla: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Layout indicator for reading mask data:\\n\"\n            \"  1: Read line-by-line from bottom to top (default)\\n\"\n            \"  2: Like 1, but with a single read statement\\n\"\n            \"  3: Read line-by-line from top to bottom\\n\"\n            \"  4: Like 3, but with a single read statement\"\n        ),\n        ge=1,\n        le=4\n    )\n    idfm: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Format indicator for reading mask data:\\n\"\n            \"  1: Free format (default)\\n\"\n            \"  2: Fixed format\\n\"\n            \"  3: Unformatted\"\n        ),\n        ge=1,\n        le=3\n    )\n    format: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Formatted read format specification, like '(f10.6)' for float type. \"\n            \"Use '(....)' for auto detection of the format. This specifies how the \"\n            \"mask values should be read from the file.\"\n        )\n    )\n\n    @field_validator('idf')\n    @classmethod\n    def validate_file_unit(cls, v):\n        \"\"\"Validate file unit number.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"File unit number must be positive, got {v}\")\n        return v\n\n    @field_validator('idla')\n    @classmethod\n    def validate_idla(cls, v):\n        \"\"\"Validate layout indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n        return v\n\n    @field_validator('idfm')\n    @classmethod\n    def validate_idfm(cls, v):\n        \"\"\"Validate format indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3]:\n            raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.filename","title":"filename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filename: Optional[Union[str, WW3DataBlob]] = Field(default=None, description='Filename or data blob containing the mask data for the grid. This file should contain the point status values in the format specified by the idfm and format parameters.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.idf","title":"idf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idf: Optional[int] = Field(default=None, description='File unit number for the mask file. Each file in WW3 is assigned a unique unit number to distinguish between different input files during processing.', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[int] = Field(default=None, description='Layout indicator for reading mask data:\\n  1: Read line-by-line from bottom to top (default)\\n  2: Like 1, but with a single read statement\\n  3: Read line-by-line from top to bottom\\n  4: Like 3, but with a single read statement', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.idfm","title":"idfm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idfm: Optional[int] = Field(default=None, description='Format indicator for reading mask data:\\n  1: Free format (default)\\n  2: Fixed format\\n  3: Unformatted', ge=1, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[str] = Field(default=None, description=\"Formatted read format specification, like '(f10.6)' for float type. Use '(....)' for auto detection of the format. This specifies how the mask values should be read from the file.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.validate_file_unit","title":"validate_file_unit  <code>classmethod</code>","text":"<pre><code>validate_file_unit(v)\n</code></pre> <p>Validate file unit number.</p> Source code in <code>rompy_ww3/namelists/mask.py</code> <pre><code>@field_validator('idf')\n@classmethod\ndef validate_file_unit(cls, v):\n    \"\"\"Validate file unit number.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"File unit number must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(v)\n</code></pre> <p>Validate layout indicator.</p> Source code in <code>rompy_ww3/namelists/mask.py</code> <pre><code>@field_validator('idla')\n@classmethod\ndef validate_idla(cls, v):\n    \"\"\"Validate layout indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.mask.Mask.validate_idfm","title":"validate_idfm  <code>classmethod</code>","text":"<pre><code>validate_idfm(v)\n</code></pre> <p>Validate format indicator.</p> Source code in <code>rompy_ww3/namelists/mask.py</code> <pre><code>@field_validator('idfm')\n@classmethod\ndef validate_idfm(cls, v):\n    \"\"\"Validate format indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3]:\n        raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#obstacle-namelist","title":"Obstacle Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle","title":"Obstacle","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>OBST_NML namelist for WW3.</p> <p>The OBST_NML namelist defines the obstruction map for WAVEWATCH III grids. This map is used only if &amp;MISC FLAGTR = 1 in param.nml (transparencies at cell boundaries) or if &amp;MISC FLAGTR = 2 in param.nml (transparencies at cell centers) or if &amp;MISC FLAGTR = 3 in param.nml (transparencies at cell boundaries with continuous ice) or if &amp;MISC FLAGTR = 4 in param.nml (transparencies at cell centers with continuous ice).</p> <p>The obstruction values represent the transparency or transmission coefficient of obstacles like vegetation, ice, structures, etc. The scale factor converts the input values to the appropriate obstruction values needed by WW3.</p> <p>In the case of unstructured grids, no obstruction file can be added.</p> <p>If the file unit number equals 10, then data is read from this file with special handling. No comment lines are allowed within the data input.</p> Source code in <code>rompy_ww3/namelists/obstacle.py</code> <pre><code>class Obstacle(NamelistBaseModel):\n    \"\"\"OBST_NML namelist for WW3.\n\n    The OBST_NML namelist defines the obstruction map for WAVEWATCH III grids.\n    This map is used only if &amp;MISC FLAGTR = 1 in param.nml (transparencies at cell boundaries)\n    or if &amp;MISC FLAGTR = 2 in param.nml (transparencies at cell centers)\n    or if &amp;MISC FLAGTR = 3 in param.nml (transparencies at cell boundaries with continuous ice)\n    or if &amp;MISC FLAGTR = 4 in param.nml (transparencies at cell centers with continuous ice).\n\n    The obstruction values represent the transparency or transmission coefficient of obstacles\n    like vegetation, ice, structures, etc. The scale factor converts the input values to the\n    appropriate obstruction values needed by WW3.\n\n    In the case of unstructured grids, no obstruction file can be added.\n\n    If the file unit number equals 10, then data is read from this file with special handling.\n    No comment lines are allowed within the data input.\n    \"\"\"\n\n    sf: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scale factor to apply to obstacle values from the input file. \"\n            \"The final obstruction value is calculated as: value = value_read * scale_factor. \"\n            \"This factor is used to convert the values from the input file to appropriate \"\n            \"obstruction values for WW3's transmission calculations.\"\n        )\n    )\n    filename: Optional[Union[str, WW3DataBlob]] = Field(\n        default=None,\n        description=(\n            \"Filename or data blob containing the obstruction data for the grid. This file should contain \"\n            \"the obstruction/transmission values in the format specified by the idfm and format parameters.\"\n        )\n    )\n    idf: Optional[int] = Field(\n        default=None,\n        description=(\n            \"File unit number for the obstacle file. Each file in WW3 is assigned a unique \"\n            \"unit number to distinguish between different input files during processing.\"\n        ),\n        ge=1  # Must be positive file unit number\n    )\n    idla: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Layout indicator for reading obstacle data:\\n\"\n            \"  1: Read line-by-line from bottom to top (default)\\n\"\n            \"  2: Like 1, but with a single read statement\\n\"\n            \"  3: Read line-by-line from top to bottom\\n\"\n            \"  4: Like 3, but with a single read statement\"\n        ),\n        ge=1,\n        le=4\n    )\n    idfm: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Format indicator for reading obstacle data:\\n\"\n            \"  1: Free format (default)\\n\"\n            \"  2: Fixed format\\n\"\n            \"  3: Unformatted\"\n        ),\n        ge=1,\n        le=3\n    )\n    format: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Formatted read format specification, like '(f10.6)' for float type. \"\n            \"Use '(....)' for auto detection of the format. This specifies how the \"\n            \"obstacle values should be read from the file.\"\n        )\n    )\n\n    @field_validator('sf')\n    @classmethod\n    def validate_scale_factor(cls, v):\n        \"\"\"Validate scale factor is not zero.\"\"\"\n        if v is not None:\n            if v == 0:\n                raise ValueError(f\"Scale factor must not be zero, got {v}\")\n        return v\n\n    @field_validator('idf')\n    @classmethod\n    def validate_file_unit(cls, v):\n        \"\"\"Validate file unit number.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"File unit number must be positive, got {v}\")\n        return v\n\n    @field_validator('idla')\n    @classmethod\n    def validate_idla(cls, v):\n        \"\"\"Validate layout indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n        return v\n\n    @field_validator('idfm')\n    @classmethod\n    def validate_idfm(cls, v):\n        \"\"\"Validate format indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3]:\n            raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.sf","title":"sf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sf: Optional[float] = Field(default=None, description=\"Scale factor to apply to obstacle values from the input file. The final obstruction value is calculated as: value = value_read * scale_factor. This factor is used to convert the values from the input file to appropriate obstruction values for WW3's transmission calculations.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.filename","title":"filename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filename: Optional[Union[str, WW3DataBlob]] = Field(default=None, description='Filename or data blob containing the obstruction data for the grid. This file should contain the obstruction/transmission values in the format specified by the idfm and format parameters.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.idf","title":"idf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idf: Optional[int] = Field(default=None, description='File unit number for the obstacle file. Each file in WW3 is assigned a unique unit number to distinguish between different input files during processing.', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[int] = Field(default=None, description='Layout indicator for reading obstacle data:\\n  1: Read line-by-line from bottom to top (default)\\n  2: Like 1, but with a single read statement\\n  3: Read line-by-line from top to bottom\\n  4: Like 3, but with a single read statement', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.idfm","title":"idfm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idfm: Optional[int] = Field(default=None, description='Format indicator for reading obstacle data:\\n  1: Free format (default)\\n  2: Fixed format\\n  3: Unformatted', ge=1, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[str] = Field(default=None, description=\"Formatted read format specification, like '(f10.6)' for float type. Use '(....)' for auto detection of the format. This specifies how the obstacle values should be read from the file.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.validate_scale_factor","title":"validate_scale_factor  <code>classmethod</code>","text":"<pre><code>validate_scale_factor(v)\n</code></pre> <p>Validate scale factor is not zero.</p> Source code in <code>rompy_ww3/namelists/obstacle.py</code> <pre><code>@field_validator('sf')\n@classmethod\ndef validate_scale_factor(cls, v):\n    \"\"\"Validate scale factor is not zero.\"\"\"\n    if v is not None:\n        if v == 0:\n            raise ValueError(f\"Scale factor must not be zero, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.validate_file_unit","title":"validate_file_unit  <code>classmethod</code>","text":"<pre><code>validate_file_unit(v)\n</code></pre> <p>Validate file unit number.</p> Source code in <code>rompy_ww3/namelists/obstacle.py</code> <pre><code>@field_validator('idf')\n@classmethod\ndef validate_file_unit(cls, v):\n    \"\"\"Validate file unit number.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"File unit number must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(v)\n</code></pre> <p>Validate layout indicator.</p> Source code in <code>rompy_ww3/namelists/obstacle.py</code> <pre><code>@field_validator('idla')\n@classmethod\ndef validate_idla(cls, v):\n    \"\"\"Validate layout indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.obstacle.Obstacle.validate_idfm","title":"validate_idfm  <code>classmethod</code>","text":"<pre><code>validate_idfm(v)\n</code></pre> <p>Validate format indicator.</p> Source code in <code>rompy_ww3/namelists/obstacle.py</code> <pre><code>@field_validator('idfm')\n@classmethod\ndef validate_idfm(cls, v):\n    \"\"\"Validate format indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3]:\n        raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#slope-namelist","title":"Slope Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope","title":"Slope","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>SLOPE_NML namelist for WW3.</p> <p>The SLOPE_NML namelist defines the reflection slope map for WAVEWATCH III grids. This map is used only if &amp;REF1 REFMAP = 2 is defined in param.nml.</p> <p>The reflection slope values represent the characteristics of coastal slopes that  affect wave reflection and dissipation. The scale factor converts the input values  to the appropriate slope values needed by WW3's reflection calculations.</p> <p>In the case of unstructured grids, no reflection slope file can be added.</p> Source code in <code>rompy_ww3/namelists/slope.py</code> <pre><code>class Slope(NamelistBaseModel):\n    \"\"\"SLOPE_NML namelist for WW3.\n\n    The SLOPE_NML namelist defines the reflection slope map for WAVEWATCH III grids.\n    This map is used only if &amp;REF1 REFMAP = 2 is defined in param.nml.\n\n    The reflection slope values represent the characteristics of coastal slopes that \n    affect wave reflection and dissipation. The scale factor converts the input values \n    to the appropriate slope values needed by WW3's reflection calculations.\n\n    In the case of unstructured grids, no reflection slope file can be added.\n    \"\"\"\n\n    sf: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scale factor to apply to slope values from the input file. \"\n            \"The final slope value is calculated as: value = value_read * scale_factor. \"\n            \"This factor is used to convert the values from the input file to appropriate \"\n            \"slope values for WW3's reflection calculations.\"\n        )\n    )\n    filename: Optional[Union[str, WW3DataBlob]] = Field(\n        default=None,\n        description=(\n            \"Filename or data blob containing the reflection slope data for the grid. This file should contain \"\n            \"the slope values in the format specified by the idfm and format parameters.\"\n        )\n    )\n    idf: Optional[int] = Field(\n        default=None,\n        description=(\n            \"File unit number for the slope file. Each file in WW3 is assigned a unique \"\n            \"unit number to distinguish between different input files during processing.\"\n        ),\n        ge=1  # Must be positive file unit number\n    )\n    idla: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Layout indicator for reading slope data:\\n\"\n            \"  1: Read line-by-line from bottom to top (default)\\n\"\n            \"  2: Like 1, but with a single read statement\\n\"\n            \"  3: Read line-by-line from top to bottom\\n\"\n            \"  4: Like 3, but with a single read statement\"\n        ),\n        ge=1,\n        le=4\n    )\n    idfm: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Format indicator for reading slope data:\\n\"\n            \"  1: Free format (default)\\n\"\n            \"  2: Fixed format\\n\"\n            \"  3: Unformatted\"\n        ),\n        ge=1,\n        le=3\n    )\n    format: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Formatted read format specification, like '(f10.6)' for float type. \"\n            \"Use '(....)' for auto detection of the format. This specifies how the \"\n            \"slope values should be read from the file.\"\n        )\n    )\n\n    @field_validator('sf')\n    @classmethod\n    def validate_scale_factor(cls, v):\n        \"\"\"Validate scale factor is not zero.\"\"\"\n        if v is not None:\n            if v == 0:\n                raise ValueError(f\"Scale factor must not be zero, got {v}\")\n        return v\n\n    @field_validator('idf')\n    @classmethod\n    def validate_file_unit(cls, v):\n        \"\"\"Validate file unit number.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"File unit number must be positive, got {v}\")\n        return v\n\n    @field_validator('idla')\n    @classmethod\n    def validate_idla(cls, v):\n        \"\"\"Validate layout indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n        return v\n\n    @field_validator('idfm')\n    @classmethod\n    def validate_idfm(cls, v):\n        \"\"\"Validate format indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3]:\n            raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.sf","title":"sf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sf: Optional[float] = Field(default=None, description=\"Scale factor to apply to slope values from the input file. The final slope value is calculated as: value = value_read * scale_factor. This factor is used to convert the values from the input file to appropriate slope values for WW3's reflection calculations.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.filename","title":"filename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filename: Optional[Union[str, WW3DataBlob]] = Field(default=None, description='Filename or data blob containing the reflection slope data for the grid. This file should contain the slope values in the format specified by the idfm and format parameters.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.idf","title":"idf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idf: Optional[int] = Field(default=None, description='File unit number for the slope file. Each file in WW3 is assigned a unique unit number to distinguish between different input files during processing.', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[int] = Field(default=None, description='Layout indicator for reading slope data:\\n  1: Read line-by-line from bottom to top (default)\\n  2: Like 1, but with a single read statement\\n  3: Read line-by-line from top to bottom\\n  4: Like 3, but with a single read statement', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.idfm","title":"idfm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idfm: Optional[int] = Field(default=None, description='Format indicator for reading slope data:\\n  1: Free format (default)\\n  2: Fixed format\\n  3: Unformatted', ge=1, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[str] = Field(default=None, description=\"Formatted read format specification, like '(f10.6)' for float type. Use '(....)' for auto detection of the format. This specifies how the slope values should be read from the file.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.validate_scale_factor","title":"validate_scale_factor  <code>classmethod</code>","text":"<pre><code>validate_scale_factor(v)\n</code></pre> <p>Validate scale factor is not zero.</p> Source code in <code>rompy_ww3/namelists/slope.py</code> <pre><code>@field_validator('sf')\n@classmethod\ndef validate_scale_factor(cls, v):\n    \"\"\"Validate scale factor is not zero.\"\"\"\n    if v is not None:\n        if v == 0:\n            raise ValueError(f\"Scale factor must not be zero, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.validate_file_unit","title":"validate_file_unit  <code>classmethod</code>","text":"<pre><code>validate_file_unit(v)\n</code></pre> <p>Validate file unit number.</p> Source code in <code>rompy_ww3/namelists/slope.py</code> <pre><code>@field_validator('idf')\n@classmethod\ndef validate_file_unit(cls, v):\n    \"\"\"Validate file unit number.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"File unit number must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(v)\n</code></pre> <p>Validate layout indicator.</p> Source code in <code>rompy_ww3/namelists/slope.py</code> <pre><code>@field_validator('idla')\n@classmethod\ndef validate_idla(cls, v):\n    \"\"\"Validate layout indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.slope.Slope.validate_idfm","title":"validate_idfm  <code>classmethod</code>","text":"<pre><code>validate_idfm(v)\n</code></pre> <p>Validate format indicator.</p> Source code in <code>rompy_ww3/namelists/slope.py</code> <pre><code>@field_validator('idfm')\n@classmethod\ndef validate_idfm(cls, v):\n    \"\"\"Validate format indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3]:\n        raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#sediment-namelist","title":"Sediment Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment","title":"Sediment","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>SED_NML namelist for WW3.</p> <p>The SED_NML namelist defines the sedimentary bottom map for WAVEWATCH III grids. This map is used only if &amp;SBT4 SEDMAPD50 = T is defined in param.nml.</p> <p>The sediment values represent the median grain size (D50) of the sediment, which affects bottom friction and wave dissipation. The scale factor converts the input  values to the appropriate sediment values needed by WW3's sediment calculations.</p> <p>In the case of unstructured grids, no sedimentary bottom file can be added.</p> Source code in <code>rompy_ww3/namelists/sediment.py</code> <pre><code>class Sediment(NamelistBaseModel):\n    \"\"\"SED_NML namelist for WW3.\n\n    The SED_NML namelist defines the sedimentary bottom map for WAVEWATCH III grids.\n    This map is used only if &amp;SBT4 SEDMAPD50 = T is defined in param.nml.\n\n    The sediment values represent the median grain size (D50) of the sediment, which\n    affects bottom friction and wave dissipation. The scale factor converts the input \n    values to the appropriate sediment values needed by WW3's sediment calculations.\n\n    In the case of unstructured grids, no sedimentary bottom file can be added.\n    \"\"\"\n\n    sf: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Scale factor to apply to sediment values from the input file. \"\n            \"The final sediment value is calculated as: value = value_read * scale_factor. \"\n            \"This factor is used to convert the values from the input file to appropriate \"\n            \"sediment values (typically median grain size in mm) for WW3's sediment calculations.\"\n        )\n    )\n    filename: Optional[Union[str, WW3DataBlob]] = Field(\n        default=None,\n        description=(\n            \"Filename or data blob containing the sedimentary bottom data for the grid. This file should contain \"\n            \"the sediment median grain size (D50) values in the format specified by the idfm and format parameters.\"\n        )\n    )\n    idf: Optional[int] = Field(\n        default=None,\n        description=(\n            \"File unit number for the sediment file. Each file in WW3 is assigned a unique \"\n            \"unit number to distinguish between different input files during processing.\"\n        ),\n        ge=1  # Must be positive file unit number\n    )\n    idla: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Layout indicator for reading sediment data:\\n\"\n            \"  1: Read line-by-line from bottom to top (default)\\n\"\n            \"  2: Like 1, but with a single read statement\\n\"\n            \"  3: Read line-by-line from top to bottom\\n\"\n            \"  4: Like 3, but with a single read statement\"\n        ),\n        ge=1,\n        le=4\n    )\n    idfm: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Format indicator for reading sediment data:\\n\"\n            \"  1: Free format (default)\\n\"\n            \"  2: Fixed format\\n\"\n            \"  3: Unformatted\"\n        ),\n        ge=1,\n        le=3\n    )\n    format: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Formatted read format specification, like '(f10.6)' for float type. \"\n            \"Use '(....)' for auto detection of the format. This specifies how the \"\n            \"sediment values should be read from the file.\"\n        )\n    )\n\n    @field_validator('sf')\n    @classmethod\n    def validate_scale_factor(cls, v):\n        \"\"\"Validate scale factor is not zero.\"\"\"\n        if v is not None:\n            if v == 0:\n                raise ValueError(f\"Scale factor must not be zero, got {v}\")\n        return v\n\n    @field_validator('idf')\n    @classmethod\n    def validate_file_unit(cls, v):\n        \"\"\"Validate file unit number.\"\"\"\n        if v is not None:\n            if v &lt;= 0:\n                raise ValueError(f\"File unit number must be positive, got {v}\")\n        return v\n\n    @field_validator('idla')\n    @classmethod\n    def validate_idla(cls, v):\n        \"\"\"Validate layout indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n        return v\n\n    @field_validator('idfm')\n    @classmethod\n    def validate_idfm(cls, v):\n        \"\"\"Validate format indicator.\"\"\"\n        if v is not None and v not in [1, 2, 3]:\n            raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.sf","title":"sf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sf: Optional[float] = Field(default=None, description=\"Scale factor to apply to sediment values from the input file. The final sediment value is calculated as: value = value_read * scale_factor. This factor is used to convert the values from the input file to appropriate sediment values (typically median grain size in mm) for WW3's sediment calculations.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.filename","title":"filename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filename: Optional[Union[str, WW3DataBlob]] = Field(default=None, description='Filename or data blob containing the sedimentary bottom data for the grid. This file should contain the sediment median grain size (D50) values in the format specified by the idfm and format parameters.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.idf","title":"idf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idf: Optional[int] = Field(default=None, description='File unit number for the sediment file. Each file in WW3 is assigned a unique unit number to distinguish between different input files during processing.', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.idla","title":"idla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idla: Optional[int] = Field(default=None, description='Layout indicator for reading sediment data:\\n  1: Read line-by-line from bottom to top (default)\\n  2: Like 1, but with a single read statement\\n  3: Read line-by-line from top to bottom\\n  4: Like 3, but with a single read statement', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.idfm","title":"idfm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idfm: Optional[int] = Field(default=None, description='Format indicator for reading sediment data:\\n  1: Free format (default)\\n  2: Fixed format\\n  3: Unformatted', ge=1, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: Optional[str] = Field(default=None, description=\"Formatted read format specification, like '(f10.6)' for float type. Use '(....)' for auto detection of the format. This specifies how the sediment values should be read from the file.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.validate_scale_factor","title":"validate_scale_factor  <code>classmethod</code>","text":"<pre><code>validate_scale_factor(v)\n</code></pre> <p>Validate scale factor is not zero.</p> Source code in <code>rompy_ww3/namelists/sediment.py</code> <pre><code>@field_validator('sf')\n@classmethod\ndef validate_scale_factor(cls, v):\n    \"\"\"Validate scale factor is not zero.\"\"\"\n    if v is not None:\n        if v == 0:\n            raise ValueError(f\"Scale factor must not be zero, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.validate_file_unit","title":"validate_file_unit  <code>classmethod</code>","text":"<pre><code>validate_file_unit(v)\n</code></pre> <p>Validate file unit number.</p> Source code in <code>rompy_ww3/namelists/sediment.py</code> <pre><code>@field_validator('idf')\n@classmethod\ndef validate_file_unit(cls, v):\n    \"\"\"Validate file unit number.\"\"\"\n    if v is not None:\n        if v &lt;= 0:\n            raise ValueError(f\"File unit number must be positive, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.validate_idla","title":"validate_idla  <code>classmethod</code>","text":"<pre><code>validate_idla(v)\n</code></pre> <p>Validate layout indicator.</p> Source code in <code>rompy_ww3/namelists/sediment.py</code> <pre><code>@field_validator('idla')\n@classmethod\ndef validate_idla(cls, v):\n    \"\"\"Validate layout indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Layout indicator (idla) must be between 1 and 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.sediment.Sediment.validate_idfm","title":"validate_idfm  <code>classmethod</code>","text":"<pre><code>validate_idfm(v)\n</code></pre> <p>Validate format indicator.</p> Source code in <code>rompy_ww3/namelists/sediment.py</code> <pre><code>@field_validator('idfm')\n@classmethod\ndef validate_idfm(cls, v):\n    \"\"\"Validate format indicator.\"\"\"\n    if v is not None and v not in [1, 2, 3]:\n        raise ValueError(f\"Format indicator (idfm) must be 1, 2, or 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#forcing-namelist","title":"Forcing Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing","title":"Forcing","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>FORCING_NML namelist for WW3.</p> <p>Defines the forcing fields to preprocess.</p> Source code in <code>rompy_ww3/namelists/forcing.py</code> <pre><code>class Forcing(NamelistBaseModel):\n    \"\"\"FORCING_NML namelist for WW3.\n\n    Defines the forcing fields to preprocess.\n    \"\"\"\n\n    timestart: Optional[str] = Field(\n        default=None, description=\"Start date for the forcing field (yyyymmdd hhmmss)\"\n    )\n    timestop: Optional[str] = Field(\n        default=None, description=\"Stop date for the forcing field (yyyymmdd hhmmss)\"\n    )\n    field: Optional[ForcingField] = Field(\n        default=None, description=\"Forcing field parameters\"\n    )\n    grid: Optional[ForcingGrid] = Field(\n        default_factory=ForcingGrid, description=\"Forcing grid parameters\"\n    )\n    tidal: Optional[str] = Field(\n        default=None, description=\"Tidal constituents [FAST | VFAST | 'M2 S2 N2']\"\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_tidal_requirements(self):\n        \"\"\"Ensure tidal is only available on grid%asis with FIELD%level or FIELD%current.\"\"\"\n        if self.tidal is not None:\n            # Check if grid.asis is True (if grid is defined)\n            if self.grid is not None and self.grid.asis is not True:\n                raise ValueError(\n                    \"Tidal constituents are only available with grid%asis set to True\"\n                )\n\n            # Check if field.water_levels (level) or field.currents is True (if field is defined)\n            if self.field is not None:\n                level_or_current_set = (self.field.water_levels is True) or (\n                    self.field.currents is True\n                )\n                if not level_or_current_set:\n                    raise ValueError(\n                        \"Tidal constituents are only available with FIELD%level or FIELD%current\"\n                    )\n\n            # If field is None, it's an error because we need at least one of level or current\n            if self.field is None:\n                raise ValueError(\n                    \"Tidal constituents require field to be defined with level or current\"\n                )\n\n        return self\n\n    @property\n    def ww3_var_name(self) -&gt; Optional[str]:\n        \"\"\"Get the WW3 variable name from the FORCING%FIELD.\"\"\"\n        if self.field is not None:\n            return self.field.ww3_var_name\n        return None\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing.timestart","title":"timestart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestart: Optional[str] = Field(default=None, description='Start date for the forcing field (yyyymmdd hhmmss)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing.timestop","title":"timestop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestop: Optional[str] = Field(default=None, description='Stop date for the forcing field (yyyymmdd hhmmss)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing.field","title":"field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field: Optional[ForcingField] = Field(default=None, description='Forcing field parameters')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: Optional[ForcingGrid] = Field(default_factory=ForcingGrid, description='Forcing grid parameters')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing.tidal","title":"tidal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tidal: Optional[str] = Field(default=None, description=\"Tidal constituents [FAST | VFAST | 'M2 S2 N2']\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing.ww3_var_name","title":"ww3_var_name  <code>property</code>","text":"<pre><code>ww3_var_name: Optional[str]\n</code></pre> <p>Get the WW3 variable name from the FORCING%FIELD.</p>"},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.forcing.Forcing.validate_tidal_requirements","title":"validate_tidal_requirements","text":"<pre><code>validate_tidal_requirements()\n</code></pre> <p>Ensure tidal is only available on grid%asis with FIELD%level or FIELD%current.</p> Source code in <code>rompy_ww3/namelists/forcing.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_tidal_requirements(self):\n    \"\"\"Ensure tidal is only available on grid%asis with FIELD%level or FIELD%current.\"\"\"\n    if self.tidal is not None:\n        # Check if grid.asis is True (if grid is defined)\n        if self.grid is not None and self.grid.asis is not True:\n            raise ValueError(\n                \"Tidal constituents are only available with grid%asis set to True\"\n            )\n\n        # Check if field.water_levels (level) or field.currents is True (if field is defined)\n        if self.field is not None:\n            level_or_current_set = (self.field.water_levels is True) or (\n                self.field.currents is True\n            )\n            if not level_or_current_set:\n                raise ValueError(\n                    \"Tidal constituents are only available with FIELD%level or FIELD%current\"\n                )\n\n        # If field is None, it's an error because we need at least one of level or current\n        if self.field is None:\n            raise ValueError(\n                \"Tidal constituents require field to be defined with level or current\"\n            )\n\n    return self\n</code></pre>"},{"location":"reference/namelists/#file-namelist","title":"File Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.file.File","title":"File","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>FILE_NML namelist for WW3 preprocessing.</p> <p>The FILE_NML namelist defines the content and structure of the input file for WW3 preprocessing (ww3_prnc). The input file must respect netCDF format and CF conventions with specific requirements:</p> <p>Required netCDF structure: - Dimensions: time (expected to be called 'time') - Dimensions: longitude/latitude (names can be defined in the namelist) - Variable: time defined along time dimension with:   - attribute 'units' in ISO8601 convention   - attribute 'calendar' set to 'standard' as per CF convention - Variable: longitude defined along longitude dimension - Variable: latitude defined along latitude dimension - Variable: field defined along time,latitude,longitude dimensions</p> <p>FILE%VAR(I) must be set for each field component where I is 1, 2, or 3 depending on the number of components. For example: - Single component: FILE%VAR(1) only - Two components: FILE%VAR(1), FILE%VAR(2) - Three components: FILE%VAR(1), FILE%VAR(2), FILE%VAR(3)</p> <p>The TIMESHIFT parameter shifts the time value to 'YYYYMMDD HHMMSS' format.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>class File(NamelistBaseModel):\n    \"\"\"FILE_NML namelist for WW3 preprocessing.\n\n    The FILE_NML namelist defines the content and structure of the input file for WW3 preprocessing (ww3_prnc).\n    The input file must respect netCDF format and CF conventions with specific requirements:\n\n    Required netCDF structure:\n    - Dimensions: time (expected to be called 'time')\n    - Dimensions: longitude/latitude (names can be defined in the namelist)\n    - Variable: time defined along time dimension with:\n      - attribute 'units' in ISO8601 convention\n      - attribute 'calendar' set to 'standard' as per CF convention\n    - Variable: longitude defined along longitude dimension\n    - Variable: latitude defined along latitude dimension\n    - Variable: field defined along time,latitude,longitude dimensions\n\n    FILE%VAR(I) must be set for each field component where I is 1, 2, or 3 depending on the number of components.\n    For example:\n    - Single component: FILE%VAR(1) only\n    - Two components: FILE%VAR(1), FILE%VAR(2)\n    - Three components: FILE%VAR(1), FILE%VAR(2), FILE%VAR(3)\n\n    The TIMESHIFT parameter shifts the time value to 'YYYYMMDD HHMMSS' format.\n    \"\"\"\n\n    filename: Optional[Union[str, WW3DataBlob, WW3DataGrid]] = Field(\n        default=None,\n        description=(\n            \"Input filename, WW3DataBlob, or WW3DataGrid for preprocessing. \"\n            \"The input file must respect netCDF format and CF conventions. \"\n            \"The file must contain properly formatted time, longitude/latitude, and field variables.\"\n        )\n    )\n    longitude: Optional[str] = Field(\n        default=\"longitude\",\n        description=(\n            \"Longitude/x dimension name in the input file. This specifies the name of the \"\n            \"longitude or x-coordinate variable in the netCDF file. Common names include \"\n            \"'longitude', 'lon', 'x', etc. If WW3DataGrid is used, this will be automatically set.\"\n        )\n    )\n    latitude: Optional[str] = Field(\n        default=\"latitude\",\n        description=(\n            \"Latitude/y dimension name in the input file. This specifies the name of the \"\n            \"latitude or y-coordinate variable in the netCDF file. Common names include \"\n            \"'latitude', 'lat', 'y', etc. If WW3DataGrid is used, this will be automatically set.\"\n        )\n    )\n    var1: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Variable name for the first component of the field. This specifies the name of the \"\n            \"first component variable in the netCDF file. For example, 'U' for the U-component \"\n            \"of wind or current fields. This is required for single, double, or triple component fields.\"\n        )\n    )\n    var2: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Variable name for the second component of the field. This specifies the name of the \"\n            \"second component variable in the netCDF file. For example, 'V' for the V-component \"\n            \"of wind or current fields. This is required for double or triple component fields.\"\n        )\n    )\n    var3: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Variable name for the third component of the field. This specifies the name of the \"\n            \"third component variable in the netCDF file. For example, for air-sea temperature \"\n            \"difference. This is required only for triple component fields.\"\n        )\n    )\n\n    @field_validator('filename')\n    @classmethod\n    def validate_filename(cls, v):\n        \"\"\"Validate filename is not empty if provided.\"\"\"\n        if v is not None:\n            if isinstance(v, str) and v.strip() == \"\":\n                raise ValueError(\"Filename cannot be empty\")\n        return v\n\n    @field_validator('longitude', 'latitude')\n    @classmethod\n    def validate_dimension_names(cls, v):\n        \"\"\"Validate dimension names are not empty.\"\"\"\n        if v is not None and v.strip() == \"\":\n            raise ValueError(\"Dimension names cannot be empty\")\n        return v\n\n    @field_validator('var1', 'var2', 'var3')\n    @classmethod\n    def validate_variable_names(cls, v):\n        \"\"\"Validate variable names are not empty.\"\"\"\n        if v is not None and v.strip() == \"\":\n            raise ValueError(\"Variable names cannot be empty\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def set_latlon(self):\n        \"\"\"Ensure latitude and longitude are consistent with WW3DataGrid coords.\"\"\"\n        if isinstance(self.filename, WW3DataGrid):\n            if self.longitude is None:\n                self.longitude = self.filename.coords.x\n            if self.latitude is None:\n                self.latitude = self.filename.coords.y\n        return self\n\n    @model_validator(mode=\"after\")\n    def set_vars(self):\n        \"\"\"Ensure variables are consistent with WW3DataGrid.\"\"\"\n        if isinstance(self.filename, WW3DataGrid):\n            if self.filename.variables:\n                if self.var1 or self.var2 or self.var3:  # Fixed typo: was self.var1 or self.var1 or self.var3\n                    logger.warning(\n                        \"Variables set in WW3DataGrid and File. File takes preference\"\n                    )\n                    self.filename.variables = [\n                        getattr(self, var)\n                        for var in [\"var1\", \"var2\", \"var3\"]\n                        if getattr(self, var)\n                    ]\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_component_consistency(self):\n        \"\"\"Ensure component variable specifications are logically consistent.\"\"\"\n        # For 2-component fields (e.g., currents, winds), both var1 and var2 should be specified\n        # For 3-component fields (e.g., winds with air-sea temp diff), all three should be specified\n        # For 1-component fields, only var1 should be specified\n\n        if self.var1 is not None and self.var2 is None and self.var3 is None:\n            # Single component: OK\n            pass\n        elif self.var1 is not None and self.var2 is not None and self.var3 is None:\n            # Two components: OK\n            pass\n        elif self.var1 is not None and self.var2 is not None and self.var3 is not None:\n            # Three components: OK\n            pass\n        elif self.var1 is None:\n            # var1 is None but others may be set - this is an error\n            if self.var2 is not None or self.var3 is not None:\n                raise ValueError(\"var1 must be specified if var2 or var3 is specified\")\n\n        return self\n\n    def get_namelist_name(self) -&gt; str:\n        \"\"\"Return the specific namelist name for FILE_NML.\"\"\"\n        return \"FILE_NML\"\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.filename","title":"filename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filename: Optional[Union[str, WW3DataBlob, WW3DataGrid]] = Field(default=None, description='Input filename, WW3DataBlob, or WW3DataGrid for preprocessing. The input file must respect netCDF format and CF conventions. The file must contain properly formatted time, longitude/latitude, and field variables.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: Optional[str] = Field(default='longitude', description=\"Longitude/x dimension name in the input file. This specifies the name of the longitude or x-coordinate variable in the netCDF file. Common names include 'longitude', 'lon', 'x', etc. If WW3DataGrid is used, this will be automatically set.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: Optional[str] = Field(default='latitude', description=\"Latitude/y dimension name in the input file. This specifies the name of the latitude or y-coordinate variable in the netCDF file. Common names include 'latitude', 'lat', 'y', etc. If WW3DataGrid is used, this will be automatically set.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.var1","title":"var1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>var1: Optional[str] = Field(default=None, description=\"Variable name for the first component of the field. This specifies the name of the first component variable in the netCDF file. For example, 'U' for the U-component of wind or current fields. This is required for single, double, or triple component fields.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.var2","title":"var2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>var2: Optional[str] = Field(default=None, description=\"Variable name for the second component of the field. This specifies the name of the second component variable in the netCDF file. For example, 'V' for the V-component of wind or current fields. This is required for double or triple component fields.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.var3","title":"var3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>var3: Optional[str] = Field(default=None, description='Variable name for the third component of the field. This specifies the name of the third component variable in the netCDF file. For example, for air-sea temperature difference. This is required only for triple component fields.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.validate_filename","title":"validate_filename  <code>classmethod</code>","text":"<pre><code>validate_filename(v)\n</code></pre> <p>Validate filename is not empty if provided.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>@field_validator('filename')\n@classmethod\ndef validate_filename(cls, v):\n    \"\"\"Validate filename is not empty if provided.\"\"\"\n    if v is not None:\n        if isinstance(v, str) and v.strip() == \"\":\n            raise ValueError(\"Filename cannot be empty\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.validate_dimension_names","title":"validate_dimension_names  <code>classmethod</code>","text":"<pre><code>validate_dimension_names(v)\n</code></pre> <p>Validate dimension names are not empty.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>@field_validator('longitude', 'latitude')\n@classmethod\ndef validate_dimension_names(cls, v):\n    \"\"\"Validate dimension names are not empty.\"\"\"\n    if v is not None and v.strip() == \"\":\n        raise ValueError(\"Dimension names cannot be empty\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.validate_variable_names","title":"validate_variable_names  <code>classmethod</code>","text":"<pre><code>validate_variable_names(v)\n</code></pre> <p>Validate variable names are not empty.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>@field_validator('var1', 'var2', 'var3')\n@classmethod\ndef validate_variable_names(cls, v):\n    \"\"\"Validate variable names are not empty.\"\"\"\n    if v is not None and v.strip() == \"\":\n        raise ValueError(\"Variable names cannot be empty\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.set_latlon","title":"set_latlon","text":"<pre><code>set_latlon()\n</code></pre> <p>Ensure latitude and longitude are consistent with WW3DataGrid coords.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_latlon(self):\n    \"\"\"Ensure latitude and longitude are consistent with WW3DataGrid coords.\"\"\"\n    if isinstance(self.filename, WW3DataGrid):\n        if self.longitude is None:\n            self.longitude = self.filename.coords.x\n        if self.latitude is None:\n            self.latitude = self.filename.coords.y\n    return self\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.set_vars","title":"set_vars","text":"<pre><code>set_vars()\n</code></pre> <p>Ensure variables are consistent with WW3DataGrid.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_vars(self):\n    \"\"\"Ensure variables are consistent with WW3DataGrid.\"\"\"\n    if isinstance(self.filename, WW3DataGrid):\n        if self.filename.variables:\n            if self.var1 or self.var2 or self.var3:  # Fixed typo: was self.var1 or self.var1 or self.var3\n                logger.warning(\n                    \"Variables set in WW3DataGrid and File. File takes preference\"\n                )\n                self.filename.variables = [\n                    getattr(self, var)\n                    for var in [\"var1\", \"var2\", \"var3\"]\n                    if getattr(self, var)\n                ]\n    return self\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.validate_component_consistency","title":"validate_component_consistency","text":"<pre><code>validate_component_consistency()\n</code></pre> <p>Ensure component variable specifications are logically consistent.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_component_consistency(self):\n    \"\"\"Ensure component variable specifications are logically consistent.\"\"\"\n    # For 2-component fields (e.g., currents, winds), both var1 and var2 should be specified\n    # For 3-component fields (e.g., winds with air-sea temp diff), all three should be specified\n    # For 1-component fields, only var1 should be specified\n\n    if self.var1 is not None and self.var2 is None and self.var3 is None:\n        # Single component: OK\n        pass\n    elif self.var1 is not None and self.var2 is not None and self.var3 is None:\n        # Two components: OK\n        pass\n    elif self.var1 is not None and self.var2 is not None and self.var3 is not None:\n        # Three components: OK\n        pass\n    elif self.var1 is None:\n        # var1 is None but others may be set - this is an error\n        if self.var2 is not None or self.var3 is not None:\n            raise ValueError(\"var1 must be specified if var2 or var3 is specified\")\n\n    return self\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.file.File.get_namelist_name","title":"get_namelist_name","text":"<pre><code>get_namelist_name() -&gt; str\n</code></pre> <p>Return the specific namelist name for FILE_NML.</p> Source code in <code>rompy_ww3/namelists/file.py</code> <pre><code>def get_namelist_name(self) -&gt; str:\n    \"\"\"Return the specific namelist name for FILE_NML.\"\"\"\n    return \"FILE_NML\"\n</code></pre>"},{"location":"reference/namelists/#bound-namelist","title":"Bound Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound","title":"Bound","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>BOUND_NML namelist for WW3.</p> <p>The BOUND_NML namelist defines the input boundaries for preprocessing in WAVEWATCH III. This namelist is used by the ww3_bounc program to handle boundary data.</p> <p>This namelist controls how boundary conditions are read from or written to files, including interpolation methods and verbosity of output.</p> Source code in <code>rompy_ww3/namelists/bound.py</code> <pre><code>class Bound(NamelistBaseModel):\n    \"\"\"BOUND_NML namelist for WW3.\n\n    The BOUND_NML namelist defines the input boundaries for preprocessing in WAVEWATCH III.\n    This namelist is used by the ww3_bounc program to handle boundary data.\n\n    This namelist controls how boundary conditions are read from or written to files,\n    including interpolation methods and verbosity of output.\n    \"\"\"\n\n    mode: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Processing mode for boundary data:\\n\"\n            \"  'WRITE': Write boundary data to output files\\n\"\n            \"  'READ': Read boundary data from input files\\n\"\n            \"This determines the direction of data flow for boundary processing.\"\n        )\n    )\n    interp: Optional[int] = Field(\n        default=2,\n        description=(\n            \"Interpolation method for boundary data:\\n\"\n            \"  1: Nearest neighbor interpolation\\n\"\n            \"  2: Linear interpolation (default)\\n\"\n            \"This controls how boundary data is interpolated when necessary.\"\n        ),\n        ge=1,\n        le=2\n    )\n    verbose: Optional[int] = Field(\n        default=1,\n        description=(\n            \"Verbosity level for boundary processing output:\\n\"\n            \"  0: Minimal output\\n\"\n            \"  1: Standard output (default)\\n\"\n            \"  2: Detailed output\\n\"\n            \"This controls the level of detail in the processing logs.\"\n        ),\n        ge=0,\n        le=2\n    )\n    file: Optional[Union[str, WW3DataBlob, WW3Boundary]] = Field(\n        default=None,\n        description=(\n            \"Input/output file specification containing boundary data. \"\n            \"This can be a string path, WW3DataBlob, or WW3Boundary object \"\n            \"containing the boundary conditions in netCDF format (typically spec.nc).\"\n        )\n    )\n\n    @field_validator('mode')\n    @classmethod\n    def validate_mode(cls, v):\n        \"\"\"Validate mode is either 'WRITE' or 'READ'.\"\"\"\n        if v is not None:\n            valid_modes = {'WRITE', 'READ', 'write', 'read'}\n            if v.upper() not in valid_modes:\n                raise ValueError(f\"Mode must be 'WRITE' or 'READ', got {v}\")\n        return v.upper() if v is not None else v\n\n    @field_validator('interp')\n    @classmethod\n    def validate_interp(cls, v):\n        \"\"\"Validate interpolation method.\"\"\"\n        if v is not None:\n            if v not in [1, 2]:\n                raise ValueError(f\"Interpolation method must be 1 (nearest) or 2 (linear), got {v}\")\n        return v\n\n    @field_validator('verbose')\n    @classmethod\n    def validate_verbose(cls, v):\n        \"\"\"Validate verbosity level.\"\"\"\n        if v is not None:\n            if v not in [0, 1, 2]:\n                raise ValueError(f\"Verbosity level must be 0, 1, or 2, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Optional[str] = Field(default=None, description=\"Processing mode for boundary data:\\n  'WRITE': Write boundary data to output files\\n  'READ': Read boundary data from input files\\nThis determines the direction of data flow for boundary processing.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound.interp","title":"interp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interp: Optional[int] = Field(default=2, description='Interpolation method for boundary data:\\n  1: Nearest neighbor interpolation\\n  2: Linear interpolation (default)\\nThis controls how boundary data is interpolated when necessary.', ge=1, le=2)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound.verbose","title":"verbose  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verbose: Optional[int] = Field(default=1, description='Verbosity level for boundary processing output:\\n  0: Minimal output\\n  1: Standard output (default)\\n  2: Detailed output\\nThis controls the level of detail in the processing logs.', ge=0, le=2)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Optional[Union[str, WW3DataBlob, WW3Boundary]] = Field(default=None, description='Input/output file specification containing boundary data. This can be a string path, WW3DataBlob, or WW3Boundary object containing the boundary conditions in netCDF format (typically spec.nc).')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound.validate_mode","title":"validate_mode  <code>classmethod</code>","text":"<pre><code>validate_mode(v)\n</code></pre> <p>Validate mode is either 'WRITE' or 'READ'.</p> Source code in <code>rompy_ww3/namelists/bound.py</code> <pre><code>@field_validator('mode')\n@classmethod\ndef validate_mode(cls, v):\n    \"\"\"Validate mode is either 'WRITE' or 'READ'.\"\"\"\n    if v is not None:\n        valid_modes = {'WRITE', 'READ', 'write', 'read'}\n        if v.upper() not in valid_modes:\n            raise ValueError(f\"Mode must be 'WRITE' or 'READ', got {v}\")\n    return v.upper() if v is not None else v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound.validate_interp","title":"validate_interp  <code>classmethod</code>","text":"<pre><code>validate_interp(v)\n</code></pre> <p>Validate interpolation method.</p> Source code in <code>rompy_ww3/namelists/bound.py</code> <pre><code>@field_validator('interp')\n@classmethod\ndef validate_interp(cls, v):\n    \"\"\"Validate interpolation method.\"\"\"\n    if v is not None:\n        if v not in [1, 2]:\n            raise ValueError(f\"Interpolation method must be 1 (nearest) or 2 (linear), got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.bound.Bound.validate_verbose","title":"validate_verbose  <code>classmethod</code>","text":"<pre><code>validate_verbose(v)\n</code></pre> <p>Validate verbosity level.</p> Source code in <code>rompy_ww3/namelists/bound.py</code> <pre><code>@field_validator('verbose')\n@classmethod\ndef validate_verbose(cls, v):\n    \"\"\"Validate verbosity level.\"\"\"\n    if v is not None:\n        if v not in [0, 1, 2]:\n            raise ValueError(f\"Verbosity level must be 0, 1, or 2, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#track-namelist","title":"Track Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track","title":"Track","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>TRACK_NML namelist for WW3.</p> <p>The TRACK_NML namelist defines the track output configuration for WAVEWATCH III. This namelist sets up the temporal parameters for track output processing.</p> <p>Track output is used to generate output for specific tracks or trajectories  rather than regular grid points or points specified in a file.</p> Source code in <code>rompy_ww3/namelists/track.py</code> <pre><code>class Track(NamelistBaseModel):\n    \"\"\"TRACK_NML namelist for WW3.\n\n    The TRACK_NML namelist defines the track output configuration for WAVEWATCH III.\n    This namelist sets up the temporal parameters for track output processing.\n\n    Track output is used to generate output for specific tracks or trajectories \n    rather than regular grid points or points specified in a file.\n    \"\"\"\n\n    timestart: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Start date for the track output in format 'YYYYMMDD HHMMSS'. \"\n            \"This specifies when to begin writing track output during the simulation. \"\n            \"Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\"\n        )\n    )\n    timestride: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Time stride for the track output in seconds as a string. \"\n            \"This specifies the time interval between track output writes. \"\n            \"Example: '3600' for hourly output, '21600' for 6-hourly output.\"\n        )\n    )\n    timecount: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Number of time steps for the track output as a string. \"\n            \"This specifies the total number of time steps for which track output will be generated. \"\n        )\n    )\n    timesplit: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Time splitting option for output file management:\\n\"\n            \"  4: Yearly splitting\\n\"\n            \"  6: Monthly splitting\\n\"\n            \"  8: Daily splitting\\n\"\n            \"  10: Hourly splitting\\n\"\n            \"This controls how output files are split over time periods.\"\n        ),\n        ge=4,\n        le=10\n    )\n\n    @field_validator('timestart')\n    @classmethod\n    def validate_timestart_format(cls, v):\n        \"\"\"Validate date format for timestart.\"\"\"\n        if v is not None:\n            return validate_date_format(v)\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track.timestart","title":"timestart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestart: Optional[str] = Field(default=None, description=\"Start date for the track output in format 'YYYYMMDD HHMMSS'. This specifies when to begin writing track output during the simulation. Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track.timestride","title":"timestride  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestride: Optional[str] = Field(default=None, description=\"Time stride for the track output in seconds as a string. This specifies the time interval between track output writes. Example: '3600' for hourly output, '21600' for 6-hourly output.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track.timecount","title":"timecount  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timecount: Optional[str] = Field(default=None, description='Number of time steps for the track output as a string. This specifies the total number of time steps for which track output will be generated. ')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track.timesplit","title":"timesplit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timesplit: Optional[int] = Field(default=None, description='Time splitting option for output file management:\\n  4: Yearly splitting\\n  6: Monthly splitting\\n  8: Daily splitting\\n  10: Hourly splitting\\nThis controls how output files are split over time periods.', ge=4, le=10)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.track.Track.validate_timestart_format","title":"validate_timestart_format  <code>classmethod</code>","text":"<pre><code>validate_timestart_format(v)\n</code></pre> <p>Validate date format for timestart.</p> Source code in <code>rompy_ww3/namelists/track.py</code> <pre><code>@field_validator('timestart')\n@classmethod\ndef validate_timestart_format(cls, v):\n    \"\"\"Validate date format for timestart.\"\"\"\n    if v is not None:\n        return validate_date_format(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#field-namelist","title":"Field Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field","title":"Field","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>FIELD_NML namelist for WW3.</p> <p>The FIELD_NML namelist defines the field output configuration for WAVEWATCH III post-processing. This namelist controls how field (gridded) output is generated from the model results.</p> <p>The field output can include various wave parameters like significant wave height,  mean period, direction, etc., and can be written to NetCDF files with various  formatting and temporal options.</p> Source code in <code>rompy_ww3/namelists/field.py</code> <pre><code>class Field(NamelistBaseModel):\n    \"\"\"FIELD_NML namelist for WW3.\n\n    The FIELD_NML namelist defines the field output configuration for WAVEWATCH III post-processing.\n    This namelist controls how field (gridded) output is generated from the model results.\n\n    The field output can include various wave parameters like significant wave height, \n    mean period, direction, etc., and can be written to NetCDF files with various \n    formatting and temporal options.\n    \"\"\"\n\n    timestart: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Start date for the output field in format 'YYYYMMDD HHMMSS'. \"\n            \"This specifies when to begin writing field output during the post-processing. \"\n            \"Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\"\n        )\n    )\n    timestride: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Time stride for the output field in seconds as a string. \"\n            \"This specifies the time interval between field output writes. \"\n            \"Example: '3600' for hourly output, '21600' for 6-hourly output.\"\n        )\n    )\n    timecount: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Number of time steps for the output field as a string. \"\n            \"This specifies the total number of time steps for which field output will be generated. \"\n        )\n    )\n    timesplit: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Time splitting option for output file management:\\n\"\n            \"  0: No date in filename\\n\"\n            \"  4: Yearly splitting\\n\"\n            \"  6: Monthly splitting\\n\"\n            \"  8: Daily splitting\\n\"\n            \"  10: Hourly splitting\\n\"\n            \"This controls how output files are split over time periods.\"\n        ),\n        ge=0,\n        le=10\n    )\n    list: Optional[str] = Field(\n        default=None,\n        description=(\n            \"List of output fields to include in the output file. \"\n            \"This is a space-separated list of parameter names to output, such as: \"\n            \"'HS T02 DIR SPR' for significant wave height, mean period, direction, and spread.\"\n        )\n    )\n    partition: Optional[str] = Field(\n        default=None,\n        description=(\n            \"List of wave partitions to output, specified as a space-separated string. \"\n            \"Examples: '0 1 2 3' for partitions 0-3, '0' for total wave field only. \"\n            \"Partition 0 is the total wave field, partitions 1-N are individual swell partitions.\"\n        )\n    )\n    samefile: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to put all variables in the same file (T) or separate files (F). \"\n            \"When True, all requested output variables are written to a single NetCDF file. \"\n            \"When False, each variable may be written to separate files.\"\n        )\n    )\n    vector: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Vector format [T] or direction/magnitude format [F] for directional fields. \"\n            \"When True, directional fields like currents/winds are output as vector components. \"\n            \"When False, they are output as direction and magnitude separately.\"\n        )\n    )\n    type: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Data type for output variables:\\n\"\n            \"  2: SHORT (16-bit integer)\\n\"\n            \"  3: Depends on the variable type\\n\"\n            \"  4: REAL (32-bit float)\\n\"\n            \"This controls the precision and storage format of the output variables.\"\n        ),\n        ge=2,\n        le=4\n    )\n    fcvars: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to generate auxiliary forecast variables. \"\n            \"When True, additional forecast-related variables are included in the output.\"\n        )\n    )\n    timeref: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Forecast reference time in format 'YYYYMMDD HHMMSS'. \"\n            \"This specifies the reference time for forecast variables in the output. \"\n            \"Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\"\n        )\n    )\n    timevar: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Time variable type for NetCDF encoding:\\n\"\n            \"  'D': DOUBLE precision time variable\\n\"\n            \"  'I': INT64 time variable\\n\"\n            \"This controls the data type of the time coordinate variable in NetCDF output.\"\n        )\n    )\n    timeunit: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Time units for NetCDF encoding:\\n\"\n            \"  'D': Days since epoch\\n\"\n            \"  'S': Seconds since epoch\\n\"\n            \"This controls the units of the time coordinate in the NetCDF output.\"\n        )\n    )\n    timeepoch: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Epoch used for encoding of NetCDF time variables in format 'YYYY-MM-DD HH:MM:SS'. \"\n            \"This specifies the reference date/time for NetCDF time encoding. \"\n            \"Example: '1900-01-01 00:00:00' for the standard 1900 epoch.\"\n        )\n    )\n    noval: Optional[float] = Field(\n        default=None,\n        description=(\n            \"Value to use for wet cells that have an undefined (UNDEF) value. \"\n            \"This is a fill value used in the NetCDF output for cells that are \"\n            \"wet but have no valid data for the specific variable.\"\n        )\n    )\n    mapsta: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to output MAPSTA field in file (T) or not (F). \"\n            \"When True, the MAPSTA field (mapping status) is included in the output file.\"\n        )\n    )\n\n    @field_validator('timestart', 'timeref')\n    @classmethod\n    def validate_time_format(cls, v):\n        \"\"\"Validate date format for time fields.\"\"\"\n        if v is not None:\n            return validate_date_format(v)\n        return v\n\n    @field_validator('timesplit')\n    @classmethod\n    def validate_timesplit(cls, v):\n        \"\"\"Validate timesplit value.\"\"\"\n        if v is not None and v not in [0, 4, 6, 8, 10]:\n            raise ValueError(f\"Time split must be 0, 4, 6, 8, or 10, got {v}\")\n        return v\n\n    @field_validator('type')\n    @classmethod\n    def validate_type(cls, v):\n        \"\"\"Validate type value.\"\"\"\n        if v is not None and v not in [2, 3, 4]:\n            raise ValueError(f\"Type must be 2, 3, or 4, got {v}\")\n        return v\n\n    @field_validator('timevar')\n    @classmethod\n    def validate_timevar(cls, v):\n        \"\"\"Validate timevar value.\"\"\"\n        if v is not None:\n            valid_values = {'D', 'I', 'd', 'i'}\n            if v.upper() not in valid_values:\n                raise ValueError(f\"Timevar must be 'D' or 'I', got {v}\")\n        return v.upper() if v is not None else v\n\n    @field_validator('timeunit')\n    @classmethod\n    def validate_timeunit(cls, v):\n        \"\"\"Validate timeunit value.\"\"\"\n        if v is not None:\n            valid_values = {'D', 'S', 'd', 's'}\n            if v.upper() not in valid_values:\n                raise ValueError(f\"Timeunit must be 'D' or 'S', got {v}\")\n        return v.upper() if v is not None else v  # Use 'S' for seconds, not 'I'\n\n    @field_validator('samefile', 'vector', 'fcvars', 'mapsta')\n    @classmethod\n    def validate_boolean_flags(cls, v):\n        \"\"\"Validate boolean flags are actually boolean.\"\"\"\n        if v is not None and not isinstance(v, bool):\n            raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timestart","title":"timestart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestart: Optional[str] = Field(default=None, description=\"Start date for the output field in format 'YYYYMMDD HHMMSS'. This specifies when to begin writing field output during the post-processing. Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timestride","title":"timestride  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestride: Optional[str] = Field(default=None, description=\"Time stride for the output field in seconds as a string. This specifies the time interval between field output writes. Example: '3600' for hourly output, '21600' for 6-hourly output.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timecount","title":"timecount  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timecount: Optional[str] = Field(default=None, description='Number of time steps for the output field as a string. This specifies the total number of time steps for which field output will be generated. ')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timesplit","title":"timesplit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timesplit: Optional[int] = Field(default=None, description='Time splitting option for output file management:\\n  0: No date in filename\\n  4: Yearly splitting\\n  6: Monthly splitting\\n  8: Daily splitting\\n  10: Hourly splitting\\nThis controls how output files are split over time periods.', ge=0, le=10)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.list","title":"list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>list: Optional[str] = Field(default=None, description=\"List of output fields to include in the output file. This is a space-separated list of parameter names to output, such as: 'HS T02 DIR SPR' for significant wave height, mean period, direction, and spread.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.partition","title":"partition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partition: Optional[str] = Field(default=None, description=\"List of wave partitions to output, specified as a space-separated string. Examples: '0 1 2 3' for partitions 0-3, '0' for total wave field only. Partition 0 is the total wave field, partitions 1-N are individual swell partitions.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.samefile","title":"samefile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>samefile: Optional[bool] = Field(default=None, description='Flag to put all variables in the same file (T) or separate files (F). When True, all requested output variables are written to a single NetCDF file. When False, each variable may be written to separate files.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.vector","title":"vector  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vector: Optional[bool] = Field(default=None, description='Vector format [T] or direction/magnitude format [F] for directional fields. When True, directional fields like currents/winds are output as vector components. When False, they are output as direction and magnitude separately.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Optional[int] = Field(default=None, description='Data type for output variables:\\n  2: SHORT (16-bit integer)\\n  3: Depends on the variable type\\n  4: REAL (32-bit float)\\nThis controls the precision and storage format of the output variables.', ge=2, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.fcvars","title":"fcvars  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fcvars: Optional[bool] = Field(default=None, description='Flag to generate auxiliary forecast variables. When True, additional forecast-related variables are included in the output.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timeref","title":"timeref  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeref: Optional[str] = Field(default=None, description=\"Forecast reference time in format 'YYYYMMDD HHMMSS'. This specifies the reference time for forecast variables in the output. Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timevar","title":"timevar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timevar: Optional[str] = Field(default=None, description=\"Time variable type for NetCDF encoding:\\n  'D': DOUBLE precision time variable\\n  'I': INT64 time variable\\nThis controls the data type of the time coordinate variable in NetCDF output.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timeunit","title":"timeunit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeunit: Optional[str] = Field(default=None, description=\"Time units for NetCDF encoding:\\n  'D': Days since epoch\\n  'S': Seconds since epoch\\nThis controls the units of the time coordinate in the NetCDF output.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.timeepoch","title":"timeepoch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeepoch: Optional[str] = Field(default=None, description=\"Epoch used for encoding of NetCDF time variables in format 'YYYY-MM-DD HH:MM:SS'. This specifies the reference date/time for NetCDF time encoding. Example: '1900-01-01 00:00:00' for the standard 1900 epoch.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.noval","title":"noval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>noval: Optional[float] = Field(default=None, description='Value to use for wet cells that have an undefined (UNDEF) value. This is a fill value used in the NetCDF output for cells that are wet but have no valid data for the specific variable.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.mapsta","title":"mapsta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mapsta: Optional[bool] = Field(default=None, description='Flag to output MAPSTA field in file (T) or not (F). When True, the MAPSTA field (mapping status) is included in the output file.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.validate_time_format","title":"validate_time_format  <code>classmethod</code>","text":"<pre><code>validate_time_format(v)\n</code></pre> <p>Validate date format for time fields.</p> Source code in <code>rompy_ww3/namelists/field.py</code> <pre><code>@field_validator('timestart', 'timeref')\n@classmethod\ndef validate_time_format(cls, v):\n    \"\"\"Validate date format for time fields.\"\"\"\n    if v is not None:\n        return validate_date_format(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.validate_timesplit","title":"validate_timesplit  <code>classmethod</code>","text":"<pre><code>validate_timesplit(v)\n</code></pre> <p>Validate timesplit value.</p> Source code in <code>rompy_ww3/namelists/field.py</code> <pre><code>@field_validator('timesplit')\n@classmethod\ndef validate_timesplit(cls, v):\n    \"\"\"Validate timesplit value.\"\"\"\n    if v is not None and v not in [0, 4, 6, 8, 10]:\n        raise ValueError(f\"Time split must be 0, 4, 6, 8, or 10, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.validate_type","title":"validate_type  <code>classmethod</code>","text":"<pre><code>validate_type(v)\n</code></pre> <p>Validate type value.</p> Source code in <code>rompy_ww3/namelists/field.py</code> <pre><code>@field_validator('type')\n@classmethod\ndef validate_type(cls, v):\n    \"\"\"Validate type value.\"\"\"\n    if v is not None and v not in [2, 3, 4]:\n        raise ValueError(f\"Type must be 2, 3, or 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.validate_timevar","title":"validate_timevar  <code>classmethod</code>","text":"<pre><code>validate_timevar(v)\n</code></pre> <p>Validate timevar value.</p> Source code in <code>rompy_ww3/namelists/field.py</code> <pre><code>@field_validator('timevar')\n@classmethod\ndef validate_timevar(cls, v):\n    \"\"\"Validate timevar value.\"\"\"\n    if v is not None:\n        valid_values = {'D', 'I', 'd', 'i'}\n        if v.upper() not in valid_values:\n            raise ValueError(f\"Timevar must be 'D' or 'I', got {v}\")\n    return v.upper() if v is not None else v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.validate_timeunit","title":"validate_timeunit  <code>classmethod</code>","text":"<pre><code>validate_timeunit(v)\n</code></pre> <p>Validate timeunit value.</p> Source code in <code>rompy_ww3/namelists/field.py</code> <pre><code>@field_validator('timeunit')\n@classmethod\ndef validate_timeunit(cls, v):\n    \"\"\"Validate timeunit value.\"\"\"\n    if v is not None:\n        valid_values = {'D', 'S', 'd', 's'}\n        if v.upper() not in valid_values:\n            raise ValueError(f\"Timeunit must be 'D' or 'S', got {v}\")\n    return v.upper() if v is not None else v  # Use 'S' for seconds, not 'I'\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.field.Field.validate_boolean_flags","title":"validate_boolean_flags  <code>classmethod</code>","text":"<pre><code>validate_boolean_flags(v)\n</code></pre> <p>Validate boolean flags are actually boolean.</p> Source code in <code>rompy_ww3/namelists/field.py</code> <pre><code>@field_validator('samefile', 'vector', 'fcvars', 'mapsta')\n@classmethod\ndef validate_boolean_flags(cls, v):\n    \"\"\"Validate boolean flags are actually boolean.\"\"\"\n    if v is not None and not isinstance(v, bool):\n        raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#point-namelist","title":"Point Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point","title":"Point","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>POINT_NML namelist for WW3.</p> <p>The POINT_NML namelist defines the point output configuration for WAVEWATCH III post-processing. This namelist controls how point output is generated from specific locations in the model domain.</p> <p>Point output can include various wave parameters for specific locations (buoys, stations, etc.) and can be written to NetCDF files with various formatting and temporal options.</p> Source code in <code>rompy_ww3/namelists/point.py</code> <pre><code>class Point(NamelistBaseModel):\n    \"\"\"POINT_NML namelist for WW3.\n\n    The POINT_NML namelist defines the point output configuration for WAVEWATCH III post-processing.\n    This namelist controls how point output is generated from specific locations in the model domain.\n\n    Point output can include various wave parameters for specific locations (buoys, stations, etc.)\n    and can be written to NetCDF files with various formatting and temporal options.\n    \"\"\"\n\n    timestart: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Start date for the point output in format 'YYYYMMDD HHMMSS'. \"\n            \"This specifies when to begin writing point output during the post-processing. \"\n            \"Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\"\n        )\n    )\n    timestride: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Time stride for the point output in seconds as a string. \"\n            \"This specifies the time interval between point output writes. \"\n            \"Example: '3600' for hourly output, '21600' for 6-hourly output.\"\n        )\n    )\n    timecount: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Number of time steps for the point output as a string. \"\n            \"This specifies the total number of time steps for which point output will be generated. \"\n        )\n    )\n    timesplit: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Time splitting option for output file management:\\n\"\n            \"  0: No date in filename\\n\"\n            \"  4: Yearly splitting\\n\"\n            \"  6: Monthly splitting\\n\"\n            \"  8: Daily splitting\\n\"\n            \"  10: Hourly splitting\\n\"\n            \"This controls how output files are split over time periods.\"\n        ),\n        ge=0,\n        le=10\n    )\n    list: Optional[str] = Field(\n        default=None,\n        description=(\n            \"List of point indices to output. Options are:\\n\"\n            \"  'all': Output all points in the point file\\n\"\n            \"  '1 2 3': Space-separated list of specific point indices\\n\"\n            \"  '1-3': Range notation for point indices (if supported)\\n\"\n            \"This specifies which points from the point file will be included in the output.\"\n        )\n    )\n    samefile: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to put all points in the same file (T) or separate files (F). \"\n            \"When True, all requested point output is written to a single NetCDF file. \"\n            \"When False, each point may be written to separate files.\"\n        )\n    )\n    buffer: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Number of points to process per pass. This controls memory usage during \"\n            \"point output processing by limiting how many points are processed simultaneously. \"\n            \"Higher values use more memory but may be faster. \"\n            \"Lower values use less memory but may be slower.\"\n        ),\n        ge=1\n    )\n    type: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Output type for point data:\\n\"\n            \"  0: Inventory (basic point information)\\n\"\n            \"  1: Spectra (full wave spectra)\\n\"\n            \"  2: Mean parameters (HS, Tp, etc.)\\n\"\n            \"  3: Source terms (wind input, dissipation, etc.)\\n\"\n            \"This determines the type and amount of data output for each point.\"\n        ),\n        ge=0,\n        le=3\n    )\n    dimorder: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Dimension ordering for point output NetCDF files:\\n\"\n            \"  T: Time,Station (time varies fastest)\\n\"\n            \"  F: Station,Time (station varies fastest)\\n\"\n            \"This controls how data dimensions are organized in the output files.\"\n        )\n    )\n\n    @field_validator('timestart')\n    @classmethod\n    def validate_timestart_format(cls, v):\n        \"\"\"Validate date format for timestart.\"\"\"\n        if v is not None:\n            return validate_date_format(v)\n        return v\n\n    @field_validator('timesplit')\n    @classmethod\n    def validate_timesplit(cls, v):\n        \"\"\"Validate timesplit value.\"\"\"\n        if v is not None and v not in [0, 4, 6, 8, 10]:\n            raise ValueError(f\"Time split must be 0, 4, 6, 8, or 10, got {v}\")\n        return v\n\n    @field_validator('type')\n    @classmethod\n    def validate_type(cls, v):\n        \"\"\"Validate type value.\"\"\"\n        if v is not None and v not in [0, 1, 2, 3]:\n            raise ValueError(f\"Type must be 0, 1, 2, or 3, got {v}\")\n        return v\n\n    @field_validator('buffer')\n    @classmethod\n    def validate_buffer(cls, v):\n        \"\"\"Validate buffer value.\"\"\"\n        if v is not None and v &lt; 1:\n            raise ValueError(f\"Buffer must be at least 1, got {v}\")\n        return v\n\n    @field_validator('samefile', 'dimorder')\n    @classmethod\n    def validate_boolean_flags(cls, v):\n        \"\"\"Validate boolean flags are actually boolean.\"\"\"\n        if v is not None and not isinstance(v, bool):\n            raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.timestart","title":"timestart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestart: Optional[str] = Field(default=None, description=\"Start date for the point output in format 'YYYYMMDD HHMMSS'. This specifies when to begin writing point output during the post-processing. Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.timestride","title":"timestride  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestride: Optional[str] = Field(default=None, description=\"Time stride for the point output in seconds as a string. This specifies the time interval between point output writes. Example: '3600' for hourly output, '21600' for 6-hourly output.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.timecount","title":"timecount  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timecount: Optional[str] = Field(default=None, description='Number of time steps for the point output as a string. This specifies the total number of time steps for which point output will be generated. ')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.timesplit","title":"timesplit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timesplit: Optional[int] = Field(default=None, description='Time splitting option for output file management:\\n  0: No date in filename\\n  4: Yearly splitting\\n  6: Monthly splitting\\n  8: Daily splitting\\n  10: Hourly splitting\\nThis controls how output files are split over time periods.', ge=0, le=10)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.list","title":"list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>list: Optional[str] = Field(default=None, description=\"List of point indices to output. Options are:\\n  'all': Output all points in the point file\\n  '1 2 3': Space-separated list of specific point indices\\n  '1-3': Range notation for point indices (if supported)\\nThis specifies which points from the point file will be included in the output.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.samefile","title":"samefile  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>samefile: Optional[bool] = Field(default=None, description='Flag to put all points in the same file (T) or separate files (F). When True, all requested point output is written to a single NetCDF file. When False, each point may be written to separate files.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.buffer","title":"buffer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>buffer: Optional[int] = Field(default=None, description='Number of points to process per pass. This controls memory usage during point output processing by limiting how many points are processed simultaneously. Higher values use more memory but may be faster. Lower values use less memory but may be slower.', ge=1)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Optional[int] = Field(default=None, description='Output type for point data:\\n  0: Inventory (basic point information)\\n  1: Spectra (full wave spectra)\\n  2: Mean parameters (HS, Tp, etc.)\\n  3: Source terms (wind input, dissipation, etc.)\\nThis determines the type and amount of data output for each point.', ge=0, le=3)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.dimorder","title":"dimorder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dimorder: Optional[bool] = Field(default=None, description='Dimension ordering for point output NetCDF files:\\n  T: Time,Station (time varies fastest)\\n  F: Station,Time (station varies fastest)\\nThis controls how data dimensions are organized in the output files.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.validate_timestart_format","title":"validate_timestart_format  <code>classmethod</code>","text":"<pre><code>validate_timestart_format(v)\n</code></pre> <p>Validate date format for timestart.</p> Source code in <code>rompy_ww3/namelists/point.py</code> <pre><code>@field_validator('timestart')\n@classmethod\ndef validate_timestart_format(cls, v):\n    \"\"\"Validate date format for timestart.\"\"\"\n    if v is not None:\n        return validate_date_format(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.validate_timesplit","title":"validate_timesplit  <code>classmethod</code>","text":"<pre><code>validate_timesplit(v)\n</code></pre> <p>Validate timesplit value.</p> Source code in <code>rompy_ww3/namelists/point.py</code> <pre><code>@field_validator('timesplit')\n@classmethod\ndef validate_timesplit(cls, v):\n    \"\"\"Validate timesplit value.\"\"\"\n    if v is not None and v not in [0, 4, 6, 8, 10]:\n        raise ValueError(f\"Time split must be 0, 4, 6, 8, or 10, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.validate_type","title":"validate_type  <code>classmethod</code>","text":"<pre><code>validate_type(v)\n</code></pre> <p>Validate type value.</p> Source code in <code>rompy_ww3/namelists/point.py</code> <pre><code>@field_validator('type')\n@classmethod\ndef validate_type(cls, v):\n    \"\"\"Validate type value.\"\"\"\n    if v is not None and v not in [0, 1, 2, 3]:\n        raise ValueError(f\"Type must be 0, 1, 2, or 3, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.validate_buffer","title":"validate_buffer  <code>classmethod</code>","text":"<pre><code>validate_buffer(v)\n</code></pre> <p>Validate buffer value.</p> Source code in <code>rompy_ww3/namelists/point.py</code> <pre><code>@field_validator('buffer')\n@classmethod\ndef validate_buffer(cls, v):\n    \"\"\"Validate buffer value.\"\"\"\n    if v is not None and v &lt; 1:\n        raise ValueError(f\"Buffer must be at least 1, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.point.Point.validate_boolean_flags","title":"validate_boolean_flags  <code>classmethod</code>","text":"<pre><code>validate_boolean_flags(v)\n</code></pre> <p>Validate boolean flags are actually boolean.</p> Source code in <code>rompy_ww3/namelists/point.py</code> <pre><code>@field_validator('samefile', 'dimorder')\n@classmethod\ndef validate_boolean_flags(cls, v):\n    \"\"\"Validate boolean flags are actually boolean.\"\"\"\n    if v is not None and not isinstance(v, bool):\n        raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#restart-namelist","title":"Restart Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.restart.Restart","title":"Restart","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>RESTART_NML namelist for WW3.</p> <p>The RESTART_NML namelist defines the restart time for initializing the wave model in WAVEWATCH III. This namelist specifies the time at which the model should initialize from restart files, allowing continuation of simulations from a previous state.</p> <p>The restart time is used to select the appropriate restart file(s) for model initialization. This is essential for long-term simulations that need to be broken into segments or for initializing forecasts from analysis states.</p> Source code in <code>rompy_ww3/namelists/restart.py</code> <pre><code>class Restart(NamelistBaseModel):\n    \"\"\"RESTART_NML namelist for WW3.\n\n    The RESTART_NML namelist defines the restart time for initializing the wave model in WAVEWATCH III.\n    This namelist specifies the time at which the model should initialize from restart files,\n    allowing continuation of simulations from a previous state.\n\n    The restart time is used to select the appropriate restart file(s) for model initialization.\n    This is essential for long-term simulations that need to be broken into segments or\n    for initializing forecasts from analysis states.\n    \"\"\"\n\n    restarttime: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Restart time for model initialization in format 'YYYYMMDD HHMMSS'. \"\n            \"This specifies the time at which the model should initialize from restart files. \"\n            \"The model will look for restart files corresponding to this time to initialize \"\n            \"the wave spectra and other state variables. \"\n            \"Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\"\n        )\n    )\n\n    @field_validator('restarttime')\n    @classmethod\n    def validate_restarttime_format(cls, v):\n        \"\"\"Validate date format for restarttime.\"\"\"\n        if v is not None:\n            return validate_date_format(v)\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restart.Restart-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.restart.Restart.restarttime","title":"restarttime  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>restarttime: Optional[str] = Field(default=None, description=\"Restart time for model initialization in format 'YYYYMMDD HHMMSS'. This specifies the time at which the model should initialize from restart files. The model will look for restart files corresponding to this time to initialize the wave spectra and other state variables. Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restart.Restart-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.restart.Restart.validate_restarttime_format","title":"validate_restarttime_format  <code>classmethod</code>","text":"<pre><code>validate_restarttime_format(v)\n</code></pre> <p>Validate date format for restarttime.</p> Source code in <code>rompy_ww3/namelists/restart.py</code> <pre><code>@field_validator('restarttime')\n@classmethod\ndef validate_restarttime_format(cls, v):\n    \"\"\"Validate date format for restarttime.\"\"\"\n    if v is not None:\n        return validate_date_format(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#homogeneous-count-namelist","title":"Homogeneous Count Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount","title":"HomogCount","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>HOMOG_COUNT_NML namelist for WW3.</p> <p>Defines homogeneous input counts.</p> Source code in <code>rompy_ww3/namelists/homogeneous.py</code> <pre><code>class HomogCount(NamelistBaseModel):\n    \"\"\"HOMOG_COUNT_NML namelist for WW3.\n\n    Defines homogeneous input counts.\n    \"\"\"\n\n    # Single-grid homogeneous input counts\n    n_ic1: Optional[int] = Field(\n        default=None, description=\"Number of ice concentration type 1 inputs\"\n    )\n    n_ic2: Optional[int] = Field(\n        default=None, description=\"Number of ice concentration type 2 inputs\"\n    )\n    n_ic3: Optional[int] = Field(\n        default=None, description=\"Number of ice concentration type 3 inputs\"\n    )\n    n_ic4: Optional[int] = Field(\n        default=None, description=\"Number of ice concentration type 4 inputs\"\n    )\n    n_ic5: Optional[int] = Field(\n        default=None, description=\"Number of ice concentration type 5 inputs\"\n    )\n    n_mdn: Optional[int] = Field(\n        default=None, description=\"Number of mud density inputs\"\n    )\n    n_mth: Optional[int] = Field(\n        default=None, description=\"Number of mud thickness inputs\"\n    )\n    n_mvs: Optional[int] = Field(\n        default=None, description=\"Number of mud viscosity inputs\"\n    )\n    n_lev: Optional[int] = Field(\n        default=None, description=\"Number of water level inputs\"\n    )\n    n_cur: Optional[int] = Field(default=None, description=\"Number of current inputs\")\n    n_wnd: Optional[int] = Field(default=None, description=\"Number of wind inputs\")\n    n_ice: Optional[int] = Field(\n        default=None, description=\"Number of ice concentration inputs\"\n    )\n    n_tau: Optional[int] = Field(\n        default=None, description=\"Number of wind stress inputs\"\n    )\n    n_rho: Optional[int] = Field(\n        default=None, description=\"Number of air density inputs\"\n    )\n    n_mov: Optional[int] = Field(\n        default=None, description=\"Number of moving inputs (multi-grid)\"\n    )\n\n    @field_validator(\n        \"n_ic1\",\n        \"n_ic2\",\n        \"n_ic3\",\n        \"n_ic4\",\n        \"n_ic5\",\n        \"n_mdn\",\n        \"n_mth\",\n        \"n_mvs\",\n        \"n_lev\",\n        \"n_cur\",\n        \"n_wnd\",\n        \"n_ice\",\n        \"n_tau\",\n        \"n_rho\",\n        \"n_mov\",\n        mode=\"before\",\n    )\n    @classmethod\n    def validate_non_negative_count(cls, v):\n        \"\"\"Ensure count values are non-negative.\"\"\"\n        if v is not None and v &lt; 0:\n            raise ValueError(\"Count values must be non-negative\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_ic1","title":"n_ic1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_ic1: Optional[int] = Field(default=None, description='Number of ice concentration type 1 inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_ic2","title":"n_ic2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_ic2: Optional[int] = Field(default=None, description='Number of ice concentration type 2 inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_ic3","title":"n_ic3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_ic3: Optional[int] = Field(default=None, description='Number of ice concentration type 3 inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_ic4","title":"n_ic4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_ic4: Optional[int] = Field(default=None, description='Number of ice concentration type 4 inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_ic5","title":"n_ic5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_ic5: Optional[int] = Field(default=None, description='Number of ice concentration type 5 inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_mdn","title":"n_mdn  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_mdn: Optional[int] = Field(default=None, description='Number of mud density inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_mth","title":"n_mth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_mth: Optional[int] = Field(default=None, description='Number of mud thickness inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_mvs","title":"n_mvs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_mvs: Optional[int] = Field(default=None, description='Number of mud viscosity inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_lev","title":"n_lev  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_lev: Optional[int] = Field(default=None, description='Number of water level inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_cur","title":"n_cur  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_cur: Optional[int] = Field(default=None, description='Number of current inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_wnd","title":"n_wnd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_wnd: Optional[int] = Field(default=None, description='Number of wind inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_ice","title":"n_ice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_ice: Optional[int] = Field(default=None, description='Number of ice concentration inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_tau","title":"n_tau  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_tau: Optional[int] = Field(default=None, description='Number of wind stress inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_rho","title":"n_rho  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_rho: Optional[int] = Field(default=None, description='Number of air density inputs')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.n_mov","title":"n_mov  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_mov: Optional[int] = Field(default=None, description='Number of moving inputs (multi-grid)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogCount.validate_non_negative_count","title":"validate_non_negative_count  <code>classmethod</code>","text":"<pre><code>validate_non_negative_count(v)\n</code></pre> <p>Ensure count values are non-negative.</p> Source code in <code>rompy_ww3/namelists/homogeneous.py</code> <pre><code>@field_validator(\n    \"n_ic1\",\n    \"n_ic2\",\n    \"n_ic3\",\n    \"n_ic4\",\n    \"n_ic5\",\n    \"n_mdn\",\n    \"n_mth\",\n    \"n_mvs\",\n    \"n_lev\",\n    \"n_cur\",\n    \"n_wnd\",\n    \"n_ice\",\n    \"n_tau\",\n    \"n_rho\",\n    \"n_mov\",\n    mode=\"before\",\n)\n@classmethod\ndef validate_non_negative_count(cls, v):\n    \"\"\"Ensure count values are non-negative.\"\"\"\n    if v is not None and v &lt; 0:\n        raise ValueError(\"Count values must be non-negative\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#homogeneous-input-namelist","title":"Homogeneous Input Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput","title":"HomogInput","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>HOMOG_INPUT_NML namelist for WW3.</p> <p>Defines homogeneous inputs.</p> Source code in <code>rompy_ww3/namelists/homogeneous.py</code> <pre><code>class HomogInput(NamelistBaseModel):\n    \"\"\"HOMOG_INPUT_NML namelist for WW3.\n\n    Defines homogeneous inputs.\n    \"\"\"\n\n    name: Optional[str] = Field(\n        default=None,\n        description=\"Input type name (IC1, IC2, IC3, IC4, IC5, MDN, MTH, MVS, LEV, CUR, WND, ICE, MOV, TAU, RHO)\",\n    )\n    date: Optional[str] = Field(\n        default=None, description=\"Input date (yyyymmdd hhmmss)\"\n    )\n    value1: Optional[float] = Field(\n        default=None, description=\"First input value (depends on input type)\"\n    )\n    value2: Optional[float] = Field(\n        default=None, description=\"Second input value (depends on input type)\"\n    )\n    value3: Optional[float] = Field(\n        default=None, description=\"Third input value (depends on input type)\"\n    )\n\n    @field_validator(\"name\", mode=\"before\")\n    @classmethod\n    def validate_name(cls, v):\n        \"\"\"Validate that name is one of the allowed values.\"\"\"\n        if v is None:\n            return v\n        allowed_names = {\n            \"IC1\",\n            \"IC2\",\n            \"IC3\",\n            \"IC4\",\n            \"IC5\",\n            \"MDN\",\n            \"MTH\",\n            \"MVS\",\n            \"LEV\",\n            \"CUR\",\n            \"WND\",\n            \"ICE\",\n            \"MOV\",\n            \"TAU\",\n            \"RHO\",\n        }\n        if v not in allowed_names:\n            raise ValueError(f\"Name must be one of {allowed_names}, got {v}\")\n        return v\n\n    @field_validator(\"date\", mode=\"before\")\n    @classmethod\n    def validate_date_format(cls, v):\n        \"\"\"Validate date format is yyyymmdd hhmmss.\"\"\"\n        if v is None:\n            return v\n        # Check if it matches the format yyyymmdd hhmmss (15 characters)\n        if not isinstance(v, str) or len(v) != 15 or v[8] != \" \":\n            raise ValueError(f\"Date must be in format yyyymmdd hhmmss, got {v}\")\n\n        # Check if all characters are digits except the space\n        date_part = v[:8]\n        time_part = v[9:]\n        if not (date_part.isdigit() and time_part.isdigit()):\n            raise ValueError(f\"Date must be in format yyyymmdd hhmmss, got {v}\")\n\n        return v\n\n    @field_validator(\"value1\", mode=\"before\")\n    @classmethod\n    def validate_value1_deactivation(cls, v):\n        \"\"\"Validate that if value1 is 0, the input is deactivated.\"\"\"\n        if v == 0:\n            # When value1 is 0, we can issue a warning or just allow it as per spec\n            # The spec says \"if VALUE1 is equal 0, then the homogeneous input is desactivated\"\n            # This is more informational than a validation error\n            pass\n        return v\n\n    @field_validator(\"value1\", \"value2\", \"value3\", mode=\"before\")\n    @classmethod\n    def validate_value_constraints(cls, v, info):\n        \"\"\"Validate value constraints based on the input name.\"\"\"\n        if v is None:\n            return v\n\n        # This validator has limited access to other fields in Pydantic v2\n        # The full validation for value constraints based on name will happen\n        # at the HomogeneousInputs level or during model construction\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(default=None, description='Input type name (IC1, IC2, IC3, IC4, IC5, MDN, MTH, MVS, LEV, CUR, WND, ICE, MOV, TAU, RHO)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: Optional[str] = Field(default=None, description='Input date (yyyymmdd hhmmss)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.value1","title":"value1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value1: Optional[float] = Field(default=None, description='First input value (depends on input type)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.value2","title":"value2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value2: Optional[float] = Field(default=None, description='Second input value (depends on input type)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.value3","title":"value3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value3: Optional[float] = Field(default=None, description='Third input value (depends on input type)')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.validate_name","title":"validate_name  <code>classmethod</code>","text":"<pre><code>validate_name(v)\n</code></pre> <p>Validate that name is one of the allowed values.</p> Source code in <code>rompy_ww3/namelists/homogeneous.py</code> <pre><code>@field_validator(\"name\", mode=\"before\")\n@classmethod\ndef validate_name(cls, v):\n    \"\"\"Validate that name is one of the allowed values.\"\"\"\n    if v is None:\n        return v\n    allowed_names = {\n        \"IC1\",\n        \"IC2\",\n        \"IC3\",\n        \"IC4\",\n        \"IC5\",\n        \"MDN\",\n        \"MTH\",\n        \"MVS\",\n        \"LEV\",\n        \"CUR\",\n        \"WND\",\n        \"ICE\",\n        \"MOV\",\n        \"TAU\",\n        \"RHO\",\n    }\n    if v not in allowed_names:\n        raise ValueError(f\"Name must be one of {allowed_names}, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.validate_date_format","title":"validate_date_format  <code>classmethod</code>","text":"<pre><code>validate_date_format(v)\n</code></pre> <p>Validate date format is yyyymmdd hhmmss.</p> Source code in <code>rompy_ww3/namelists/homogeneous.py</code> <pre><code>@field_validator(\"date\", mode=\"before\")\n@classmethod\ndef validate_date_format(cls, v):\n    \"\"\"Validate date format is yyyymmdd hhmmss.\"\"\"\n    if v is None:\n        return v\n    # Check if it matches the format yyyymmdd hhmmss (15 characters)\n    if not isinstance(v, str) or len(v) != 15 or v[8] != \" \":\n        raise ValueError(f\"Date must be in format yyyymmdd hhmmss, got {v}\")\n\n    # Check if all characters are digits except the space\n    date_part = v[:8]\n    time_part = v[9:]\n    if not (date_part.isdigit() and time_part.isdigit()):\n        raise ValueError(f\"Date must be in format yyyymmdd hhmmss, got {v}\")\n\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.validate_value1_deactivation","title":"validate_value1_deactivation  <code>classmethod</code>","text":"<pre><code>validate_value1_deactivation(v)\n</code></pre> <p>Validate that if value1 is 0, the input is deactivated.</p> Source code in <code>rompy_ww3/namelists/homogeneous.py</code> <pre><code>@field_validator(\"value1\", mode=\"before\")\n@classmethod\ndef validate_value1_deactivation(cls, v):\n    \"\"\"Validate that if value1 is 0, the input is deactivated.\"\"\"\n    if v == 0:\n        # When value1 is 0, we can issue a warning or just allow it as per spec\n        # The spec says \"if VALUE1 is equal 0, then the homogeneous input is desactivated\"\n        # This is more informational than a validation error\n        pass\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.homogeneous.HomogInput.validate_value_constraints","title":"validate_value_constraints  <code>classmethod</code>","text":"<pre><code>validate_value_constraints(v, info)\n</code></pre> <p>Validate value constraints based on the input name.</p> Source code in <code>rompy_ww3/namelists/homogeneous.py</code> <pre><code>@field_validator(\"value1\", \"value2\", \"value3\", mode=\"before\")\n@classmethod\ndef validate_value_constraints(cls, v, info):\n    \"\"\"Validate value constraints based on the input name.\"\"\"\n    if v is None:\n        return v\n\n    # This validator has limited access to other fields in Pydantic v2\n    # The full validation for value constraints based on name will happen\n    # at the HomogeneousInputs level or during model construction\n    return v\n</code></pre>"},{"location":"reference/namelists/#inbound-count-namelist","title":"Inbound Count Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundCount","title":"InboundCount","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>INBND_COUNT_NML namelist for WW3.</p> <p>The INBND_COUNT_NML namelist defines the number of input boundary points for WAVEWATCH III grids. This namelist sets up how many boundary points will be specified in the corresponding INBND_POINT_NML.</p> <p>If no mask is defined, INBOUND can be used to specify active boundaries. If the actual input data is not defined in the actual wave model run, the initial conditions will be applied as constant boundary conditions.</p> <p>The points must start from index 1 to N and define grid points from segment data identifying points at which input boundary conditions are to be defined.</p> Source code in <code>rompy_ww3/namelists/inbound.py</code> <pre><code>class InboundCount(NamelistBaseModel):\n    \"\"\"INBND_COUNT_NML namelist for WW3.\n\n    The INBND_COUNT_NML namelist defines the number of input boundary points\n    for WAVEWATCH III grids. This namelist sets up how many boundary points\n    will be specified in the corresponding INBND_POINT_NML.\n\n    If no mask is defined, INBOUND can be used to specify active boundaries.\n    If the actual input data is not defined in the actual wave model run,\n    the initial conditions will be applied as constant boundary conditions.\n\n    The points must start from index 1 to N and define grid points from segment data\n    identifying points at which input boundary conditions are to be defined.\n    \"\"\"\n\n    n_point: Optional[int] = Field(\n        default=None,\n        description=\"Number of boundary points, defines how many boundary points will be specified\",\n        ge=0  # Can have 0 boundary points\n    )\n\n    @field_validator('n_point')\n    @classmethod\n    def validate_n_point(cls, v):\n        \"\"\"Validate number of points is non-negative.\"\"\"\n        if v is not None:\n            if v &lt; 0:\n                raise ValueError(f\"Number of points must be non-negative, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundCount-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundCount.n_point","title":"n_point  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_point: Optional[int] = Field(default=None, description='Number of boundary points, defines how many boundary points will be specified', ge=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundCount-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundCount.validate_n_point","title":"validate_n_point  <code>classmethod</code>","text":"<pre><code>validate_n_point(v)\n</code></pre> <p>Validate number of points is non-negative.</p> Source code in <code>rompy_ww3/namelists/inbound.py</code> <pre><code>@field_validator('n_point')\n@classmethod\ndef validate_n_point(cls, v):\n    \"\"\"Validate number of points is non-negative.\"\"\"\n    if v is not None:\n        if v &lt; 0:\n            raise ValueError(f\"Number of points must be non-negative, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#inbound-point-list-namelist","title":"Inbound Point List Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundPointList","title":"InboundPointList","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>INBND_POINT_NML namelist for WW3.</p> <p>The INBND_POINT_NML namelist defines the input boundary points for WAVEWATCH III grids. Each point is specified by its grid indices (x_index, y_index) and a connect flag.</p> <p>If no mask is defined, INBOUND can be used to specify active boundaries. If the actual input data is not defined in the actual wave model run, the initial conditions will be applied as constant boundary conditions.</p> <p>The points must start from index 1 to N and define grid points from segment data identifying points at which input boundary conditions are to be defined. The connect flag determines if intermediate points between consecutive points are also included as boundary points.</p> Source code in <code>rompy_ww3/namelists/inbound.py</code> <pre><code>class InboundPointList(NamelistBaseModel):\n    \"\"\"INBND_POINT_NML namelist for WW3.\n\n    The INBND_POINT_NML namelist defines the input boundary points for WAVEWATCH III grids.\n    Each point is specified by its grid indices (x_index, y_index) and a connect flag.\n\n    If no mask is defined, INBOUND can be used to specify active boundaries.\n    If the actual input data is not defined in the actual wave model run,\n    the initial conditions will be applied as constant boundary conditions.\n\n    The points must start from index 1 to N and define grid points from segment data\n    identifying points at which input boundary conditions are to be defined.\n    The connect flag determines if intermediate points between consecutive points\n    are also included as boundary points.\n    \"\"\"\n\n    points: List[InboundPoint] = Field(\n        default_factory=list,\n        description=\"List of inbound boundary points, each specifying x_index, y_index, and connect flag\"\n    )\n\n    @field_validator('points')\n    @classmethod\n    def validate_points_list(cls, v):\n        \"\"\"Validate the points list.\"\"\"\n        if v is not None:\n            for i, point in enumerate(v):\n                if not isinstance(point, InboundPoint):\n                    raise ValueError(f\"Point at index {i} must be of type InboundPoint, got {type(point)}\")\n        return v\n\n    def render(self) -&gt; str:\n        \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n        lines = [\"&amp;INBND_POINT_NML\"]\n\n        for i, point in enumerate(self.points, 1):\n            # Format as unindexed: INBND_POINT(I) = x_index y_index connect\n            values = []\n            if point.x_index is not None:\n                values.append(str(point.x_index))\n            if point.y_index is not None:\n                values.append(str(point.y_index))\n            if point.connect is not None:\n                values.append(\"T\" if point.connect else \"F\")\n\n            if values:\n                # Simple space-separated format - Fortran will read this correctly\n                spaced_values = \" \".join(values)\n                lines.append(f\"  INBND_POINT({i})         = {spaced_values}\")\n            lines.append(\"\")  # Add a blank line between points for readability\n\n        lines.append(\"/\")\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundPointList-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundPointList.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: List[InboundPoint] = Field(default_factory=list, description='List of inbound boundary points, each specifying x_index, y_index, and connect flag')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundPointList-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundPointList.validate_points_list","title":"validate_points_list  <code>classmethod</code>","text":"<pre><code>validate_points_list(v)\n</code></pre> <p>Validate the points list.</p> Source code in <code>rompy_ww3/namelists/inbound.py</code> <pre><code>@field_validator('points')\n@classmethod\ndef validate_points_list(cls, v):\n    \"\"\"Validate the points list.\"\"\"\n    if v is not None:\n        for i, point in enumerate(v):\n            if not isinstance(point, InboundPoint):\n                raise ValueError(f\"Point at index {i} must be of type InboundPoint, got {type(point)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.inbound.InboundPointList.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Render the namelist content with unindexed parameters.</p> Source code in <code>rompy_ww3/namelists/inbound.py</code> <pre><code>def render(self) -&gt; str:\n    \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n    lines = [\"&amp;INBND_POINT_NML\"]\n\n    for i, point in enumerate(self.points, 1):\n        # Format as unindexed: INBND_POINT(I) = x_index y_index connect\n        values = []\n        if point.x_index is not None:\n            values.append(str(point.x_index))\n        if point.y_index is not None:\n            values.append(str(point.y_index))\n        if point.connect is not None:\n            values.append(\"T\" if point.connect else \"F\")\n\n        if values:\n            # Simple space-separated format - Fortran will read this correctly\n            spaced_values = \" \".join(values)\n            lines.append(f\"  INBND_POINT({i})         = {spaced_values}\")\n        lines.append(\"\")  # Add a blank line between points for readability\n\n    lines.append(\"/\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#excluded-count-namelist","title":"Excluded Count Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedCount","title":"ExcludedCount","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>EXCL_COUNT_NML namelist for WW3.</p> <p>The EXCL_COUNT_NML namelist defines the number of excluded points and bodies for WAVEWATCH III grids. This namelist sets up how many excluded points and bodies will be specified in the corresponding EXCL_POINT_NML and EXCL_BODY_NML namelists.</p> <p>If no mask is defined, EXCL can be used to specify excluded areas. NOTE: If a mask is defined, EXCL cannot be used.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>class ExcludedCount(NamelistBaseModel):\n    \"\"\"EXCL_COUNT_NML namelist for WW3.\n\n    The EXCL_COUNT_NML namelist defines the number of excluded points and bodies\n    for WAVEWATCH III grids. This namelist sets up how many excluded points and bodies\n    will be specified in the corresponding EXCL_POINT_NML and EXCL_BODY_NML namelists.\n\n    If no mask is defined, EXCL can be used to specify excluded areas.\n    NOTE: If a mask is defined, EXCL cannot be used.\n    \"\"\"\n\n    n_point: Optional[int] = Field(\n        default=None,\n        description=\"Number of excluded point segments, defines how many excluded points will be specified\",\n        ge=0  # Can have 0 excluded points\n    )\n    n_body: Optional[int] = Field(\n        default=None,\n        description=\"Number of excluded bodies, defines how many closed bodies will be removed from the grid\",\n        ge=0  # Can have 0 excluded bodies\n    )\n\n    @field_validator('n_point', 'n_body')\n    @classmethod\n    def validate_counts(cls, v):\n        \"\"\"Validate counts are non-negative.\"\"\"\n        if v is not None:\n            if v &lt; 0:\n                raise ValueError(f\"Count must be non-negative, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedCount-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedCount.n_point","title":"n_point  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_point: Optional[int] = Field(default=None, description='Number of excluded point segments, defines how many excluded points will be specified', ge=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedCount.n_body","title":"n_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_body: Optional[int] = Field(default=None, description='Number of excluded bodies, defines how many closed bodies will be removed from the grid', ge=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedCount-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedCount.validate_counts","title":"validate_counts  <code>classmethod</code>","text":"<pre><code>validate_counts(v)\n</code></pre> <p>Validate counts are non-negative.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>@field_validator('n_point', 'n_body')\n@classmethod\ndef validate_counts(cls, v):\n    \"\"\"Validate counts are non-negative.\"\"\"\n    if v is not None:\n        if v &lt; 0:\n            raise ValueError(f\"Count must be non-negative, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#excluded-point-list-namelist","title":"Excluded Point List Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedPointList","title":"ExcludedPointList","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>EXCL_POINT_NML namelist for WW3.</p> <p>The EXCL_POINT_NML namelist defines the excluded points for WAVEWATCH III grids. Each point is specified by its grid indices (x_index, y_index) and a connect flag.</p> <p>If no mask is defined, EXCL can be used to specify excluded areas. NOTE: If a mask is defined, EXCL cannot be used.</p> <p>The excluded points are specified as segments of points that define areas to be  excluded from the simulation. The connect flag determines if intermediate points  between consecutive points are also excluded.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>class ExcludedPointList(NamelistBaseModel):\n    \"\"\"EXCL_POINT_NML namelist for WW3.\n\n    The EXCL_POINT_NML namelist defines the excluded points for WAVEWATCH III grids.\n    Each point is specified by its grid indices (x_index, y_index) and a connect flag.\n\n    If no mask is defined, EXCL can be used to specify excluded areas.\n    NOTE: If a mask is defined, EXCL cannot be used.\n\n    The excluded points are specified as segments of points that define areas to be \n    excluded from the simulation. The connect flag determines if intermediate points \n    between consecutive points are also excluded.\n    \"\"\"\n\n    points: List[ExcludedPoint] = Field(\n        default_factory=list,\n        description=\"List of excluded points, each specifying x_index, y_index, and connect flag\"\n    )\n\n    @field_validator('points')\n    @classmethod\n    def validate_points_list(cls, v):\n        \"\"\"Validate the points list.\"\"\"\n        if v is not None:\n            for i, point in enumerate(v):\n                if not isinstance(point, ExcludedPoint):\n                    raise ValueError(f\"Point at index {i} must be of type ExcludedPoint, got {type(point)}\")\n        return v\n\n    def render(self) -&gt; str:\n        \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n        lines = [\"&amp;EXCL_POINT_NML\"]\n\n        for j, point in enumerate(self.points, 1):\n            # Format as unindexed: EXCL_POINT(J) = x_index y_index connect\n            values = []\n            if point.x_index is not None:\n                values.append(str(point.x_index))\n            if point.y_index is not None:\n                values.append(str(point.y_index))\n            if point.connect is not None:\n                values.append(\"T\" if point.connect else \"F\")\n\n            if values:\n                # Simple space-separated format - Fortran will read this correctly\n                spaced_values = \" \".join(values)\n                lines.append(f\"  EXCL_POINT({j})       = {spaced_values}\")\n            lines.append(\"\")  # Add a blank line between points for readability\n\n        lines.append(\"/\")\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedPointList-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedPointList.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: List[ExcludedPoint] = Field(default_factory=list, description='List of excluded points, each specifying x_index, y_index, and connect flag')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedPointList-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedPointList.validate_points_list","title":"validate_points_list  <code>classmethod</code>","text":"<pre><code>validate_points_list(v)\n</code></pre> <p>Validate the points list.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>@field_validator('points')\n@classmethod\ndef validate_points_list(cls, v):\n    \"\"\"Validate the points list.\"\"\"\n    if v is not None:\n        for i, point in enumerate(v):\n            if not isinstance(point, ExcludedPoint):\n                raise ValueError(f\"Point at index {i} must be of type ExcludedPoint, got {type(point)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedPointList.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Render the namelist content with unindexed parameters.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>def render(self) -&gt; str:\n    \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n    lines = [\"&amp;EXCL_POINT_NML\"]\n\n    for j, point in enumerate(self.points, 1):\n        # Format as unindexed: EXCL_POINT(J) = x_index y_index connect\n        values = []\n        if point.x_index is not None:\n            values.append(str(point.x_index))\n        if point.y_index is not None:\n            values.append(str(point.y_index))\n        if point.connect is not None:\n            values.append(\"T\" if point.connect else \"F\")\n\n        if values:\n            # Simple space-separated format - Fortran will read this correctly\n            spaced_values = \" \".join(values)\n            lines.append(f\"  EXCL_POINT({j})       = {spaced_values}\")\n        lines.append(\"\")  # Add a blank line between points for readability\n\n    lines.append(\"/\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#excluded-body-list-namelist","title":"Excluded Body List Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedBodyList","title":"ExcludedBodyList","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>EXCL_BODY_NML namelist for WW3.</p> <p>The EXCL_BODY_NML namelist defines the excluded bodies for WAVEWATCH III grids. Each body is specified by a point inside the closed body to be removed.</p> <p>If no mask is defined, EXCL can be used to specify excluded areas. NOTE: If a mask is defined, EXCL cannot be used.</p> <p>The excluded bodies are specified as points inside closed bodies of sea points. Each specified point will result in the entire closed body of sea points  containing that point to be removed from the simulation.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>class ExcludedBodyList(NamelistBaseModel):\n    \"\"\"EXCL_BODY_NML namelist for WW3.\n\n    The EXCL_BODY_NML namelist defines the excluded bodies for WAVEWATCH III grids.\n    Each body is specified by a point inside the closed body to be removed.\n\n    If no mask is defined, EXCL can be used to specify excluded areas.\n    NOTE: If a mask is defined, EXCL cannot be used.\n\n    The excluded bodies are specified as points inside closed bodies of sea points.\n    Each specified point will result in the entire closed body of sea points \n    containing that point to be removed from the simulation.\n    \"\"\"\n\n    bodies: List[ExcludedBody] = Field(\n        default_factory=list,\n        description=\"List of excluded bodies, each specified by a point inside the closed body to be removed\"\n    )\n\n    @field_validator('bodies')\n    @classmethod\n    def validate_bodies_list(cls, v):\n        \"\"\"Validate the bodies list.\"\"\"\n        if v is not None:\n            for i, body in enumerate(v):\n                if not isinstance(body, ExcludedBody):\n                    raise ValueError(f\"Body at index {i} must be of type ExcludedBody, got {type(body)}\")\n        return v\n\n    def render(self) -&gt; str:\n        \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n        lines = [\"&amp;EXCL_BODY_NML\"]\n\n        for k, body in enumerate(self.bodies, 1):\n            # Format as unindexed: EXCL_BODY(K) = x_index y_index\n            values = []\n            if body.x_index is not None:\n                values.append(str(body.x_index))\n            if body.y_index is not None:\n                values.append(str(body.y_index))\n\n            if values:\n                # Simple space-separated format - Fortran will read this correctly\n                spaced_values = \" \".join(values)\n                lines.append(f\"  EXCL_BODY({k})        = {spaced_values}\")\n            lines.append(\"\")  # Add a blank line between bodies for readability\n\n        lines.append(\"/\")\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedBodyList-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedBodyList.bodies","title":"bodies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bodies: List[ExcludedBody] = Field(default_factory=list, description='List of excluded bodies, each specified by a point inside the closed body to be removed')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedBodyList-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedBodyList.validate_bodies_list","title":"validate_bodies_list  <code>classmethod</code>","text":"<pre><code>validate_bodies_list(v)\n</code></pre> <p>Validate the bodies list.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>@field_validator('bodies')\n@classmethod\ndef validate_bodies_list(cls, v):\n    \"\"\"Validate the bodies list.\"\"\"\n    if v is not None:\n        for i, body in enumerate(v):\n            if not isinstance(body, ExcludedBody):\n                raise ValueError(f\"Body at index {i} must be of type ExcludedBody, got {type(body)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.excluded.ExcludedBodyList.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Render the namelist content with unindexed parameters.</p> Source code in <code>rompy_ww3/namelists/excluded.py</code> <pre><code>def render(self) -&gt; str:\n    \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n    lines = [\"&amp;EXCL_BODY_NML\"]\n\n    for k, body in enumerate(self.bodies, 1):\n        # Format as unindexed: EXCL_BODY(K) = x_index y_index\n        values = []\n        if body.x_index is not None:\n            values.append(str(body.x_index))\n        if body.y_index is not None:\n            values.append(str(body.y_index))\n\n        if values:\n            # Simple space-separated format - Fortran will read this correctly\n            spaced_values = \" \".join(values)\n            lines.append(f\"  EXCL_BODY({k})        = {spaced_values}\")\n        lines.append(\"\")  # Add a blank line between bodies for readability\n\n    lines.append(\"/\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#outbound-count-namelist","title":"Outbound Count Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundCount","title":"OutboundCount","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>OUTBND_COUNT_NML namelist for WW3.</p> <p>The OUTBND_COUNT_NML namelist defines the number of output boundary lines for WAVEWATCH III grids. This namelist sets up how many boundary lines will be specified in the corresponding OUTBND_LINE_NML namelist.</p> <p>It creates a nest file with output boundaries for an inner grid. The prefered way to do it is to use ww3_bounc program. These do not need to be defined for data transfer between grids in the multi-grid driver.</p> Source code in <code>rompy_ww3/namelists/outbound.py</code> <pre><code>class OutboundCount(NamelistBaseModel):\n    \"\"\"OUTBND_COUNT_NML namelist for WW3.\n\n    The OUTBND_COUNT_NML namelist defines the number of output boundary lines\n    for WAVEWATCH III grids. This namelist sets up how many boundary lines\n    will be specified in the corresponding OUTBND_LINE_NML namelist.\n\n    It creates a nest file with output boundaries for an inner grid.\n    The prefered way to do it is to use ww3_bounc program.\n    These do not need to be defined for data transfer between grids in the multi-grid driver.\n    \"\"\"\n\n    n_line: Optional[int] = Field(\n        default=None,\n        description=\"Number of output boundary lines, defines how many boundary lines will be specified\",\n        ge=0  # Can have 0 boundary lines\n    )\n\n    @field_validator('n_line')\n    @classmethod\n    def validate_n_line(cls, v):\n        \"\"\"Validate number of lines is non-negative.\"\"\"\n        if v is not None:\n            if v &lt; 0:\n                raise ValueError(f\"Number of lines must be non-negative, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundCount-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundCount.n_line","title":"n_line  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_line: Optional[int] = Field(default=None, description='Number of output boundary lines, defines how many boundary lines will be specified', ge=0)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundCount-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundCount.validate_n_line","title":"validate_n_line  <code>classmethod</code>","text":"<pre><code>validate_n_line(v)\n</code></pre> <p>Validate number of lines is non-negative.</p> Source code in <code>rompy_ww3/namelists/outbound.py</code> <pre><code>@field_validator('n_line')\n@classmethod\ndef validate_n_line(cls, v):\n    \"\"\"Validate number of lines is non-negative.\"\"\"\n    if v is not None:\n        if v &lt; 0:\n            raise ValueError(f\"Number of lines must be non-negative, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#outbound-line-list-namelist","title":"Outbound Line List Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundLineList","title":"OutboundLineList","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>OUTBND_LINE_NML namelist for WW3.</p> <p>The OUTBND_LINE_NML namelist defines the output boundary lines for WAVEWATCH III grids. Each line is specified by its starting point (x0, y0), increments (dx, dy), and number of points (np).</p> <p>Output boundary points are defined as a number of straight lines, defined by its starting point (X0,Y0), increments (DX,DY) and number of points. A negative number of points starts a new output file.</p> <p>For spherical grids in degrees, an example would be: '1.75  1.50  0.25 -0.10     3' '2.25  1.50 -0.10  0.00    -6' '0.10  0.10  0.10  0.00   -10'</p> <p>It creates a nest file with output boundaries for an inner grid. The prefered way to do it is to use ww3_bounc program. These do not need to be defined for data transfer between grids in the multi-grid driver.</p> Source code in <code>rompy_ww3/namelists/outbound.py</code> <pre><code>class OutboundLineList(NamelistBaseModel):\n    \"\"\"OUTBND_LINE_NML namelist for WW3.\n\n    The OUTBND_LINE_NML namelist defines the output boundary lines for WAVEWATCH III grids.\n    Each line is specified by its starting point (x0, y0), increments (dx, dy), and number of points (np).\n\n    Output boundary points are defined as a number of straight lines, defined by its starting point (X0,Y0),\n    increments (DX,DY) and number of points. A negative number of points starts a new output file.\n\n    For spherical grids in degrees, an example would be:\n    '1.75  1.50  0.25 -0.10     3'\n    '2.25  1.50 -0.10  0.00    -6'\n    '0.10  0.10  0.10  0.00   -10'\n\n    It creates a nest file with output boundaries for an inner grid.\n    The prefered way to do it is to use ww3_bounc program.\n    These do not need to be defined for data transfer between grids in the multi-grid driver.\n    \"\"\"\n\n    lines: List[OutboundLine] = Field(\n        default_factory=list,\n        description=\"List of outbound boundary lines, each specifying x0, y0, dx, dy, and np\"\n    )\n\n    @field_validator('lines')\n    @classmethod\n    def validate_lines_list(cls, v):\n        \"\"\"Validate the lines list.\"\"\"\n        if v is not None:\n            for i, line in enumerate(v):\n                if not isinstance(line, OutboundLine):\n                    raise ValueError(f\"Line at index {i} must be of type OutboundLine, got {type(line)}\")\n        return v\n\n    def render(self) -&gt; str:\n        \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n        lines = [\"&amp;OUTBND_LINE_NML\"]\n\n        for i, line in enumerate(self.lines, 1):\n            # Format as unindexed: OUTBND_LINE(I) = x0 y0 dx dy np\n            values = []\n            if line.x0 is not None:\n                values.append(str(line.x0))\n            if line.y0 is not None:\n                values.append(str(line.y0))\n            if line.dx is not None:\n                values.append(str(line.dx))\n            if line.dy is not None:\n                values.append(str(line.dy))\n            if line.np is not None:\n                values.append(str(line.np))\n\n            if values:\n                # Simple space-separated format - Fortran will read this correctly\n                spaced_values = \" \".join(values)\n                lines.append(f\"  OUTBND_LINE({i})         = {spaced_values}\")\n            lines.append(\"\")  # Add a blank line between lines for readability\n\n        lines.append(\"/\")\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundLineList-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundLineList.lines","title":"lines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lines: List[OutboundLine] = Field(default_factory=list, description='List of outbound boundary lines, each specifying x0, y0, dx, dy, and np')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundLineList-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundLineList.validate_lines_list","title":"validate_lines_list  <code>classmethod</code>","text":"<pre><code>validate_lines_list(v)\n</code></pre> <p>Validate the lines list.</p> Source code in <code>rompy_ww3/namelists/outbound.py</code> <pre><code>@field_validator('lines')\n@classmethod\ndef validate_lines_list(cls, v):\n    \"\"\"Validate the lines list.\"\"\"\n    if v is not None:\n        for i, line in enumerate(v):\n            if not isinstance(line, OutboundLine):\n                raise ValueError(f\"Line at index {i} must be of type OutboundLine, got {type(line)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.outbound.OutboundLineList.render","title":"render","text":"<pre><code>render() -&gt; str\n</code></pre> <p>Render the namelist content with unindexed parameters.</p> Source code in <code>rompy_ww3/namelists/outbound.py</code> <pre><code>def render(self) -&gt; str:\n    \"\"\"Render the namelist content with unindexed parameters.\"\"\"\n    lines = [\"&amp;OUTBND_LINE_NML\"]\n\n    for i, line in enumerate(self.lines, 1):\n        # Format as unindexed: OUTBND_LINE(I) = x0 y0 dx dy np\n        values = []\n        if line.x0 is not None:\n            values.append(str(line.x0))\n        if line.y0 is not None:\n            values.append(str(line.y0))\n        if line.dx is not None:\n            values.append(str(line.dx))\n        if line.dy is not None:\n            values.append(str(line.dy))\n        if line.np is not None:\n            values.append(str(line.np))\n\n        if values:\n            # Simple space-separated format - Fortran will read this correctly\n            spaced_values = \" \".join(values)\n            lines.append(f\"  OUTBND_LINE({i})         = {spaced_values}\")\n        lines.append(\"\")  # Add a blank line between lines for readability\n\n    lines.append(\"/\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/namelists/#spectra-output-namelist","title":"Spectra Output Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra","title":"Spectra","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>SPECTRA_NML namelist for WW3.</p> <p>The SPECTRA_NML namelist defines the type 1 (spectra) output configuration for point output in WAVEWATCH III. This namelist controls how full wave spectra are output for specific points in the model domain.</p> <p>Type 1 output provides the complete 2D wave spectrum at specified points, which can be used for detailed spectral analysis, verification against observations, or as input to other spectral models.</p> Source code in <code>rompy_ww3/namelists/spectra.py</code> <pre><code>class Spectra(NamelistBaseModel):\n    \"\"\"SPECTRA_NML namelist for WW3.\n\n    The SPECTRA_NML namelist defines the type 1 (spectra) output configuration for point output in WAVEWATCH III.\n    This namelist controls how full wave spectra are output for specific points in the model domain.\n\n    Type 1 output provides the complete 2D wave spectrum at specified points, which can be used for\n    detailed spectral analysis, verification against observations, or as input to other spectral models.\n    \"\"\"\n\n    output: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Output type for spectra data:\\n\"\n            \"  1: Print plots (human-readable spectral plots)\\n\"\n            \"  2: Table of 1-D spectra (frequency-integrated spectra)\\n\"\n            \"  3: Transfer file (binary format for model-to-model transfer)\\n\"\n            \"  4: Spectral partitioning (separated swell partitions)\\n\"\n            \"This determines the format and content of the spectral output.\"\n        ),\n        ge=1,\n        le=4\n    )\n    scale_fac: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Scale factor for spectral output. This controls scaling of spectral values:\\n\"\n            \"  -1: Disabled (no scaling applied)\\n\"\n            \"  Other values: Scaling factor applied to spectra\\n\"\n            \"This is used to adjust units or magnitudes of spectral values in output.\"\n        )\n    )\n    output_fac: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Output factor for normalized spectra:\\n\"\n            \"  0: Normalized spectra (energy normalized to 1)\\n\"\n            \"  Other values: Non-normalized spectra with specified factor\\n\"\n            \"This controls whether spectra are normalized or output with original magnitudes.\"\n        )\n    )\n\n    @field_validator('output')\n    @classmethod\n    def validate_output_type(cls, v):\n        \"\"\"Validate output type.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Output type must be 1, 2, 3, or 4, got {v}\")\n        return v\n\n    @field_validator('scale_fac')\n    @classmethod\n    def validate_scale_factor(cls, v):\n        \"\"\"Validate scale factor.\"\"\"\n        if v is not None and v == -1:\n            # -1 is valid (disabled)\n            pass\n        elif v is not None and not isinstance(v, int):\n            raise ValueError(f\"Scale factor must be an integer, got {type(v)}\")\n        return v\n\n    @field_validator('output_fac')\n    @classmethod\n    def validate_output_factor(cls, v):\n        \"\"\"Validate output factor.\"\"\"\n        if v is not None and not isinstance(v, int):\n            raise ValueError(f\"Output factor must be an integer, got {type(v)}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Optional[int] = Field(default=None, description='Output type for spectra data:\\n  1: Print plots (human-readable spectral plots)\\n  2: Table of 1-D spectra (frequency-integrated spectra)\\n  3: Transfer file (binary format for model-to-model transfer)\\n  4: Spectral partitioning (separated swell partitions)\\nThis determines the format and content of the spectral output.', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra.scale_fac","title":"scale_fac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scale_fac: Optional[int] = Field(default=None, description='Scale factor for spectral output. This controls scaling of spectral values:\\n  -1: Disabled (no scaling applied)\\n  Other values: Scaling factor applied to spectra\\nThis is used to adjust units or magnitudes of spectral values in output.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra.output_fac","title":"output_fac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_fac: Optional[int] = Field(default=None, description='Output factor for normalized spectra:\\n  0: Normalized spectra (energy normalized to 1)\\n  Other values: Non-normalized spectra with specified factor\\nThis controls whether spectra are normalized or output with original magnitudes.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra.validate_output_type","title":"validate_output_type  <code>classmethod</code>","text":"<pre><code>validate_output_type(v)\n</code></pre> <p>Validate output type.</p> Source code in <code>rompy_ww3/namelists/spectra.py</code> <pre><code>@field_validator('output')\n@classmethod\ndef validate_output_type(cls, v):\n    \"\"\"Validate output type.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Output type must be 1, 2, 3, or 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra.validate_scale_factor","title":"validate_scale_factor  <code>classmethod</code>","text":"<pre><code>validate_scale_factor(v)\n</code></pre> <p>Validate scale factor.</p> Source code in <code>rompy_ww3/namelists/spectra.py</code> <pre><code>@field_validator('scale_fac')\n@classmethod\ndef validate_scale_factor(cls, v):\n    \"\"\"Validate scale factor.\"\"\"\n    if v is not None and v == -1:\n        # -1 is valid (disabled)\n        pass\n    elif v is not None and not isinstance(v, int):\n        raise ValueError(f\"Scale factor must be an integer, got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.spectra.Spectra.validate_output_factor","title":"validate_output_factor  <code>classmethod</code>","text":"<pre><code>validate_output_factor(v)\n</code></pre> <p>Validate output factor.</p> Source code in <code>rompy_ww3/namelists/spectra.py</code> <pre><code>@field_validator('output_fac')\n@classmethod\ndef validate_output_factor(cls, v):\n    \"\"\"Validate output factor.\"\"\"\n    if v is not None and not isinstance(v, int):\n        raise ValueError(f\"Output factor must be an integer, got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#parameter-output-namelist","title":"Parameter Output Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.param.Param","title":"Param","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>PARAM_NML namelist for WW3.</p> <p>The PARAM_NML namelist defines the type 2 (mean parameter) output configuration for point output in WAVEWATCH III. This namelist controls how mean wave parameters are output for specific points in the model domain.</p> <p>Type 2 output provides statistical wave parameters derived from the spectra, such as significant wave height (HS), mean periods (T01, T02, Tp), mean direction (DIR),  directional spread (SPR), and peak direction (DP). This is the most commonly used output type for operational wave forecasting and model verification.</p> Source code in <code>rompy_ww3/namelists/param.py</code> <pre><code>class Param(NamelistBaseModel):\n    \"\"\"PARAM_NML namelist for WW3.\n\n    The PARAM_NML namelist defines the type 2 (mean parameter) output configuration for point output in WAVEWATCH III.\n    This namelist controls how mean wave parameters are output for specific points in the model domain.\n\n    Type 2 output provides statistical wave parameters derived from the spectra, such as\n    significant wave height (HS), mean periods (T01, T02, Tp), mean direction (DIR), \n    directional spread (SPR), and peak direction (DP). This is the most commonly used output type\n    for operational wave forecasting and model verification.\n    \"\"\"\n\n    output: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Output type for mean parameter data:\\n\"\n            \"  1: Forcing parameters (wind, current, etc.)\\n\"\n            \"  2: Mean wave parameters (HS, Tp, DIR, etc.)\\n\"\n            \"  3: Nondimensional parameters (U*, friction velocity scaled)\\n\"\n            \"  4: Nondimensional parameters (U10, 10m wind scaled)\\n\"\n            \"  5: Validation table format\\n\"\n            \"  6: WMO standard output format\\n\"\n            \"This determines the format and content of the mean parameter output.\"\n        ),\n        ge=1,\n        le=6\n    )\n\n    @field_validator('output')\n    @classmethod\n    def validate_output_type(cls, v):\n        \"\"\"Validate output type.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4, 5, 6]:\n            raise ValueError(f\"Output type must be 1-6, got {v}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.param.Param-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.param.Param.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Optional[int] = Field(default=None, description='Output type for mean parameter data:\\n  1: Forcing parameters (wind, current, etc.)\\n  2: Mean wave parameters (HS, Tp, DIR, etc.)\\n  3: Nondimensional parameters (U*, friction velocity scaled)\\n  4: Nondimensional parameters (U10, 10m wind scaled)\\n  5: Validation table format\\n  6: WMO standard output format\\nThis determines the format and content of the mean parameter output.', ge=1, le=6)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.param.Param-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.param.Param.validate_output_type","title":"validate_output_type  <code>classmethod</code>","text":"<pre><code>validate_output_type(v)\n</code></pre> <p>Validate output type.</p> Source code in <code>rompy_ww3/namelists/param.py</code> <pre><code>@field_validator('output')\n@classmethod\ndef validate_output_type(cls, v):\n    \"\"\"Validate output type.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4, 5, 6]:\n        raise ValueError(f\"Output type must be 1-6, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#source-terms-output-namelist","title":"Source Terms Output Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source","title":"Source","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>SOURCE_NML namelist for WW3.</p> <p>The SOURCE_NML namelist defines the type 3 (source terms) output configuration for point output in WAVEWATCH III. This namelist controls how source term information is output for specific points in the model domain.</p> <p>Type 3 output provides detailed information about the various source terms that contribute to wave growth and decay, including wind input, nonlinear wave-wave interactions, whitecapping dissipation, bottom friction, and ice effects. This output is valuable for process studies and understanding model physics.</p> Source code in <code>rompy_ww3/namelists/source.py</code> <pre><code>class Source(NamelistBaseModel):\n    \"\"\"SOURCE_NML namelist for WW3.\n\n    The SOURCE_NML namelist defines the type 3 (source terms) output configuration for point output in WAVEWATCH III.\n    This namelist controls how source term information is output for specific points in the model domain.\n\n    Type 3 output provides detailed information about the various source terms that contribute to\n    wave growth and decay, including wind input, nonlinear wave-wave interactions, whitecapping\n    dissipation, bottom friction, and ice effects. This output is valuable for process studies\n    and understanding model physics.\n    \"\"\"\n\n    output: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Output type for source term data:\\n\"\n            \"  1: Print plots (human-readable source term plots)\\n\"\n            \"  2: Table of 1-D S(f) (frequency-dependent source functions)\\n\"\n            \"  3: Table of 1-D inverse time scales (1/T = S/F, frequency-dependent)\\n\"\n            \"  4: Transfer file (binary format for model-to-model transfer)\\n\"\n            \"This determines the format and content of the source term output.\"\n        ),\n        ge=1,\n        le=4\n    )\n    scale_fac: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Scale factor for source term output. This controls scaling of source term values:\\n\"\n            \"  -1: Disabled (no scaling applied)\\n\"\n            \"  Other values: Scaling factor applied to source terms\\n\"\n            \"This is used to adjust units or magnitudes of source term values in output.\"\n        )\n    )\n    output_fac: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Output factor for normalized source terms:\\n\"\n            \"  0: Normalized source terms (energy normalized to 1)\\n\"\n            \"  Other values: Non-normalized source terms with specified factor\\n\"\n            \"This controls whether source terms are normalized or output with original magnitudes.\"\n        )\n    )\n    table_fac: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Table factor controlling dimensional/non-dimensional representation:\\n\"\n            \"  0: Dimensional source terms\\n\"\n            \"  1: Nondimensional in terms of U10 (10m wind speed scaled)\\n\"\n            \"  2: Nondimensional in terms of U* (friction velocity scaled)\\n\"\n            \"  3-5: Like 0-2 but with frequency normalized with peak frequency (fp)\\n\"\n            \"This controls the normalization scheme used for tabular source term output.\"\n        ),\n        ge=0,\n        le=5\n    )\n    spectrum: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to include spectrum in source term output (T) or not (F). \"\n            \"When True, the wave spectrum is included alongside source term data.\"\n        )\n    )\n    input: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to include input source term in output (T) or not (F). \"\n            \"When True, wind input source term information is included in the output.\"\n        )\n    )\n    interactions: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to include nonlinear interactions in output (T) or not (F). \"\n            \"When True, nonlinear wave-wave interaction source term information is included.\"\n        )\n    )\n    dissipation: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to include dissipation source term in output (T) or not (F). \"\n            \"When True, whitecapping and other dissipation source term information is included.\"\n        )\n    )\n    bottom: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to include bottom source term in output (T) or not (F). \"\n            \"When True, bottom friction source term information is included in the output.\"\n        )\n    )\n    ice: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to include ice source term in output (T) or not (F). \"\n            \"When True, ice-related source term information is included in the output.\"\n        )\n    )\n    total: Optional[bool] = Field(\n        default=None,\n        description=(\n            \"Flag to include total source term in output (T) or not (F). \"\n            \"When True, the sum of all source terms is included in the output.\"\n        )\n    )\n\n    @field_validator('output')\n    @classmethod\n    def validate_output_type(cls, v):\n        \"\"\"Validate output type.\"\"\"\n        if v is not None and v not in [1, 2, 3, 4]:\n            raise ValueError(f\"Output type must be 1, 2, 3, or 4, got {v}\")\n        return v\n\n    @field_validator('scale_fac')\n    @classmethod\n    def validate_scale_factor(cls, v):\n        \"\"\"Validate scale factor.\"\"\"\n        if v is not None and v == -1:\n            # -1 is valid (disabled)\n            pass\n        elif v is not None and not isinstance(v, int):\n            raise ValueError(f\"Scale factor must be an integer, got {type(v)}\")\n        return v\n\n    @field_validator('output_fac')\n    @classmethod\n    def validate_output_factor(cls, v):\n        \"\"\"Validate output factor.\"\"\"\n        if v is not None and not isinstance(v, int):\n            raise ValueError(f\"Output factor must be an integer, got {type(v)}\")\n        return v\n\n    @field_validator('table_fac')\n    @classmethod\n    def validate_table_factor(cls, v):\n        \"\"\"Validate table factor.\"\"\"\n        if v is not None and (v &lt; 0 or v &gt; 5):\n            raise ValueError(f\"Table factor must be 0-5, got {v}\")\n        return v\n\n    @field_validator('spectrum', 'input', 'interactions', 'dissipation', 'bottom', 'ice', 'total')\n    @classmethod\n    def validate_boolean_flags(cls, v):\n        \"\"\"Validate boolean flags are actually boolean.\"\"\"\n        if v is not None and not isinstance(v, bool):\n            raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.output","title":"output  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output: Optional[int] = Field(default=None, description='Output type for source term data:\\n  1: Print plots (human-readable source term plots)\\n  2: Table of 1-D S(f) (frequency-dependent source functions)\\n  3: Table of 1-D inverse time scales (1/T = S/F, frequency-dependent)\\n  4: Transfer file (binary format for model-to-model transfer)\\nThis determines the format and content of the source term output.', ge=1, le=4)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.scale_fac","title":"scale_fac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scale_fac: Optional[int] = Field(default=None, description='Scale factor for source term output. This controls scaling of source term values:\\n  -1: Disabled (no scaling applied)\\n  Other values: Scaling factor applied to source terms\\nThis is used to adjust units or magnitudes of source term values in output.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.output_fac","title":"output_fac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_fac: Optional[int] = Field(default=None, description='Output factor for normalized source terms:\\n  0: Normalized source terms (energy normalized to 1)\\n  Other values: Non-normalized source terms with specified factor\\nThis controls whether source terms are normalized or output with original magnitudes.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.table_fac","title":"table_fac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table_fac: Optional[int] = Field(default=None, description='Table factor controlling dimensional/non-dimensional representation:\\n  0: Dimensional source terms\\n  1: Nondimensional in terms of U10 (10m wind speed scaled)\\n  2: Nondimensional in terms of U* (friction velocity scaled)\\n  3-5: Like 0-2 but with frequency normalized with peak frequency (fp)\\nThis controls the normalization scheme used for tabular source term output.', ge=0, le=5)\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.spectrum","title":"spectrum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spectrum: Optional[bool] = Field(default=None, description='Flag to include spectrum in source term output (T) or not (F). When True, the wave spectrum is included alongside source term data.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.input","title":"input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input: Optional[bool] = Field(default=None, description='Flag to include input source term in output (T) or not (F). When True, wind input source term information is included in the output.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.interactions","title":"interactions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interactions: Optional[bool] = Field(default=None, description='Flag to include nonlinear interactions in output (T) or not (F). When True, nonlinear wave-wave interaction source term information is included.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.dissipation","title":"dissipation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dissipation: Optional[bool] = Field(default=None, description='Flag to include dissipation source term in output (T) or not (F). When True, whitecapping and other dissipation source term information is included.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.bottom","title":"bottom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bottom: Optional[bool] = Field(default=None, description='Flag to include bottom source term in output (T) or not (F). When True, bottom friction source term information is included in the output.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.ice","title":"ice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ice: Optional[bool] = Field(default=None, description='Flag to include ice source term in output (T) or not (F). When True, ice-related source term information is included in the output.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.total","title":"total  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total: Optional[bool] = Field(default=None, description='Flag to include total source term in output (T) or not (F). When True, the sum of all source terms is included in the output.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.validate_output_type","title":"validate_output_type  <code>classmethod</code>","text":"<pre><code>validate_output_type(v)\n</code></pre> <p>Validate output type.</p> Source code in <code>rompy_ww3/namelists/source.py</code> <pre><code>@field_validator('output')\n@classmethod\ndef validate_output_type(cls, v):\n    \"\"\"Validate output type.\"\"\"\n    if v is not None and v not in [1, 2, 3, 4]:\n        raise ValueError(f\"Output type must be 1, 2, 3, or 4, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.validate_scale_factor","title":"validate_scale_factor  <code>classmethod</code>","text":"<pre><code>validate_scale_factor(v)\n</code></pre> <p>Validate scale factor.</p> Source code in <code>rompy_ww3/namelists/source.py</code> <pre><code>@field_validator('scale_fac')\n@classmethod\ndef validate_scale_factor(cls, v):\n    \"\"\"Validate scale factor.\"\"\"\n    if v is not None and v == -1:\n        # -1 is valid (disabled)\n        pass\n    elif v is not None and not isinstance(v, int):\n        raise ValueError(f\"Scale factor must be an integer, got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.validate_output_factor","title":"validate_output_factor  <code>classmethod</code>","text":"<pre><code>validate_output_factor(v)\n</code></pre> <p>Validate output factor.</p> Source code in <code>rompy_ww3/namelists/source.py</code> <pre><code>@field_validator('output_fac')\n@classmethod\ndef validate_output_factor(cls, v):\n    \"\"\"Validate output factor.\"\"\"\n    if v is not None and not isinstance(v, int):\n        raise ValueError(f\"Output factor must be an integer, got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.validate_table_factor","title":"validate_table_factor  <code>classmethod</code>","text":"<pre><code>validate_table_factor(v)\n</code></pre> <p>Validate table factor.</p> Source code in <code>rompy_ww3/namelists/source.py</code> <pre><code>@field_validator('table_fac')\n@classmethod\ndef validate_table_factor(cls, v):\n    \"\"\"Validate table factor.\"\"\"\n    if v is not None and (v &lt; 0 or v &gt; 5):\n        raise ValueError(f\"Table factor must be 0-5, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.source.Source.validate_boolean_flags","title":"validate_boolean_flags  <code>classmethod</code>","text":"<pre><code>validate_boolean_flags(v)\n</code></pre> <p>Validate boolean flags are actually boolean.</p> Source code in <code>rompy_ww3/namelists/source.py</code> <pre><code>@field_validator('spectrum', 'input', 'interactions', 'dissipation', 'bottom', 'ice', 'total')\n@classmethod\ndef validate_boolean_flags(cls, v):\n    \"\"\"Validate boolean flags are actually boolean.\"\"\"\n    if v is not None and not isinstance(v, bool):\n        raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/namelists/#restart-update-namelist","title":"Restart Update Namelist","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate","title":"RestartUpdate","text":"<p>               Bases: <code>NamelistBaseModel</code></p> <p>UPRSTR_NML namelist for WW3.</p> <p>The UPRSTR_NML namelist defines restart file update parameters for WAVEWATCH III. This namelist is used to update existing restart files with new data, allowing for adjustments to restart conditions without reinitializing the entire model state.</p> <p>The namelist allows updating various components of the restart file using different methods (replace, add, multiply) and provides control over which fields to update.</p> Source code in <code>rompy_ww3/namelists/restartupdate.py</code> <pre><code>class RestartUpdate(NamelistBaseModel):\n    \"\"\"UPRSTR_NML namelist for WW3.\n\n    The UPRSTR_NML namelist defines restart file update parameters for WAVEWATCH III.\n    This namelist is used to update existing restart files with new data, allowing\n    for adjustments to restart conditions without reinitializing the entire model state.\n\n    The namelist allows updating various components of the restart file using different\n    methods (replace, add, multiply) and provides control over which fields to update.\n    \"\"\"\n\n    # Update configuration\n    update_time: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Time for restart file update in format 'YYYYMMDD HHMMSS'. \"\n            \"This specifies when to perform the restart file update during the simulation. \"\n            \"Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\"\n        )\n    )\n    update_stride: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Time stride for restart file updates in seconds as a string. \"\n            \"This specifies the time interval between restart file updates. \"\n            \"Example: '3600' for hourly updates, '21600' for 6-hourly updates.\"\n        )\n    )\n\n    # File configuration\n    input_restart: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Path to the input restart file that will be updated. \"\n            \"This should point to an existing restart file that will serve as the base \"\n            \"for the update operation.\"\n        )\n    )\n    output_restart: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Path to the output restart file that will contain the updated data. \"\n            \"The updated restart information will be written to this file.\"\n        )\n    )\n\n    # Fields to update\n    wave_field: Optional[bool] = Field(\n        default=None,\n        description=\"Flag to update wave field (T/F). If true, the wave spectral data will be updated.\"\n    )\n    water_level: Optional[bool] = Field(\n        default=None,\n        description=\"Flag to update water level (T/F). If true, the water level data will be updated.\"\n    )\n    current: Optional[bool] = Field(\n        default=None,\n        description=\"Flag to update current (T/F). If true, the ocean current data will be updated.\"\n    )\n    ice: Optional[bool] = Field(\n        default=None,\n        description=\"Flag to update ice fields (T/F). If true, ice-related data will be updated.\"\n    )\n    wind: Optional[bool] = Field(\n        default=None,\n        description=\"Flag to update wind fields (T/F). If true, wind field data will be updated.\"\n    )\n\n    # Update method\n    update_method: Optional[str] = Field(\n        default=None,\n        description=(\n            \"Method for updating the restart fields:\\n\"\n            \"  'replace': Replace the field values with new values\\n\"\n            \"  'add': Add the new values to the existing field values\\n\"\n            \"  'multiply': Multiply the existing field values by the new values\"\n        )\n    )\n\n    @field_validator('update_time')\n    @classmethod\n    def validate_update_time_format(cls, v):\n        \"\"\"Validate date format for update_time.\"\"\"\n        if v is not None:\n            return validate_date_format(v)\n        return v\n\n    @field_validator('update_method')\n    @classmethod\n    def validate_update_method(cls, v):\n        \"\"\"Validate update method is valid.\"\"\"\n        if v is not None:\n            valid_methods = {'replace', 'add', 'multiply', 'REPLACE', 'ADD', 'MULTIPLY'}\n            if v.upper() not in valid_methods:\n                raise ValueError(f\"Update method must be one of replace, add, multiply, got {v}\")\n        return v.upper() if v is not None else v\n\n    @field_validator('wave_field', 'water_level', 'current', 'ice', 'wind')\n    @classmethod\n    def validate_boolean_flags(cls, v):\n        \"\"\"Validate boolean flags are actually boolean.\"\"\"\n        if v is not None and not isinstance(v, bool):\n            raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n        return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate-attributes","title":"Attributes","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.update_time","title":"update_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>update_time: Optional[str] = Field(default=None, description=\"Time for restart file update in format 'YYYYMMDD HHMMSS'. This specifies when to perform the restart file update during the simulation. Example: '20100101 000000' for January 1, 2010 at 00:00:00 UTC.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.update_stride","title":"update_stride  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>update_stride: Optional[str] = Field(default=None, description=\"Time stride for restart file updates in seconds as a string. This specifies the time interval between restart file updates. Example: '3600' for hourly updates, '21600' for 6-hourly updates.\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.input_restart","title":"input_restart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>input_restart: Optional[str] = Field(default=None, description='Path to the input restart file that will be updated. This should point to an existing restart file that will serve as the base for the update operation.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.output_restart","title":"output_restart  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_restart: Optional[str] = Field(default=None, description='Path to the output restart file that will contain the updated data. The updated restart information will be written to this file.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.wave_field","title":"wave_field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wave_field: Optional[bool] = Field(default=None, description='Flag to update wave field (T/F). If true, the wave spectral data will be updated.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.water_level","title":"water_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>water_level: Optional[bool] = Field(default=None, description='Flag to update water level (T/F). If true, the water level data will be updated.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.current","title":"current  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current: Optional[bool] = Field(default=None, description='Flag to update current (T/F). If true, the ocean current data will be updated.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.ice","title":"ice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ice: Optional[bool] = Field(default=None, description='Flag to update ice fields (T/F). If true, ice-related data will be updated.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.wind","title":"wind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wind: Optional[bool] = Field(default=None, description='Flag to update wind fields (T/F). If true, wind field data will be updated.')\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.update_method","title":"update_method  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>update_method: Optional[str] = Field(default=None, description=\"Method for updating the restart fields:\\n  'replace': Replace the field values with new values\\n  'add': Add the new values to the existing field values\\n  'multiply': Multiply the existing field values by the new values\")\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate-functions","title":"Functions","text":""},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.validate_update_time_format","title":"validate_update_time_format  <code>classmethod</code>","text":"<pre><code>validate_update_time_format(v)\n</code></pre> <p>Validate date format for update_time.</p> Source code in <code>rompy_ww3/namelists/restartupdate.py</code> <pre><code>@field_validator('update_time')\n@classmethod\ndef validate_update_time_format(cls, v):\n    \"\"\"Validate date format for update_time.\"\"\"\n    if v is not None:\n        return validate_date_format(v)\n    return v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.validate_update_method","title":"validate_update_method  <code>classmethod</code>","text":"<pre><code>validate_update_method(v)\n</code></pre> <p>Validate update method is valid.</p> Source code in <code>rompy_ww3/namelists/restartupdate.py</code> <pre><code>@field_validator('update_method')\n@classmethod\ndef validate_update_method(cls, v):\n    \"\"\"Validate update method is valid.\"\"\"\n    if v is not None:\n        valid_methods = {'replace', 'add', 'multiply', 'REPLACE', 'ADD', 'MULTIPLY'}\n        if v.upper() not in valid_methods:\n            raise ValueError(f\"Update method must be one of replace, add, multiply, got {v}\")\n    return v.upper() if v is not None else v\n</code></pre>"},{"location":"reference/namelists/#rompy_ww3.namelists.restartupdate.RestartUpdate.validate_boolean_flags","title":"validate_boolean_flags  <code>classmethod</code>","text":"<pre><code>validate_boolean_flags(v)\n</code></pre> <p>Validate boolean flags are actually boolean.</p> Source code in <code>rompy_ww3/namelists/restartupdate.py</code> <pre><code>@field_validator('wave_field', 'water_level', 'current', 'ice', 'wind')\n@classmethod\ndef validate_boolean_flags(cls, v):\n    \"\"\"Validate boolean flags are actually boolean.\"\"\"\n    if v is not None and not isinstance(v, bool):\n        raise ValueError(f\"Flag must be boolean (T/F), got {type(v)}\")\n    return v\n</code></pre>"},{"location":"reference/source/","title":"Source API Reference","text":""},{"location":"reference/source/#rompy_ww3.source.Ww3Source","title":"Ww3Source","text":"<p>               Bases: <code>SourceBase</code></p> <p>Ww3 source class with WW3-specific data source capabilities.</p> <p>This class extends SourceBase with WW3-specific data source handling for wave model inputs.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>class Ww3Source(SourceBase):\n    \"\"\"Ww3 source class with WW3-specific data source capabilities.\n\n    This class extends SourceBase with WW3-specific data source handling for wave model inputs.\n    \"\"\"\n\n    model_type: Literal[\"ww3\"] = Field(\n        default=\"ww3\",\n        description=\"Model type discriminator\",\n    )\n    uri: str | Path = Field(description=\"Path to the dataset\")\n    kwargs: dict = Field(\n        default={},\n        description=\"Keyword arguments to pass to xarray.open_dataset\",\n    )\n\n    # WW3-specific source parameters\n    data_type: Optional[str] = Field(\n        default=None,\n        description=\"Type of data: 'winds', 'currents', 'water_levels', 'ice_conc', 'spectra', etc.\",\n    )\n\n    file_format: Optional[str] = Field(\n        default=None,\n        description=\"File format: 'netcdf', 'binary', 'ascii', 'grib', etc.\",\n    )\n\n    # Temporal parameters\n    start_time: Optional[str] = Field(\n        default=None, description=\"Start time for data (yyyymmdd hhmmss)\"\n    )\n    end_time: Optional[str] = Field(\n        default=None, description=\"End time for data (yyyymmdd hhmmss)\"\n    )\n    time_step: Optional[int] = Field(default=None, description=\"Time step in seconds\")\n\n    # Spatial parameters\n    spatial_resolution: Optional[str] = Field(\n        default=None, description=\"Spatial resolution description\"\n    )\n\n    # Variable mapping for WW3\n    variable_mapping: Optional[Dict[str, str]] = Field(\n        default=None, description=\"Mapping of source variables to WW3 variable names\"\n    )\n\n    # Data filtering parameters\n    variables: Optional[List[str]] = Field(\n        default=None, description=\"List of variables to extract from the source\"\n    )\n\n    # Quality control parameters\n    min_value: Optional[float] = Field(\n        default=None, description=\"Minimum valid value for data\"\n    )\n    max_value: Optional[float] = Field(\n        default=None, description=\"Maximum valid value for data\"\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_source_parameters(self) -&gt; \"Ww3Source\":\n        \"\"\"Validate source parameters.\"\"\"\n        # Validate data type\n        valid_data_types = [\n            \"winds\",\n            \"currents\",\n            \"water_levels\",\n            \"ice_conc\",\n            \"air_density\",\n            \"atm_momentum\",\n            \"spectra\",\n            \"mean\",\n            \"spec1d\",\n            \"mud_density\",\n            \"mud_thickness\",\n            \"mud_viscosity\",\n        ]\n        if self.data_type and self.data_type not in valid_data_types:\n            raise ValueError(f\"data_type must be one of {valid_data_types}\")\n\n        # Validate file format\n        valid_formats = [\"netcdf\", \"binary\", \"ascii\", \"grib\"]\n        if self.file_format and self.file_format not in valid_formats:\n            raise ValueError(f\"file_format must be one of {valid_formats}\")\n\n        # Validate time step\n        if self.time_step is not None and self.time_step &lt;= 0:\n            raise ValueError(\"time_step must be positive\")\n\n        # Validate value ranges\n        if self.min_value is not None and self.max_value is not None:\n            if self.min_value &gt;= self.max_value:\n                raise ValueError(\"min_value must be less than max_value\")\n\n        return self\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation for this source class.\"\"\"\n        return f\"Ww3Source(uri={self.uri}, data_type={self.data_type})\"\n\n    def _open(self) -&gt; xr.Dataset:\n        \"\"\"This method needs to return an xarray Dataset object.\"\"\"\n        ds = xr.open_dataset(self.uri, **self.kwargs)\n\n        # Apply variable filtering if specified\n        if self.variables:\n            ds = ds[self.variables]\n\n        return ds\n\n    def get_ww3_variable_name(self, source_var: str) -&gt; str:\n        \"\"\"Get the WW3 variable name for a source variable.\n\n        Args:\n            source_var: The variable name in the source data\n\n        Returns:\n            The corresponding WW3 variable name\n        \"\"\"\n        if self.variable_mapping and source_var in self.variable_mapping:\n            return self.variable_mapping[source_var]\n\n        # Default mappings for common variables\n        default_mapping = {\n            # Winds\n            \"u_wind\": \"u10\",\n            \"v_wind\": \"v10\",\n            \"wind_u\": \"u10\",\n            \"wind_v\": \"v10\",\n            \"wind_speed\": \"wspd\",\n            \"wind_direction\": \"wdir\",\n            # Currents\n            \"u_current\": \"uocn\",\n            \"v_current\": \"vocn\",\n            \"current_u\": \"uocn\",\n            \"current_v\": \"vocn\",\n            # Water levels\n            \"sea_surface_height\": \"ssh\",\n            \"water_level\": \"ssh\",\n            \"ssh\": \"ssh\",\n            # Ice\n            \"ice_concentration\": \"aic\",\n            \"ice_thickness\": \"hit\",\n            # Air density\n            \"air_density\": \"rhoair\",\n            # Spectra (for assimilation)\n            \"wave_spectrum\": \"spec\",\n            \"wave_energy_spectrum\": \"spec\",\n        }\n\n        return default_mapping.get(source_var, source_var)\n\n    def generate_source_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Generate configuration dictionary for this source.\"\"\"\n        config = {\n            \"uri\": str(self.uri),\n            \"data_type\": self.data_type,\n            \"file_format\": self.file_format,\n            \"start_time\": self.start_time,\n            \"end_time\": self.end_time,\n            \"time_step\": self.time_step,\n            \"spatial_resolution\": self.spatial_resolution,\n            \"variables\": self.variables,\n            \"min_value\": self.min_value,\n            \"max_value\": self.max_value,\n        }\n\n        # Remove None values\n        config = {k: v for k, v in config.items() if v is not None}\n\n        return config\n\n    def write_source_config(\n        self, workdir: Path, filename: str = \"source_config.txt\"\n    ) -&gt; None:\n        \"\"\"Write source configuration to a file.\"\"\"\n        workdir.mkdir(parents=True, exist_ok=True)\n\n        config_file = workdir / filename\n        config = self.generate_source_config()\n\n        with open(config_file, \"w\") as f:\n            f.write(\"# WW3 Source Configuration\\n\")\n            for key, value in config.items():\n                if isinstance(value, list):\n                    f.write(f\"{key}: {', '.join(map(str, value))}\\n\")\n                else:\n                    f.write(f\"{key}: {value}\\n\")\n\n        logger.info(f\"Wrote source configuration to {config_file}\")\n\n    def get_template_context(self) -&gt; Dict[str, Any]:\n        \"\"\"Generate template context for Jinja2 templates.\n\n        Returns:\n            Dictionary containing source parameters for templates.\n        \"\"\"\n        return {\n            \"uri\": str(self.uri),\n            \"data_type\": self.data_type,\n            \"file_format\": self.file_format,\n            \"start_time\": self.start_time,\n            \"end_time\": self.end_time,\n            \"time_step\": self.time_step,\n            \"spatial_resolution\": self.spatial_resolution,\n            \"variables\": self.variables,\n            \"min_value\": self.min_value,\n            \"max_value\": self.max_value,\n            \"variable_mapping\": self.variable_mapping,\n        }\n\n    def get_ww3_variable_mapping(self) -&gt; Dict[str, str]:\n        \"\"\"Get the complete WW3 variable mapping.\n\n        Returns:\n            Dictionary mapping source variable names to WW3 variable names.\n        \"\"\"\n        # Start with default mappings\n        default_mapping = {\n            # Winds\n            \"u_wind\": \"u10\",\n            \"v_wind\": \"v10\",\n            \"wind_u\": \"u10\",\n            \"wind_v\": \"v10\",\n            \"wind_speed\": \"wspd\",\n            \"wind_direction\": \"wdir\",\n            # Currents\n            \"u_current\": \"uocn\",\n            \"v_current\": \"vocn\",\n            \"current_u\": \"uocn\",\n            \"current_v\": \"vocn\",\n            # Water levels\n            \"sea_surface_height\": \"ssh\",\n            \"water_level\": \"ssh\",\n            \"ssh\": \"ssh\",\n            # Ice\n            \"ice_concentration\": \"aic\",\n            \"ice_thickness\": \"hit\",\n            # Air density\n            \"air_density\": \"rhoair\",\n            # Spectra (for assimilation)\n            \"wave_spectrum\": \"spec\",\n            \"wave_energy_spectrum\": \"spec\",\n        }\n\n        # Update with custom mappings if provided\n        if self.variable_mapping:\n            default_mapping.update(self.variable_mapping)\n\n        return default_mapping\n\n    def is_time_range_valid(self) -&gt; bool:\n        \"\"\"Check if the time range is valid.\n\n        Returns:\n            True if both start_time and end_time are provided and start_time &lt; end_time, False otherwise.\n        \"\"\"\n        if not self.start_time or not self.end_time:\n            return False\n\n        # Simple string comparison for yyyymmdd hhmmss format\n        return self.start_time &lt; self.end_time\n\n    def get_data_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Get information about the data in this source.\n\n        Returns:\n            Dictionary with information about the data.\n        \"\"\"\n        try:\n            ds = self._open()\n            info = {\n                \"variables\": list(ds.data_vars.keys()),\n                \"dimensions\": dict(ds.dims),\n                \"coordinates\": list(ds.coords.keys()),\n            }\n            ds.close()\n            return info\n        except Exception as e:\n            logger.warning(f\"Could not get data info: {e}\")\n            return {\n                \"variables\": [],\n                \"dimensions\": {},\n                \"coordinates\": [],\n                \"error\": str(e),\n            }\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source-attributes","title":"Attributes","text":""},{"location":"reference/source/#rompy_ww3.source.Ww3Source.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Literal['ww3'] = Field(default='ww3', description='Model type discriminator')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.uri","title":"uri  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uri: str | Path = Field(description='Path to the dataset')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.kwargs","title":"kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kwargs: dict = Field(default={}, description='Keyword arguments to pass to xarray.open_dataset')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.data_type","title":"data_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_type: Optional[str] = Field(default=None, description=\"Type of data: 'winds', 'currents', 'water_levels', 'ice_conc', 'spectra', etc.\")\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.file_format","title":"file_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_format: Optional[str] = Field(default=None, description=\"File format: 'netcdf', 'binary', 'ascii', 'grib', etc.\")\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.start_time","title":"start_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_time: Optional[str] = Field(default=None, description='Start time for data (yyyymmdd hhmmss)')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.end_time","title":"end_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_time: Optional[str] = Field(default=None, description='End time for data (yyyymmdd hhmmss)')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.time_step","title":"time_step  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time_step: Optional[int] = Field(default=None, description='Time step in seconds')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.spatial_resolution","title":"spatial_resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spatial_resolution: Optional[str] = Field(default=None, description='Spatial resolution description')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.variable_mapping","title":"variable_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variable_mapping: Optional[Dict[str, str]] = Field(default=None, description='Mapping of source variables to WW3 variable names')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: Optional[List[str]] = Field(default=None, description='List of variables to extract from the source')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.min_value","title":"min_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_value: Optional[float] = Field(default=None, description='Minimum valid value for data')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.max_value","title":"max_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_value: Optional[float] = Field(default=None, description='Maximum valid value for data')\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source-functions","title":"Functions","text":""},{"location":"reference/source/#rompy_ww3.source.Ww3Source.validate_source_parameters","title":"validate_source_parameters","text":"<pre><code>validate_source_parameters() -&gt; Ww3Source\n</code></pre> <p>Validate source parameters.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_source_parameters(self) -&gt; \"Ww3Source\":\n    \"\"\"Validate source parameters.\"\"\"\n    # Validate data type\n    valid_data_types = [\n        \"winds\",\n        \"currents\",\n        \"water_levels\",\n        \"ice_conc\",\n        \"air_density\",\n        \"atm_momentum\",\n        \"spectra\",\n        \"mean\",\n        \"spec1d\",\n        \"mud_density\",\n        \"mud_thickness\",\n        \"mud_viscosity\",\n    ]\n    if self.data_type and self.data_type not in valid_data_types:\n        raise ValueError(f\"data_type must be one of {valid_data_types}\")\n\n    # Validate file format\n    valid_formats = [\"netcdf\", \"binary\", \"ascii\", \"grib\"]\n    if self.file_format and self.file_format not in valid_formats:\n        raise ValueError(f\"file_format must be one of {valid_formats}\")\n\n    # Validate time step\n    if self.time_step is not None and self.time_step &lt;= 0:\n        raise ValueError(\"time_step must be positive\")\n\n    # Validate value ranges\n    if self.min_value is not None and self.max_value is not None:\n        if self.min_value &gt;= self.max_value:\n            raise ValueError(\"min_value must be less than max_value\")\n\n    return self\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.get_ww3_variable_name","title":"get_ww3_variable_name","text":"<pre><code>get_ww3_variable_name(source_var: str) -&gt; str\n</code></pre> <p>Get the WW3 variable name for a source variable.</p> <p>Parameters:</p> Name Type Description Default <code>source_var</code> <code>str</code> <p>The variable name in the source data</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding WW3 variable name</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>def get_ww3_variable_name(self, source_var: str) -&gt; str:\n    \"\"\"Get the WW3 variable name for a source variable.\n\n    Args:\n        source_var: The variable name in the source data\n\n    Returns:\n        The corresponding WW3 variable name\n    \"\"\"\n    if self.variable_mapping and source_var in self.variable_mapping:\n        return self.variable_mapping[source_var]\n\n    # Default mappings for common variables\n    default_mapping = {\n        # Winds\n        \"u_wind\": \"u10\",\n        \"v_wind\": \"v10\",\n        \"wind_u\": \"u10\",\n        \"wind_v\": \"v10\",\n        \"wind_speed\": \"wspd\",\n        \"wind_direction\": \"wdir\",\n        # Currents\n        \"u_current\": \"uocn\",\n        \"v_current\": \"vocn\",\n        \"current_u\": \"uocn\",\n        \"current_v\": \"vocn\",\n        # Water levels\n        \"sea_surface_height\": \"ssh\",\n        \"water_level\": \"ssh\",\n        \"ssh\": \"ssh\",\n        # Ice\n        \"ice_concentration\": \"aic\",\n        \"ice_thickness\": \"hit\",\n        # Air density\n        \"air_density\": \"rhoair\",\n        # Spectra (for assimilation)\n        \"wave_spectrum\": \"spec\",\n        \"wave_energy_spectrum\": \"spec\",\n    }\n\n    return default_mapping.get(source_var, source_var)\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.generate_source_config","title":"generate_source_config","text":"<pre><code>generate_source_config() -&gt; Dict[str, Any]\n</code></pre> <p>Generate configuration dictionary for this source.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>def generate_source_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Generate configuration dictionary for this source.\"\"\"\n    config = {\n        \"uri\": str(self.uri),\n        \"data_type\": self.data_type,\n        \"file_format\": self.file_format,\n        \"start_time\": self.start_time,\n        \"end_time\": self.end_time,\n        \"time_step\": self.time_step,\n        \"spatial_resolution\": self.spatial_resolution,\n        \"variables\": self.variables,\n        \"min_value\": self.min_value,\n        \"max_value\": self.max_value,\n    }\n\n    # Remove None values\n    config = {k: v for k, v in config.items() if v is not None}\n\n    return config\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.write_source_config","title":"write_source_config","text":"<pre><code>write_source_config(workdir: Path, filename: str = 'source_config.txt') -&gt; None\n</code></pre> <p>Write source configuration to a file.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>def write_source_config(\n    self, workdir: Path, filename: str = \"source_config.txt\"\n) -&gt; None:\n    \"\"\"Write source configuration to a file.\"\"\"\n    workdir.mkdir(parents=True, exist_ok=True)\n\n    config_file = workdir / filename\n    config = self.generate_source_config()\n\n    with open(config_file, \"w\") as f:\n        f.write(\"# WW3 Source Configuration\\n\")\n        for key, value in config.items():\n            if isinstance(value, list):\n                f.write(f\"{key}: {', '.join(map(str, value))}\\n\")\n            else:\n                f.write(f\"{key}: {value}\\n\")\n\n    logger.info(f\"Wrote source configuration to {config_file}\")\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.get_template_context","title":"get_template_context","text":"<pre><code>get_template_context() -&gt; Dict[str, Any]\n</code></pre> <p>Generate template context for Jinja2 templates.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing source parameters for templates.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>def get_template_context(self) -&gt; Dict[str, Any]:\n    \"\"\"Generate template context for Jinja2 templates.\n\n    Returns:\n        Dictionary containing source parameters for templates.\n    \"\"\"\n    return {\n        \"uri\": str(self.uri),\n        \"data_type\": self.data_type,\n        \"file_format\": self.file_format,\n        \"start_time\": self.start_time,\n        \"end_time\": self.end_time,\n        \"time_step\": self.time_step,\n        \"spatial_resolution\": self.spatial_resolution,\n        \"variables\": self.variables,\n        \"min_value\": self.min_value,\n        \"max_value\": self.max_value,\n        \"variable_mapping\": self.variable_mapping,\n    }\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.get_ww3_variable_mapping","title":"get_ww3_variable_mapping","text":"<pre><code>get_ww3_variable_mapping() -&gt; Dict[str, str]\n</code></pre> <p>Get the complete WW3 variable mapping.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary mapping source variable names to WW3 variable names.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>def get_ww3_variable_mapping(self) -&gt; Dict[str, str]:\n    \"\"\"Get the complete WW3 variable mapping.\n\n    Returns:\n        Dictionary mapping source variable names to WW3 variable names.\n    \"\"\"\n    # Start with default mappings\n    default_mapping = {\n        # Winds\n        \"u_wind\": \"u10\",\n        \"v_wind\": \"v10\",\n        \"wind_u\": \"u10\",\n        \"wind_v\": \"v10\",\n        \"wind_speed\": \"wspd\",\n        \"wind_direction\": \"wdir\",\n        # Currents\n        \"u_current\": \"uocn\",\n        \"v_current\": \"vocn\",\n        \"current_u\": \"uocn\",\n        \"current_v\": \"vocn\",\n        # Water levels\n        \"sea_surface_height\": \"ssh\",\n        \"water_level\": \"ssh\",\n        \"ssh\": \"ssh\",\n        # Ice\n        \"ice_concentration\": \"aic\",\n        \"ice_thickness\": \"hit\",\n        # Air density\n        \"air_density\": \"rhoair\",\n        # Spectra (for assimilation)\n        \"wave_spectrum\": \"spec\",\n        \"wave_energy_spectrum\": \"spec\",\n    }\n\n    # Update with custom mappings if provided\n    if self.variable_mapping:\n        default_mapping.update(self.variable_mapping)\n\n    return default_mapping\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.is_time_range_valid","title":"is_time_range_valid","text":"<pre><code>is_time_range_valid() -&gt; bool\n</code></pre> <p>Check if the time range is valid.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if both start_time and end_time are provided and start_time &lt; end_time, False otherwise.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>def is_time_range_valid(self) -&gt; bool:\n    \"\"\"Check if the time range is valid.\n\n    Returns:\n        True if both start_time and end_time are provided and start_time &lt; end_time, False otherwise.\n    \"\"\"\n    if not self.start_time or not self.end_time:\n        return False\n\n    # Simple string comparison for yyyymmdd hhmmss format\n    return self.start_time &lt; self.end_time\n</code></pre>"},{"location":"reference/source/#rompy_ww3.source.Ww3Source.get_data_info","title":"get_data_info","text":"<pre><code>get_data_info() -&gt; Dict[str, Any]\n</code></pre> <p>Get information about the data in this source.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with information about the data.</p> Source code in <code>rompy_ww3/source.py</code> <pre><code>def get_data_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get information about the data in this source.\n\n    Returns:\n        Dictionary with information about the data.\n    \"\"\"\n    try:\n        ds = self._open()\n        info = {\n            \"variables\": list(ds.data_vars.keys()),\n            \"dimensions\": dict(ds.dims),\n            \"coordinates\": list(ds.coords.keys()),\n        }\n        ds.close()\n        return info\n    except Exception as e:\n        logger.warning(f\"Could not get data info: {e}\")\n        return {\n            \"variables\": [],\n            \"dimensions\": {},\n            \"coordinates\": [],\n            \"error\": str(e),\n        }\n</code></pre>"}]}