"""WW3 namelist composition and validation system."""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field, validator

from .namelists import (
    Domain, Input, OutputType, OutputDate, HomogCount, HomogInput
)
from .config import Config

logger = logging.getLogger(__name__)


class NamelistComposition(BaseModel):
    """Compose and validate WW3 namelists for a complete model configuration."""
    
    # Core namelist components
    domain: Optional[Domain] = Field(
        default=None,
        description="DOMAIN_NML configuration"
    )
    input_nml: Optional[Input] = Field(
        default=None,
        description="INPUT_NML configuration"
    )
    output_type: Optional[OutputType] = Field(
        default=None,
        description="OUTPUT_TYPE_NML configuration"
    )
    output_date: Optional[OutputDate] = Field(
        default=None,
        description="OUTPUT_DATE_NML configuration"
    )
    homog_count: Optional[HomogCount] = Field(
        default=None,
        description="HOMOG_COUNT_NML configuration"
    )
    homog_input: Optional[List[HomogInput]] = Field(
        default=None,
        description="HOMOG_INPUT_NML configurations"
    )
    
    class Config:
        arbitrary_types_allowed = True
    
    @validator('domain')
    def validate_domain(cls, v):
        """Validate DOMAIN_NML configuration."""
        if v is not None:
            # Ensure start and stop times are provided
            if v.start is None:
                raise ValueError("DOMAIN_NML requires start time")
            if v.stop is None:
                raise ValueError("DOMAIN_NML requires stop time")
        return v
    
    @validator('input_nml')
    def validate_input(cls, v):
        """Validate INPUT_NML configuration."""
        # Add input validation logic here if needed
        return v
    
    @validator('homog_input')
    def validate_homog_input(cls, v, values):
        """Validate HOMOG_INPUT_NML configurations against HOMOG_COUNT_NML."""
        if v is not None and 'homog_count' in values:
            homog_count = values.get('homog_count')
            if homog_count is not None:
                # Check that the number of inputs matches the counts
                input_counts = {}
                for homog_input in v:
                    if homog_input.name:
                        input_type = homog_input.name
                        input_counts[input_type] = input_counts.get(input_type, 0) + 1
                
                # Validate against homog_count
                if homog_count.n_wnd is not None and input_counts.get('WND', 0) != homog_count.n_wnd:
                    logger.warning(f"Mismatch between HOMOG_COUNT%N_WND ({homog_count.n_wnd}) and actual WND inputs ({input_counts.get('WND', 0)})")
                    
        return v
    
    def render_all_namelists(self) -> Dict[str, str]:
        """Render all namelists as strings."""
        namelists = {}
        
        if self.domain:
            namelists["domain.nml"] = self.domain.render()
            
        if self.input_nml:
            namelists["input.nml"] = self.input_nml.render()
            
        if self.output_type:
            namelists["output_type.nml"] = self.output_type.render()
            
        if self.output_date:
            namelists["output_date.nml"] = self.output_date.render()
            
        if self.homog_count:
            namelists["homog_count.nml"] = self.homog_count.render()
            
        # For homog_input, we need to combine them into a single namelist
        if self.homog_input:
            homog_input_content = "! Generated by rompy-ww3\n&HOMOG_INPUT_NML\n"
            for i, homog_input in enumerate(self.homog_input, 1):
                if homog_input.name:
                    homog_input_content += f"  HOMOG_INPUT({i})%NAME   = '{homog_input.name}'\n"
                if homog_input.date:
                    homog_input_content += f"  HOMOG_INPUT({i})%DATE   = '{homog_input.date}'\n"
                if homog_input.value1 is not None:
                    homog_input_content += f"  HOMOG_INPUT({i})%VALUE1 = {homog_input.value1}\n"
                if homog_input.value2 is not None:
                    homog_input_content += f"  HOMOG_INPUT({i})%VALUE2 = {homog_input.value2}\n"
                if homog_input.value3 is not None:
                    homog_input_content += f"  HOMOG_INPUT({i})%VALUE3 = {homog_input.value3}\n"
                homog_input_content += "\n"
            homog_input_content += "/\n"
            namelists["homog_input.nml"] = homog_input_content
            
        return namelists
    
    def write_all_namelists(self, workdir: Path) -> None:
        """Write all namelists to files."""
        workdir.mkdir(parents=True, exist_ok=True)
        
        namelists = self.render_all_namelists()
        
        for filename, content in namelists.items():
            filepath = workdir / filename
            with open(filepath, "w") as f:
                f.write(content)
                
        logger.info(f"Wrote {len(namelists)} namelist files to {workdir}")
    
    @classmethod
    def from_config(cls, config: Config) -> 'NamelistComposition':
        """Create NamelistComposition from a Config object."""
        return cls(
            domain=config.domain,
            input_nml=config.input_nml,
            output_type=config.output_type,
            output_date=config.output_date,
            homog_count=config.homog_count,
            homog_input=config.homog_input
        )
    
    def validate_completeness(self) -> List[str]:
        """Validate that all required namelist components are present.
        
        Returns:
            List of missing or incomplete components
        """
        issues = []
        
        if self.domain is None:
            issues.append("Missing DOMAIN_NML configuration")
        else:
            if self.domain.start is None:
                issues.append("DOMAIN_NML missing start time")
            if self.domain.stop is None:
                issues.append("DOMAIN_NML missing stop time")
                
        if self.input_nml is None:
            issues.append("Missing INPUT_NML configuration")
            
        return issues
    
    def validate_consistency(self) -> List[str]:
        """Validate consistency between different namelist components.
        
        Returns:
            List of consistency issues
        """
        issues = []
        
        # Check that output types and dates are consistent
        if self.output_type and self.output_date:
            # Add consistency checks here
            pass
            
        # Check that homogeneous input counts match actual inputs
        if self.homog_count and self.homog_input:
            # We already do this in the validator
            pass
            
        return issues


# Convenience function for easy usage
def compose_namelists(config: Config) -> NamelistComposition:
    """Compose namelists from a Config object."""
    return NamelistComposition.from_config(config)